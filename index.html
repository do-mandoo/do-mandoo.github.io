<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"do-mandoo.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All Dev stories found in here">
<meta property="og:type" content="website">
<meta property="og:title" content="JINLOG">
<meta property="og:url" content="https://do-mandoo.github.io/index.html">
<meta property="og:site_name" content="JINLOG">
<meta property="og:description" content="All Dev stories found in here">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JinSol">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://do-mandoo.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>JINLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JINLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Awesome</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/09/02/%ED%95%A8%EC%88%98function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%ED%95%A8%EC%88%98function/" class="post-title-link" itemprop="url">함수function</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-02 22:14:08 / Modified: 22:14:20" itemprop="dateCreated datePublished" datetime="2020-09-02T22:14:08+09:00">2020-09-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>함수란?</li>
</ol>
<ul>
<li><p>자바스에서 가장 중요한 핵심 개념1!!!!!</p>
</li>
<li><p>또다른 자바스의 핵심개념인 스코프,실행컨텍스트,클로저,생성자함수에의한객체생성,메서드,this,프로포타입,모듈화 등이 모두 함수와 깊은 관련이 있다. = 함수는 자바스를 정확히 이해하고 사용하기 위해 피해갈수 없는 핵심중의 핵심임.</p>
</li>
<li><p>수학의 함수는 “입력(input)”을 받아 “출력(output)”을 내보내는 일련의 과정을 정의한것. 예를들어, f(x,y)=x+y라는 함수를 정의하고 이 함수에 두개의 입력 2,5를 전달하면 함수는 정의된 일련의 과정, 즉 x+y를 실행해서 7을 출력함. 함수는 마치 재료를 투입받아 제품을 생산하는 기계와 같음.</p>
</li>
<li><p>미리 정의해둔 함수를 실행하는것을 수식으로 표현하면 f(2,5)=7임.<br> 이때 함수 x,y는 함수내부로 입력을 받아들이는 변수이고,<br> 2,5는 함수에서 정의된 일련의 과정을 실행하기 위해 필요한 입력이고,<br> 7은 함수의 실행결과인 출력임.</p>
</li>
<li><p>이때 함수를 실행하기 위해 필요한 입력인 2,5는 입력을 받아들이는 변수 x,y를 통해 함수외부에서 함수내부로 전달됨. 함수의 실행결과인 출력은 함수 외부로 반환됨.</p>
</li>
<li><p>프로그램언어의 함수도 수학의 함수와 같은개념임</p>
</li>
<li><p>함수f(x,y)=x+y를 자바스함수로 표현해보자.<br> =&gt; function add(x,y){ </p>
<pre><code>      return x+y;
   &#125; // = f(x,y)=x+y
   add(2,5); // 7 = f(2,5)=7</code></pre>
<p>프로그래밍 언어의함수는 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행단위로 정의한것.<br>교안의 img참고</p>
</li>
<li><p>함수는 함수정의(function definition)를 통해 생성. 자바스의 함수는 다양한 방법으로 정의할 수 있음.<br>ex)  function add( x , y ) { </p>
<pre><code>      return x + y;
    &#125; // =&gt; 함수정의
    var result = add (2, 5); // =&gt; 함수호출
    console.log(result); // 7 =&gt;함수add에 인수2,5를전달하면서 호출하면 반환값 7을 반환함.</code></pre>
</li>
</ul>
<ol start="2">
<li>함수의 사용 이유</li>
</ol>
<ul>
<li>필요할 때 여러번 호출할 수 있음 = 실행시점으 ㄹ개발자가 결정할 수 있고 몇번이든 재사용이가능.= 코드의 재사용이라는 측면에서 코드중복을 제거하여 매우 유요하고 효율적임.</li>
<li>코드중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있음.</li>
<li>함수는 객체타입의 값임.=이름(식별자)을 붙일수 있음. 함수이름은 변수이름과 마찬가지로 함수자신의 역할을 잘 설명해서 함수내부코드를 이해하지 않고도 함수의 역할을 파악할 수 있게도와 코드의 가독성을 향상시킴.</li>
<li>코드는 동작하는것만이 존재목적이 아님. 코드는 개발자를 위한 문서임.= 사람이 이해할 수 있는코드 - 가독성이 좋은코드가 좋은 코드임!!</li>
</ul>
<ol start="3">
<li>함수 리터럴<br>자바스의 함수는 객체타입임.=숫자값을 리터럴로 생성하고 객체를 객체리터럴로 생성하는것처럼 함수도 함수리터럴로 생성할수 있음. 함수리터럴은 function키워드, 함수이름, 목록, 함수몸체 로 구성됨.</li>
</ol>
<ul>
<li>함수리터럴의 구성요소<ol>
<li>함수 이름<ul>
<li>식별자임=식별자 네이밍 규칙을 준수해야 함.</li>
<li>몸체 내에서만 참조할 수 있는 식별자임.</li>
<li>생략할 수 있음.이름이 있는 함수를 기명함수(named function),이름이 없는함수를 무명,익명함수(anonymous function)라 함.</li>
</ul>
</li>
<li>매개변수 목록<ul>
<li>0개 이상의 매개변수를 소괄호()로 감싸고 쉼표,로 구분함.</li>
<li>각 매개변수는 함수를 호출할 때 지정한 인수가 순서대로 할당됨.=매개변수 목록은 순서에 의미가 있음.</li>
<li>함수몸체내에서 변수와 동일하게 취급됨.  </li>
</ul>
</li>
<li>함수 몸체<ul>
<li>함수가 호출되었을 때 일괄적으로  실행될 문들을 하나의 실행 단위로 정의한 코드블록임.</li>
<li>함수몸체는 함수호출에 의해 실행됨.</li>
</ul>
</li>
</ol>
</li>
<li>리터럴은 값을 생성하기 위한 표기법임.notation. 따라서 함수리터럴도 평가되어 값을 생성하며, 이 값은 객체임. 즉 함수는 객체임.</li>
<li>함수는 객체지만 일반객체와 다름. 일반객체는 호출할 수 없지만 함수는 호출할 수 있음. 일반객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖음.</li>
<li>함수가 객체라는 사실!!! 은 다른 프로그래밍 언어와 구별되는 자바스의 중요한 특징임.</li>
</ul>
<ol start="4">
<li>함수 정의</li>
</ol>
<ul>
<li>함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말함. 자바스엔진에 의해 평가되어 함수객체가 됨.</li>
<li>함수 정의방법 4가지 (모든 함수정의 방식은 함수를 정의한다는 면에서 동일함.)<br>  ① 함수 선언문(function declaration/ function statement)<pre><code>   ex) function add( x, y ) &#123; return x + y; &#125;</code></pre>
  ② 함수 표현식(function expression)<pre><code>   ex) var add = function ( x, y ) &#123; return x + y; &#125;;</code></pre>
  ③ Function 생성자 함수(function constructor)<pre><code>   ex) var add = new function (&#39; x&#39; , &#39; y&#39; , &#39;return x + y&#39; );</code></pre>
  ④ 화살표 함수(arrow function) : ES6<pre><code>   ex) var add = ( x, y ) =&gt; x + y;</code></pre>
**변수 선언과 함수 정의!<pre><code>  : 변수는 &#39;선언(declaration)&#39; 한다고 했지만 함수는 &#39;정의(definition)&#39;한다고 표현했음. 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당됨. 따라서 ECMAScript사양에서도 변수에는 선언(variable declaration), 함수에는 정의(function definition)라고 표현함. 선언과 정의 차이!</code></pre>
4-1.함수 선언문</li>
<li>함수 선언문 사용해 함수 정의하는 방식<br>function add( x, y ) { <pre><code> return x + y; </code></pre>
 } // =&gt;함수 선언문<br>console.dir(add); // f add (x,y) . =&gt;함수 참조, 함수객체의 프로퍼티까지 출력.<br>console.log(add(2,5)); // 7 . =&gt; 함수 호출</li>
<li>함수 리터럴과 혛태가 동일하지만, 함수 선언문은 함수 이름을 생략할 수 없음!!<br> ex) function (x, y){… // 안됨.</li>
<li>표현식이 아닌 문.=변수에 할당할 수 없음. 하지만 함수선언문이 변수에 할당되는 것처럼 보임.<ul>
<li>이유: 자바스엔진이 코드의 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문 인 함수선언문으로 해석하는 경우와 표현식인 문 인 함수리터럴표현식으로 해석하는 경우가 있기 때문임. 함수선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수리터럴과 형태가 동일함. 이는 함수이름이 있는 기명함수리터럴은 함수선언문 또는 함수리터럴 표현식으로 해석될 가능성이 있다는 의미임.</li>
<li>예를 들어, { }은 블록문일수도 있고 객체리터럴일수도 있음.- 중의적표현임. 자바스엔진은 { }처럼 중의적인 코드안의 코드의 문맥에 따라 해석을 달리함. { }이 단독으로 존재하면 블록문으로, { }이 값으로 평가되어야할 문맥에서 피연산자로 사용되면 객체리터럴로 해석 = 동일한 코드도 코드의 문맥에 따라 해석이 달라질수있음.</li>
<li>가명함수리터럴도 중의적인 코드임. = 코드의 문맥에 따라 해석이 달라질 수 있음. 자바스엔진은 함수이름이 있는 함수리터럴을 단독으로 사용(값으로 평가되어야 하는 문맥에서 함수리터럴을 사용하지않는경우=함수리터럴을 피연산자로 사용하지 않는 경우)하면 함수선언문으로 해석, 함수리터럴값으로 평가되어야하는 문맥(함수리터럴을 변수에 할당하거나 피연산자로 사용)으로 사용하면 함수리터럴표현식으로 해석함. !!함수선언문이든 함수리터럴표현식이든 함수가 생성되는 것은 동일함. 하지만 함수생성할때 내부동작에는 차이가 있음.<br>ex1. 가명함수리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.<pre><code>    함수 선언문에서는 함수이름을 생략할 수 없다.
       function foo( ) &#123; console.log(&#39; foo &#39;); &#125;
       foo( ); // foo</code></pre>
ex2. 함수 리터럴을 피연산자로 사용하면 함수 선언문이아니라 함수리터럴표현식으로 해석된다.<pre><code>    함수 리터럴에서는 함수이름을 생랼할 수 있다.
       (function bar( ) &#123; console.log(&#39; bar &#39;);  &#125;);
       bar( ); // ReferenceError: bar is not defined</code></pre>
ex1에서 단독으로 사용된 함수리터럴(foo)은 함수 선언문으로 해석됨.<br>ex2에서 그룹연산자( )내에 있는 함수리터럴(bar)은 함수리터럴표현식으로 해석됨.</li>
<li>자바스엔진은 생성된 함수를 호출하기위해 함수이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 생성된곳에 생성된함수객체를 할당함.</li>
<li>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출함.<br>   ex) var add = function add( x, y ) { return x + y; } ; <pre><code>      console.log(add( 2, 5)); //7</code></pre>
 일때 함수 선언문으로 생성한 함수를 호출한것은 함수이름 add(function add)가아니라 자바스엔진이 암묵적으로 생성한 식별자 add(var add)인것임. 함수이름과 변수이름이 일치해서 함수이름으로 호출되는것같지만 사실은 식별자로 호출된것임.!!  단, 함수선언문과 함수표현식이 정확히 동일하게 동작하는것은 아님.<br>4-2.함수 표현식</li>
</ul>
</li>
<li>자바스의 함수는 객체타입의 값임. 자바스함수는 값처럼 변수에 할당할 수도 있고, 프로퍼티값이 될수도 있고, 배열의 요소가 될수도 있음. 값의 성질을 갖는 객체를 일급 객체(first-class object)라 함. 자바스함수는 일급객체임!! = 함수를 값처럼 자유롭게 사용할 수 있다는 의미.</li>
<li>일급객체인 함수는 함수리터럴로 생성한 함수객체를 변수에 할당할 수 있음.  = 함수정의방식을 함수표현식(function expression)이라 함.<br>  ex) 함수선언문으로 정의함 add 함수를 함수 표현식으로 바꿔서 정의함.<pre><code>     var add = function ( x, y ) &#123; return x + y; &#125;;
     console.log(add(2,5)); // 7</code></pre>
 함수리터럴의 함수이름을 생략할 수 있고, 생략하는것이 일반적임.=익명함수(anonymous function) <ul>
<li>함수를 호출할때는 함수이름이 아니라 함수객체를 가리키는 식별자사용. 함수이름은 함수몸체 내부에서만 유효한 식별자!!이므로 함수이름으로 함수호출할 수 없음.<br>ex)  var add = function foo ( x, y ) { return x + y; };<pre><code>   console.log(add(2,5)); // 7
   console.log(foo(2,5)); // ReferenceError: foo is not defined</code></pre>
</li>
<li>함수 선언문 = “표현식이 아닌 문”</li>
<li>함수 표현식 = “표현식인 문”<br>4-3.함수 생성 시점과 함수 호이스팅<br>ex)</li>
<li>함수 참조      console.dir(add); // f add( x,y )<pre><code>                  console.dir(sub); // undefined   </code></pre>
</li>
<li>함수 호출      console.log(add(2,5)); // 7<pre><code>                  console.log(sub(2,5)); // TypeError: sub is nat a function</code></pre>
</li>
<li>함수 선언문  function add(x,y) { return x+y; }</li>
<li>함수 표현식  var sub = function (x,y) { return x- y ; };</li>
</ul>
</li>
</ul>
<p>ex에서와 같이 함수 선언문으로 정의한 함수는 함수선언문이전에 호출할 수 있음. 함수표현식으로 정의한 함수는 함수표현식이전에 호출할수 없음. =&gt; 함수선언문으로 정의한 함수와 함수표현식으로 정의한 함수의 생성시점이 다르기때문.<br>모든 선언문이 그렇듯 함수선언문도 코드가 한줄씩 순차적으로 실행되는 시점인(runtime) 이전에 자바스엔진에 의해 먼저 실행됨.= 함수선언문으로 함수를 정의하면 런타임 이전에 함수객체가 먼저 생성됨, 자바스 엔진은 함수이름과 동일한이름의 식별자를 암묵적으로 생성하고 생성된함수객체를 할당함.=&gt; 코드가 한줄씩 순차적으로 실행되기시작하면 런타임에는 이미 함수객체가 생성되어있고 함수이름과 동일한 식별자에 할당까지 완료된상태임. 따라서 함수선언문 이전에 함수를 참조할 수 있으며 호출할수도 있음.<br>이처럼 함수선언문이 코드의 선두로 끌어올려진것처럼 동작하는 자바스 고유의 특징을 함수 호이스팅(Function Hoisting)이라 함.<br>함수호이스팅과 변수호이스팅은 미묘한 차이가 있음.<br>var키워드를 사용한 변수선언문과 function키워드를 사용하는 함수선언문은 런타임 이전에 자바스엔진에 의해 먼저실행되어 식별자를 생성한다는 점에서 동일하지만 var키워드로 선언된 변수는 undefined로 초기화되고, 함수선언문을 통해 암묵적으로 생성된식별자는 함수객체로 초기화됨. 따라서 bar키워드를 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가!되지만 함수선언문으로 정의한 함수를 함수선언문이전에 호출하면 함수호이스팅에 의해 호출!이가능함.<br>함수표현식은 변수에 할당되는 값이 함수리터럴인 문임. 따라서 함수표현식은 변수선언문과 변수할당문을 한번에 기술한 축약표현과 동일하게 동작함.<br>변수선언은 런타임이전에 실행되어 undefined로 초기화되지만, 변수할당문의 값은 할당문이 실행되는 시점인 런타임에 평가되므로 함수표현식의 함수리터럴도 할당문이 실행되는 시점에 평가되어 함수객체가 됨.<br>따라서 함수표현식으로 함수를정의하면 함수호이스팅이 발생한느것이 아니라 변수호이스팅이 발생함.!!<br>함수표현식으로 정의한 함수는 반드시 함수표현식 이후에 참조 또는 호출해야함.<br>함수호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야한다는 당연한 규칙을 무시하기때문에 함수선언문대신 함수표현식 사용을 권장함.<br>4-4.function 생성자 함수<br>자바스가 기본제공하는 빌트인 함수인 Function 생성자함수(=constructor function, 객체를 생성하는 함수를 말함. 생성방식은 객체리터럴 외에도 다양한 방벙이 있음.)에 매개변수목록과 함수몸체를 문자열로 전달하면서 new연산자와함께 호출하면 함수객체를 생성해서 변환함. (new연산자 없이 호출해도 결과는 동일.)</p>
<ul>
<li>Function생성자함수로 add함수 생성해보기<ol>
<li>var add1 = new Function ( ‘x’, ‘y’, ‘return x + y’ );<br>  console.log(add1(2,5)); // 7</li>
<li>var add2 = (function( ) {<pre><code>   var a = 10;
   return function ( x, y) &#123;
      return x + y + a;
   &#125;</code></pre>
  }( ));<br> console.log(add2(1,2)); // 13   </li>
<li>var add3 = (function( ) {<pre><code>   var a = 10;
   return  new Function ( &#39;x&#39;, &#39;y&#39;, &#39;return x + y + a;&#39;);</code></pre>
  }( ));<br> console.log(add3(1,2)); // ReferenceError: a is not defined<br>Function 생성자함수로 함수를 생성하는 방식은 일반적이지않으며 바람직하지도 않음.<br>4-5.화살표 함수<br>ES6에서 새롭게 도입된 화살표함수(arrow function)는 function 키워드 대신 화살표 (=&gt;, fat arrow)를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있음.<br>화살표함수는 항상 익명함수로 정의함.<br>ex) const add = ( x, y ) =&gt; x + y;<br>console.log(add(2,5)); // 7<br>화살표함수는 기존함수선언문 또는 함수표현식을 완전히 대체하기위해 디자인된것은 아님. 화살표함수는 기존함수보다 표현만 간략한것이 아니라 내가부동작또한 간략화되어있음.<br>화살표함수는 생성자함수로 함부로사용할수 없고, 기존의 함수와 this바인딩방식이 다르고, prototype프로퍼티가 없고, arguments객체를 생성하지않음.</li>
</ol>
</li>
</ul>
<ol start="5">
<li>함수 호출<br>함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출함. 함수호출연산자 내에는 0개 이상의 인수를 쉼표로 구분해서 나열함. 함수를 호출하면 현재의 실행흐름을 중단하고 호출된 함수로 실행흐름을 옮김. 이때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행됨.<br>5-1.매개변수와 인수<br>함수를 실행하기위해 필요한 값을 함수외부에서 함수내부로 전달할 필요가 있는경우 매개변수(parameter,인자)를 통해 인수(argument)를 전달함. 인수는 값으로 평가될 수 있는 표현식이어야함. 인수는 함수를 호출할때지정,개수와 타입에 제한이 없음.<br>매개변수는 함수를 정의할때 선언, 함수몸체내부에서 변수와 동일하게 취급함.=함수가 호출되면 함수 몸체내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당됨. 함수가 호출될때마다 매개변수가 거치는 단계는 교안을 통해서 보자.<br>매개변수는 함수몸체내부에서만 참조할수있고 함수몸체외부에서는 참조할수없음.= 매개변수의 스코프(유효범위)는 함수내부임.<br>함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크함. = 함수를 호출할때 매개변수의 개수만큼 인수를 전달하는것이 일반적이지만 그렇지않은 경우에도 에러가 발생하지는 않는다. 인수가 부족해서 인수가 할당되지않은 매개변수의 값은 undefined임.<br>예를 들어<br>function add (x,y) {<br>   return x+y;<br> }<br>console.log(add(2)); // NaN<br>일때 매개변수x에는 인수2가 전달되지만, 매개변수y에는 전달할인수가 없어서 undefined로 초기화된 상태 그대로임. 따라서 함수몸체의 문 x+y 는 2+undefined와 같아서 NaN이 반환됨.<br>매개변수보다 인수가 더 많은 경우 초과된 인수는 암묵적으로 arguments객체의 프로퍼티로 보관이 됨.<br>예를 들어<br>function add (x,y) {<br> console.log(arguments); // Arguments(3) [2,5,10, callee: f Symbol(Symbol.iterator): f]<br>  return x+y;<br>}<br>console.log(add(2, 5, 10)); // 7<br>arguments객체는 함수를 정의할 때, 매개변수 개수를 확정할 수 없는 가변인자함수를 구할때 유용하게 사용됨.<br>5-2.인수 확인<br>ex) function add(x,y) {<pre><code>   return x+y;
&#125;
console.log(add(2)); // NaN
console.log(add(&#39;a&#39;, &#39;b&#39;)); // &#39;ab&#39;</code></pre>
예를 보면 자바스 문법상 어떠한 문제도 없으므로 자바스엔진은 아무런 이의없이 위 코드를 실행할것임. 이러한 상황이 발생한 이유 두가지.<pre><code>1). 자바스함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음.
2). 자바스는 동적타입언어. = 자바스함수는 매개변수의 타입을 사전에 지정할수 없음.</code></pre>
따라서 자바스의 경우 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있음.!</li>
</ol>
<ul>
<li>함수 내부에서 적절한 인수가 전달되었는지 확인하더라도 부적절한 호출은 사전에 방지할 수는 없고 에러는 런타임에 발생하게됨. 따라서 타입스크립트와같은 정적타입을 선언할수있는 자바시의 상위확장을 도입해서 컴파일시점에 부적절한 호출을 방지할수있게하는것도 하나의 방법임</li>
<li>단축평가를 사용해 매개변수에 기본값을 할당하는 방법도 있음.</li>
<li>ES6에서 도입된 매개변수기본값을 사용하면 함수내에서 수행하던 인수체크및 초기화를 간소화할수있음. 매개변수기본값은 매개변수에 인수를 전달하지않았을경우와 undefined를 전달한 경우에만 유효함.<br>5-3. 매개변수의 최대 개수</li>
<li>ECMAScript 사양에서는 매개변수의 최대개수에대해 명시적으로 제한하고있지않지만, 물리적한계는 있으므로 자바스엔진마다 매개변수의 최대개수에 대한 제한이 있겠지만 충분히 많은 매개변수르 지정할수 있음.</li>
<li>매개변수는 순서에 의미가 있음. = 매개변수가 많아지면 함수를 호출할때나 전달해야할 인수의 순서를 고려해야함. 이는 함수의 사용법을 이해하기 어렵게만들고, 실수를 발생시킬가능성을 높이고, 유지보수성이 나쁘다(매개변수의 개수나 순서가 변경되면 함수의 호출방법도 바뀌므로 함수를 사용하는 코드전체가 영향을 받음).</li>
<li>따라서 이상적인 매개변수 개수는 0개이며 적을수록 좋고, 한 가지 일만 해야하며 가급적 작게 만들어야 함. 최대 3개이상을 넘지않는것을 권장함.</li>
<li>객체를 인수로 사용하는경우 프로퍼티키만 정확히지정하면 매개변수의 순서를 신경쓰지않아도 됨. 또한 명시적으로 인수의 의미를 설명하는 프로퍼티키를 사용하게되므로 코드의 가독성도 좋아지고 실수도 줄어드는 효과도 있음.</li>
<li>하지만 주의!! 함수 외부에서 함수내부로 전달한 객체를 함수내부에서 변경하면 함수외부의 객체가 변경되는 부수효과(side effect)가 발생함.<br>5-4. 반환문</li>
<li>함수는 return키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행결과를 함수외부로 반환(return)할수있음.</li>
<li>multiply함수는 두개의 인수를 전달받아 곱한 결과값을 return키워드를 사용해 반환함. 함수는 return키워드를 사용해 자바스에서 사용가능한 모든값을 반환할 수 있음. 함수호출표현식은 return키워드가 반환한 표현식의 평가결과=반환값으로 평가됨.</li>
<li>반환문의 역할 두가지<br> 1). 반환문은 함수의 실행을 중단하고 함수몸체를 빠져나감. 반환문이후에 다른문이 존재하면 그 문은 실행되지않고 무시됨.<br> 2). 반환문은 return키워드 뒤에오는 표현식을 평가해 반환함. return키워드뒤에 반환값으로 사용할표현식을 명시적으로 지정하지않으면 undefined가 반환됨.</li>
<li>반환문은 생략할수 있음 .이때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환함.</li>
<li>return키워드와 반환값으로 사용할 표현식사이에 줄바꿈이 있으면 세미콜론 자동삽입기능에의해 세미콜론이 추가되어 의도치않은 결과가 발생할 수있음.</li>
<li>반환문은 함수 몸체내부에서만 사용할수 있음. 전역에서 반환문사용하면 문법에러(SyntaxError: Illegal return statement)가 발생.</li>
<li>참고로 Node.js는 모듈 시스템에 의해 파일별로 독립적인 파일스코프를 갖음. 따라서 Node.js환경에서는 파일의 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않음.</li>
</ul>
<ol start="6">
<li>참조에 의한 전달과 외부 상태의 변경</li>
</ol>
<ul>
<li>원시값은 값에 의한 전달(pass by value), 객체는 참조에 의한 전달(pass by reference) 방식으로 동작함. 매개변수도 함수몸체내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에의한전달, 참조에의한전달방식을 그대로 따름.</li>
<li>함수를 호출하면서 매개변수에 값을 전달하는 방식을 값에의한 호출 (call by value), 참조에 의한 호출(call by reference)로 구별해 부르는 경우도 있으나 동작방식은 값에 의한 전달, 참조에 의한 전달과 동일함.</li>
<li>원시타입인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경(재할당을 통한 교체)해도 원본은 훼손되지 않음.= 외부상태, 함수외부에서 함수몸체내부로 전달한 원시값의 원본을 변경하는 어떠한 부수효과도 발생하지 않음.</li>
<li>하지만 객체타입인수는 참조값이 복사되어 매개변수에 전달되기때문에 함수몸체에서 참조값을 통해 객체를 변경할 경우 원본이 훼손됨.=외부상태,함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원본객체가 변경되는 부수효과가 발생함.</li>
<li>이처럼 하수가 외부상태를 변경하면 상태변화를 추적하기 어려워짐. 이는 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 됨. 함수 내부의 동작을 유심히 관찰하지 않으면 외부상태가 변하는지 아닌지 알기어렵기때문. 언제나 그러하듯 논리가 간단해야 버그가 숨어들지 못한다!</li>
<li>이러한 현상은 객체가 변경할 수 있는 값이며, 참조에의한 전달방식으로 동작하기때문에 발생하는 부작용임. 여러 변수가 참조에 의한 전달방식을 통해 참조값을 공유하고있다면 이 변수들은 언제든지 참조하고있는 객체를 직접 변경할수있다. 복잡한 코드에서 의도치않은 객체의 변경을 추적하는것은 어려운일이다. 객체의 변경을 추적하려면 옵저버(Observer)패턴등을 통해 객체를, 참조를공유하는 모든이들에게 변경사실을 통지하고 이에 대처하는 추가대응이 필요함.</li>
<li>이러한 문제의 해결방법중 하나는 객체를 불변객체(immutable object)로 만들어 사용하는것임. 객체의 복사본을 새롭게 생성하는 비용은 들지만 객체를 마치 원시값처럼 변경불가능한 값으로 동작하게 만드는 것. 이를통해 객체의 상태변경을 원천봉쇄하고 객체의 상태변경이 필요한경우에는 객체의 방어적복사(defensive copy)를 통해 원본객체를 완전히 복제,=깊은복사(Deep copy)를 통해 새로운 객체를 생성하고 재할당을 통해 교체함. 이를 통해 외부상태가 변경되는 부수효과를 없앨수 있다.</li>
<li>외부상태를 변경하지않고 외부상태에 의존하지도않는 함수를 순수함수라 함. 순수함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍패러다임을 함수형프로그래밍이라 함.</li>
</ul>
<ol start="7">
<li>다양한 함수의 형태<br>7-1.즉시 실행 함수</li>
</ol>
<ul>
<li>함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행함수(IIFE,Immediately Invoked Function Expression)라고 함. 즉시 실행함수는 단 한번만 호출되며 다시 호출할수 없음.</li>
<li>즉시실행함수는 이름이 없는 익명함수를 사용하는것이 일반적임. 함수이름이 있는 기명즉시실행함수도 사용할수 있지만 그룹연산자( ) 내의 기명함수는 함수선언문이 아니라 함수리터럴로 평가되며 함수이름은 함수몸체에서만 참조할수있는 식별자이므로 즉시실행함수를 다시 호출할수는 없음.<br>ex) 익명 즉시 실행 함수           기명 즉시 실행 함수<pre><code> (function( ) &#123;....&#125; ( )) ;            (function foo( ) &#123;....&#125; ( )) ;</code></pre>
</li>
<li>즉시 실행함수는 반드시 그룹연산자 ( )로 감싸야함. 안그러면 에러발생. 기명함수도 마찬가지임.</li>
<li>익명 즉시 실행함수에서  그룹연산자( )로 감싸지 않을경우 생기는 에러의 이유 : 함수 선언문으로 인식하고, 함수 선언문은 함수이름을 생략할 수 없어서 함수선언문의 형식에 맞지않아 에러가 발생함.</li>
<li>기명 즉시 실행함수에서 그룹연산자( )로 감싸지 않을경우 생기는 에러의 이유 : 자바스엔진이 암묵적으로 수행하는 세미콜론 자동삽입기능에 의해 함수선언문이 끝나는위치, 즉 함수코드 블록의 닫는 중괄호{ } 뒤에 ; 이 암묵적으로 추가되기 때문에 함수 선언문 뒤의 ( )는 함수 호출연산자가 아닌 그룹연산자로 해석되고, 그룹연산자에 피연산자가 없기때문에 에러가 발생함.</li>
<li>그룹연산자의 피연산자는 값으로 평가되므로 기명 또는 무명함수를 그룹연산자로 감싸면 함수리터럴로 평가되어 함수객체가 됨.</li>
<li>즉, 그룹연산자로 함수를 묶은 이유는 먼저 함수리터럴을 평가해서 함수객체를 생성하기위해서임. 따라서 먼저 함수리터럴을 평가해서 함수객체를 생성할수있다면 그룹연산자이외의 연산자를 사용해도 좋지만 우리는<br>   ( function ( ) {<pre><code>     //  ...
&#125;( )) ;</code></pre>
의 방식을 사용함.</li>
<li>즉시 실행함수도 일반함수처럼 값을 반환할 수 있고 인수를 전달할수도 있음.<br>-&gt; 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있음.<pre><code>var res = (function () &#123;
   var a = 3;
   var b = 5;
   return a * b;</code></pre>
   }());<br>   console.log(res); // 15</li>
</ul>
<p>-&gt;즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있음.<br>    res = (function (a, b) {<br>         return a * b;<br>    }(3, 5));<br>    console.log(res); // 15<br>즉시 실행함수내에 코드를 모아두면 혹시있을수도있는 변수나 함수이름의 충돌을 방지할수있다.<br>7-2.재귀함수</p>
<ul>
<li>함수가 자기자신을 호출하는것을 재귀호출(recursive call)이라 함. 재귀함수(recursive function)는 자기자신을 호출하는 행위, 즉 재귀호출을 수행하는 함수를 말함.</li>
<li>반복문없이 구현할수 있음.</li>
<li>재귀함수는 자신을 무한재귀호출한다. 따라서 재귀함수내에는 재귀호출을 멈출수있는 탈출조건을 반드시 만들어야함. 탈출조건이 없으면 함수가 무한호출되어 스택 오버플로(stack overflow)에러가 발생함.</li>
<li>재귀함수는 반복되는처리를 반복문없이 구현할수 있다는장점이 있지만 무한반복에 빠질 위험이있고, 이로인해 스택오버플로 에러를 발생시킬수 있으므로 주의해서 사용해야함. </li>
<li>재귀함수는 반복문을 사용하는것보다 재귀함수를 사용하는편이 더 직관적으로 이해하기쉬울때만 한정적으로 사용하는것이 바람직함,<br>7-3. 중첩함수</li>
<li>함수 내부에 정의된 함수를 중첩함수(nested function)또는 내부함수(inner function)이라 함. 그리고 중첩함수를 포함하는 함수는 외부함수(outer function)라 부름. 일반적으로 중첩함수는 자신을 포함하는 외부함수를 돕는 헬퍼함수(helper function)의 역할을 함.<br>ex)<br>function outer() {<br>var x = 1;<br>function inner() {  // -&gt;중첩 함수<br>  var y = 2;<br>  console.log(x + y); // 3 ,-&gt;외부 함수의 변수를 참조할 수 있다.<br>}<br>inner();<br>}<br>outer();</li>
<li>스코프와 클로저에 깊은 관련이 있음.<br>7-4. 콜백 함수</li>
<li>교안 깊이 공부</li>
<li>함수의 매개변수를 통해 다른함수의 내부로 전달되는 함수를 콜백함수(callback function)라고 하며, 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차함수(Higher-Order Function, HOF)라고 함. 매개변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍 패러다임에서 고차함수라 함.</li>
<li>중첩함수가 외부함수를 돕는 헬퍼함수의 역할을 하는것처럼 콜백함수도 고차함수에 전달되어 헬퍼함수의 역할을 함. 단, 중첩함수는 고정되어있어서 교체하기 곤란하지만 콜백함수는 함수외부에서 고차함수내부로 주입하기때문에 자유롭게 교체할수 있다는 장점이 있음.= 고차함수는 콜백함수를 자신의 일부분으로 합성함.</li>
<li>고차함수는 매개변수를 통해 전달받은 콜백함수의 호출시점을 결정해서 호출함. = 콜백함수는 고차함수에 의해 호출되며 이때 고차함수는 필요에따라 콜백함수에 인수를 전달할수 있음. 따라서 고차함수에 콜백함수를 전달할때 콜백함수를 호출하지않고 함수자체를 전달해야함.</li>
<li>콜백함수는 비동기처리뿐 아니라 배열고차함수에서도 사용됨.자바스에서 배열은 사용빈도가 매우 높은 자료구조이고 배열을 다룰때 배열고차함수는 매우 중요함.<br>7-5.순수 함수와 비순수 함수</li>
<li>함수형 프로그래밍에서는 어떤 외부 상테에 의존하지도않는, 즉 부수효과가 없는 함수를 순수 함수(pure function)라 하고, 외부상태에 의존하거나 외부상태를변경하는, 즉 부수효과가 있는 함수를 비순수 함수(impure function)라고 함.</li>
<li>순수 함수<ul>
<li>순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수임. = 순수함수는 어떤 외부상태에도 의존하지않고 오직 매개변수를 통해 함수내부로 전달된 인수에게만 의존해 반환값을 만듦. 함수의 외부상태에 의존하는 함수는 외부상태에 따라 반환값이 달라짐.</li>
<li>특징은 함수의 외부상태를 변경하지 않는다는것. = 순수함수는 어떤 외부상태에도 의존하지않으며 외부상태를 변경하지도 않는 함수임.</li>
</ul>
</li>
<li>비순수 함수<ul>
<li>반대로 함수의 외부상태에따라 반환값이 달라지는 함수, 외부상태에 의존하는 함수를 비순수 함수라고 함.</li>
<li>특징은 순수함수와는 달리 함수외부의 상태를 변경하는 부수효과(side effect)가 있다는 것. 비순수함수는 외부상태에 의존하거나 외부상태를 변경하는 함수임.</li>
</ul>
</li>
<li>함수 내부에서 외부상태를 직접참조하면 외부상태에 의존하게 되어 반환값이 변할수 있고, 외부 상태도 변경할 수 있으므로 비순수 함수가 됨. 함수 내부에서 외부상태를 직접참조하지않더라도 매개변수를 통해 객체를 전달받으면 비순수 함수가 됨.</li>
<li>함수가 외부상태를 변경하면 상태변화를 추적하기 어려워짐. 따라서 함수외부상태의 변경을 지양하는 순수함수를 사용하는것이 좋음. 비순수 함수는 코드의 복잡성을 증가시킴. 비순수 함수를 최대한 줄이는 것은 부수효과를 최대한 억제하는것과 같음.</li>
<li>함수형 프로그래밍은 순수함수와 보조함수의 조합을 통해 외부상태를 변경하는 부수효과를 최소화해서 불변성(immutability)을 지향하는 프로그래밍패러다임임. 로직내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결하며, 변수사용을 억제하거나 생명주기를 최소화해서 상태변경을 피해 오류를 최소화하는것을 목표로 함. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게해서 가독성을 해치고, 변수의 값은 누군가에 의해 언제든지 변경될수있어 오류발생의 근본적원인이 될수있기 떄문임.</li>
<li>함수형 프로그래밍은 결국 순수함수를 통해 부수효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이라고 할 수있음. 자바스는 멀티 패러다임언어이므로 객체지향 프로그래밍뿐만아니라 함수형프로그래밍을 적극적으로 활용하고 있음.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/27/%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4object/" class="post-title-link" itemprop="url">객체리터럴object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:43:52 / Modified: 17:44:04" itemprop="dateCreated datePublished" datetime="2020-08-27T17:43:52+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>객체란?<br>Object. 자바스는 객체기반의 프로그래밍 언어이며, 자바스를 구성하는 거의 “모든 것”이 객체. 원시값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체임.<br>원시 타입은 단 하나의 값만을 나타내지만 객체타입(object/ reference type)은 다양한 타입의 값(원시값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조(data structure)임. 또한 원시타입의 값 = 원시값은 변경불가능한 값(immutable value)이지만, 객체타입의값=객체는 변경가능한 값(mutable value)임.<br>객체는 0개 이상의 프로퍼티로 구성된 집합, 프로퍼티는 키(key)와 값(value)으로 구성됨.<br>ex) var person = {</p>
<pre><code> name : &#39;Lee&#39;,
 age : 20</code></pre>
<p>   }; // name과 age는 프로퍼티 키, Lee와 20은 프로퍼티 값. 이 둘을 어우르는것이 프로퍼티.<br>자바스에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있음. 자바스의 함수는 일급객체이므로 값으로 취급할 수 있음. 따라서 함수도 프로퍼티 값으로 사용 할 수 있음. 프로퍼티 값이 함수일경우 일반함수와 구분하기 위해 메서드(method)라고 부른다.<br>ex) var counter = {</p>
<pre><code>  num : 0,                   //프로퍼티
  increase : function() &#123;   //메서드영역 시작
    this.num++;
  &#125;                                        //메서드영역 끝</code></pre>
<p>   };<br>이처럼 객체는 프로퍼티와 메서드로 구성된 집하체임.<br>프로퍼티와 메서드의 역할 : </p>
<ul>
<li>프로퍼티: 객체의 상태를 나타내는 값(data)</li>
<li>메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)<br>이처럼 객체는 상태와 동작을 하나의 단위로 구조화할 수 있어 유용함.<br>** 객체와 함수<br>: 자바스의 객체는 함수와 밀접한 관계를 가짐. 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 함. 자바스에서 함수와 객체는 분리해서 생각할 수 없는 개념=객체를 이해해야 함수를 제대로 이해, 함수를 이해해야 객체를 정확히 이해 가능.</li>
</ul>
</li>
<li><p>객체 리터럴에 의한 객체 생성</p>
</li>
</ol>
<ul>
<li>C++이나 자바와 같은 클래스기반 객체지향언어는 클래스를 사전에 정의하고 필요한 시점에 new연산자와 함께 생성자(constructor)를 호출하여 인스턴스(instance: 클래스에 의해 생성되어 메모리에 저장된 실체를 말함. 객체지향프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념임. 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 함. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성함.</li>
<li>자바스는 프로토타입 객체지향언어로 클래스기반 객체지향언어와는달리 다양한 객체 생성 방법을 지원함. -&gt; 객체 리터럴, Object생성자 함수, 생성자함수, Object.create메서드, 클래스(ES6)<br>이러한 객체 생성 방법중에서 가장일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법임. 리터럴literal은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법을 말함. 객체리터럴은 객체를 생성하기 위한 표기법임.!!!!</li>
<li>객체 리터럴은 중괄호({…})내에 0개 이상의 프로퍼티를 정의함. 변수에 할당이 이루어지는 시점에 자바스엔진은 객체리터럴을 해석해서 객체를 생성함.<br>만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성됨.<br>객체 리터럴의 중괄호는 코드블록을 의미하지 않음!!! 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않음. 하지만 객체 리터럴은 값으로 평가되는 표현식임. = 객체리터럴의 닫는 중괄호 뒤에는 세미콜론 붙임.</li>
<li>객체리터럴은 자바스의 유연함과 강력함을 대표하는 객체 생성 방식임. 객체를 생성하기 위해 클래스를 먼저 정의하고 new연산자와 함께 생성자를 호출할 필요가 없음. 숫자값이나 문자열을 만드는것과 유사하게 리터럴로 객체를 생성함. 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있음.</li>
<li>객체리터럴 외의 객체생성방식은 모두 함수를 사용해 객체를 생성함</li>
</ul>
<ol start="3">
<li>프로퍼티</li>
</ol>
<ul>
<li>객체는 프로퍼티property들의 집합이며 프로퍼티는 키key와 값value로 구성됨.</li>
<li>프로퍼티 나열할때는 쉼표( , )로 구분. 일반적으로 마지막프로퍼티뒤에는 쉼표사용안하지만 사용해도 됨.</li>
<li>프로퍼티 키와 프로퍼티 값으로 사용할수 있는 값:<br>  -프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값<br>  -프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값</li>
<li>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로서 식별자역할을 함. 하지만 반드시 식별자네이밍규칙을 따라야하는것은 아님. 단! 미묘한차이는 있음.</li>
<li>심벌값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용함. 이때 프로퍼티 키는 문자열이므로 따옴표( ‘ ‘ 또는 “ “ )로 묶어야 함. 하지만 식별자네이밍규칙을 준수하는 이름(=자바스에서 사용가능한 유요한 이름)인경우 따옴표 생략 가능.= 식별자네이밍규칙 따르지 않는 이름에는 반드시 따옴표 사용!</li>
<li>가급적 식별자네이밍규칙을 준수하는 프로퍼티 키를 사용할것을 권장!!</li>
<li>문자열 또는 문자열로 평가할수있는 표현식을 사용해 프로퍼티키를 동적으로 생성할수 있음. 사용할 프로퍼티키를 대괄호( […] )로 묶어서 사용.</li>
<li>빈 문자열을 프로퍼티키로 사용해도 에러는나지않지만 키로서 의미를갖지 못하니까 권장하지 않음.</li>
<li>프로퍼티 키에 문자열이나 심벌값 이외의 값을 사용하면 암묵적타입변환을 통해 문자열이 됨. ex)프로퍼티키로 숫자리터럴사용하면 따옴표는 붙지않지만 내부적으로는 문자열로 변환됨.</li>
<li>var, function과 같은 예약어를 프로퍼티 키로 사용해도 에러발생안함.하지만 예상치 못한 에러발생의 여지가 있으니 권장안함.</li>
<li>이미 존재하는 프로퍼티키를 중복선언하면 나중에 선언한프로퍼티로 덮어씀. 에러가 발생하지않으니 주의!!</li>
</ul>
<ol start="4">
<li><p>메서드<br>자바스에서 사용할 수 있는 모든 값은 프로퍼티값으로 사용할수 있다고 했다. 자바스의 함수는 객체다. 따라서 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있음.<br>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드method라 부름.= 메서드는 객체에 묶여있는 함수를 의미.<br>메서드 내부에서 사용한 this키워드는 객체자신을 가리키는 참조변수임.일단간단하게 이렇게 알고있기.</p>
</li>
<li><p>프로퍼티 접근</p>
</li>
</ol>
<ul>
<li>접근방법 두가지<br>  1- 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법(dot notation)<br>  2- 대괄호 프로퍼티 접근 연산자([…])를 사용하는 대괄호 표기법(bracket notation)</li>
<li>프로퍼티키가 식별자네이밍규칙을 준수하는 이름(=자바스에서 사용가능한 이름)이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있음.</li>
<li>마침표 프로퍼티 접근 연산자 또는 대괄호 프로퍼티 접근 연산자의 좌측에는 객체로 평가되는 표현식을 기술함. 마침표 프로퍼티 접근 연산자의 우측 또는 대괄호 프로퍼티 접근 연산자의 내부에는 프로퍼티 키를 지정함.</li>
<li>대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 함. 그렇지않으면 자바스엔진은 식별자로 해석하기 때문. ex) [‘name’] (O) . <a href="X">name</a></li>
<li>객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환함. 이때 ReferenceError가 발생하지 않게 주의!!!</li>
<li>프로퍼티키가 식별자네이밍규칙을 준수하지않는 이름(=자바스에서 사용가능하지 않는 이름)은 반드시 대괄호 표기법을 사용해야함. 단! 프로퍼티키가 숫자로 이루어진 문자열인경우 따옴표 생략가능. 그 외의 경우는 반드시 대괄호 내에 따옴표로 감싼 문자열이어야만 함!!</li>
<li>ex) person.last-name; // 1.브라우저환경: NaN , 2.Node.js환경:ReferenceError  //person[‘last-name’]; 이 맞는 표기.<br>브라우저 환경과 Node.js 환경에서의 실행결과가 다른 이유는  person.last-name을 실행할때 ①자바스엔진은 person.last를 평가②name식별자로 해석됨. Node.js환경은 name식별자 선언이 없으므로, 브라우저환경은 name이라는 전역변수가 암묵적을 존재. 간단하게는 이렇게 다르다. 자세한 것은 교안(나중에 잘 정리해서 추가하기)확인.</li>
</ul>
<ol start="6">
<li><p>프로퍼티 값 갱신<br>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됨.<br>ex) var person = { name: ‘Lee’ };</p>
<pre><code> person.name = &#39;Kim&#39;; //person 객체에 name프로퍼티가 존재하므로 name프로퍼티 값이 갱신됨.
 console.log(person); // &#123;name: &quot;Kim&quot;&#125;</code></pre>
</li>
<li><p>프로퍼티 동적 생성<br>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당됨.<br>ex) var person = { name: ‘Lee’};</p>
<pre><code> person.age=20; // person객체에 age프로퍼티 존재안함. 선언때 프로퍼티가 동적으로 생성되고 값이 할당됨.
 console.log(person);// &#123;name: &quot;Lee&quot;, age: 20&#125;</code></pre>
</li>
<li><p>프로퍼티 삭제<br>delete연산자는 객체의 프로퍼티를 삭제함. 이때 delete연산자의 피연산자는 프로퍼티값에 접근할 수 있는 표현식이어야 함. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시됨.!<br>ex) var person = { name: ‘Lee’};</p>
<pre><code>  person.age=20; // 프로퍼티 동적 생성
  delete person.age; // person 객체에 age프로퍼티 존재하므로 삭제가능.
  delete person.address; // person객체에 address프로퍼티 존재안함으로 에러 발생하지 않음.
  console.log(person); // &#123;name: &quot;Lee&quot;&#125;</code></pre>
</li>
<li><p>ES6에서 추가된 객체 리터럴의 확장 기능<br>ES6에서는 더욱 간편하고 표현력있는 객체 리터럴의 확장기능을 제공함.<br>9-1.프로퍼티 축약 표현<br>객체리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성됨. 프로퍼티 값은 변수에 할당된 값= 식별자 표현식일 수도 있음.<br>ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수이름과 프로퍼티 키가 동일한 이름일때, 프로퍼티키를 생략(property shorthand)할 수 있음. 이때 프로퍼티 키는 변수 이름으로 자동 생성됨.<br>9-2.계산된 프로퍼티 이름<br>문자열 또는 문자열로 타입변환할 수있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도있음. 단, 프로퍼티키로 사용할 표현식을 대괄호([…])로 묶어야 함. 이를 계산된 프로퍼티 이름(computed property name)이라 함.<br>ES6에서는 객체리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생산할 수 있음.<br>9-3.메서드 축약 표현<br>ES6에서 : 메서드 정의할 때, function키워드를 생략한 축약표현 사용가능, </p>
<pre><code>                 ex)ES5에서: sayHi: function()&#123;&#125;/  ES6에서:sayHi()&#123;&#125;
           메서드 축약표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작!</code></pre>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/27/%EC%9B%90%EC%8B%9C%EA%B0%92primitive-%EA%B3%BC-%EA%B0%9D%EC%B2%B4object-reference-%EC%9D%98-%EB%B9%84%EA%B5%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/%EC%9B%90%EC%8B%9C%EA%B0%92primitive-%EA%B3%BC-%EA%B0%9D%EC%B2%B4object-reference-%EC%9D%98-%EB%B9%84%EA%B5%90/" class="post-title-link" itemprop="url">원시값primitive 과 객체object/reference 의 비교</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:42:38 / Modified: 17:43:04" itemprop="dateCreated datePublished" datetime="2020-08-27T17:42:38+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ㅠ(“6.데이터타입”) 참고<br>자바스가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체타입)은 크게 원시타입(primitive type)과 객체(object/ reference type)타입으로 구분.<br>구분하는 이유는? : 근본적으로 다른다는 의미. 세가지 측면에서 다름</p>
<ul>
<li>원시타입의 값(= 원시값)은 변경 불가능한 값(immutable value)임.,<br>객체(참조)타입의 값(=객체)는 변경 가능한 값(mutable value)임.</li>
<li>원시값을 변수에 할당하면 변수(확보된 메모리공간)에는 실제 값이 저장됨. ,<br>객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조값이 저장됨.</li>
<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달됨. 이를 값에 의한 전달(pass by value)라 함.<br> 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨. 이를 참조에 의한 전달(pass by reference)라 함.</li>
</ul>
<ol>
<li>원시값<br>1-1.변경 불가능한 값<br>primitive type=immutable type </li>
</ol>
<ul>
<li><p>한 번 생성된 원시값은 읽기전용(read only)값이라 변경할 수 없음.</p>
</li>
<li><p>값을 변경할 수 없다 : 변수와 값을 구분해서 생각하자. </p>
<pre><code>                                   - 변수: 하나의 값을 저장하기 위해 확보한 메모리공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름,
                                   - 값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과.
                                     따라서  변경 불가능하다는 것은 변수가 아니라 값에 대한 진술임.  = 즉, &quot;원시값은 변경 불가능하다&quot;는 말은 원시값 자체를 변경할 수 없다는 것이지 변수값을 변경할 수 없다는것이 아님!! 변수는 언제든지 재할당을 통해 변수값을 변경(엄밀히 말하자면 교체)할 수 있기때문에 변수라고 부름.</code></pre>
</li>
<li><p>변수의 상대개념인  상수는 재할당이 금지된 변수를 말함. 상수도 값을 저장하기 위한 메모리공간이 필요하므로 변수라고 할 수 있음. 단, 변수는 언제든지 재할당을 통해 변수값을 변경(교체)할 수 있지만 상수는 단 한번만 할당이 허용되므로 변수값을 변경(교체)할 수 없음. =&gt; 상수와 변경불가능한값을 동일시하면 안됨. 상수는 재할당이 금지된 변수일 뿐임!!</p>
</li>
<li><p>원시값은 변경불가능한 값= 읽기 전용 값. = 불변 = 데이터의 신뢰성 보장.</p>
</li>
<li><p>재할당하면 메모리공간 덮어쓰기가 아닌 새로운 메모리공간을 확보하고 저장. 주소가 바뀌는 것. 이러한 특성을 불변성immutability라 함.<br>1-2.문자열과 불변성</p>
</li>
<li><p>데이터 타입에 의한 메모리 공간의 확보가 필요. 단 ECMAScript사양에 문자열타입(2byte)과 숫자타입(8byte)이외의 원시타입은 크기를 명확히규정하고있지않음=브라우저 제조사의 구현에따라 다름.</p>
</li>
<li><p>원시값인 문자열만의 독특한 특징: 문자열은 0개 이상의 문자(character)로 이뤄진 집합을 말하며, 1개의 문자는 2바이트의 메모리공간에 저장됨.=문자열은 몇개의 문자로 이뤄졌느냐에 따라 필요한 메모리공간의 크기가 결정됨. 숫자값은 1도, 1,000,000도 동일한 8byte가 필요하지만 문자열의 경우(단순계산때) 1개의 문자열은 2byte, 10개로 이뤄진 문자열은 20byte필요.</p>
</li>
<li><p>이런 이유들로 C에서는 하나의 문자를 위한 데이터타입(char)만 있을 뿐 문자열 타입은 존재하지 않음. C에서는 문자열을 문자들의 배열로 처리하고 자바에서는 문자열을 String객체로 처리함.</p>
</li>
<li><p>하지만!  -&gt;자바스의 장점: 개발자의 편의를 위해 원시타입인 문자열타입을 제공!! 자바스의 문자열은 원시타입,변경불가능.=문자열이 생성된 이후에는 변경할수없음을 의미</p>
<pre><code> ex) var str = &#39;hello&#39;;
        str = &#39;world&#39;;</code></pre>
<p>  일때, 첫번째문을 실행해서 hello가 저장된 메모리 공간의 첫번째 메모리셀 주소를 가리킨다. 두번째문 실행하면 world메모리생성하고 식별자str은 이것을 가리킴. hello를 수정해서 world를 덮어씌우는게 아니다. hello와world는 모두 메모리에 존재함. 식별자 str이 문자열 hello를 가리키고 있다가 문자열world를 가리키도록 변경되었을 뿐!!!!!!</p>
</li>
<li><p>문자열은 유사배열객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있음.<br>  ** 유사배열객체array-like object란, </p>
<pre><code>   : 마치 배열처럼 인덱스로 프로퍼티 값에 접근할수있고 length프로퍼티를 갖는 객체를 말함. 
      문자열은 마치 배열처럼 인데스를 통해 각 문자에 접근할 수 있고, length프로퍼티를 갖기 때문에 유사배열객체이고 for문으로 순회할수도있음.</code></pre>
<p>1-3.값에 의한 전달</p>
</li>
<li><p>ex) var score = 80;</p>
<pre><code>  var copy = score;

  console.log(score); // 80
  console.log(copy); // 80</code></pre>
<p>일때, 변수에 변수를 할당했을때 어떻게 전달되는가가 핵심이다.<br>copy=score에서 변수값80으로 평가되므로 copy변수에도 80이 할당(새로운 숫자값 80이 생성되어 copy변수에 할당됨)</p>
</li>
<li><blockquote>
<p>변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달됨 = 값에 의한 전달(Pass by value)라 함.<br>score변수와 copy변수의 값 80은 다른 메모리공간에 저장된 별개의 값임!!</p>
</blockquote>
<p>ex) 위 ex에 연결.</p>
<pre><code>   score = 100;

   console.log(score); // 100
   console.log(copy); // ??? (정답: 80)</code></pre>
<p>에서 score변수와 copy변수의 값 80은 다른 메모리공간에 저장된 별개의 값이라 했음. 따라서 score변수의 값을 100으로 재할당 해도 copy변수의 값에는 어떠한 영향도 주지 않음!!</p>
</li>
<li><p>ECMAScript사양에는 “값에 의한 전달”이라는 용어등장하지 않음.<br>“값에 의한 전달”과 “참조에 의한 전달” “공유에의한전달”이라고 표현.</p>
</li>
<li><p>정확히는 “값에 의한 전달”은 값을 전달하는 것이 아닌 메모리 주소를 전달하는것임. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음.</p>
</li>
<li><p>두변수의 원시값은 서로 다른 메모리공간에 저장된 별개의 값이되어 어느한쪽에서 재할당을 통해 값을 변경해도 서로 간섭할수 없음!!!</p>
</li>
</ul>
<ol start="2">
<li>객체</li>
</ol>
<ul>
<li>프로퍼티 개수가 정해져 있지 않으며, 동적으로 추가됙고 삭제할 수 있음. 또한 프로퍼티의 값에도 제약이 없음. = 객체는 원시값과 같이 확보해야할 메모리공간의 크기를 사전에 정해둘 수 없음.</li>
<li>객체는 복합적인 자료구조이므로 객체 관리 방식이 원시값과 비교해서 복잡함. 원시값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에따라 크기가 매우클수도 있음. 객체 생성하고 프로퍼티에 접근하는것도 원시값과 비교할때 비용이 많이 드는 일임. = 객체는 원시값과는 다른 방식으로 동작하게 설계되어있음.<br>2-1.변경가능한 값</li>
<li>객체(참조)타입의 값= 객체는 변경 가능한 값(mutable value)임.</li>
<li>원시값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리공간에 접근하면 원시값에 접근할수있음. = 원시값을 할당한 변수는 원시값자체를 값으로 갖음. !하지만! 객체를 할당한 변수가 기억하는 메모리주소를 통해 메모리공간에 접근하면 참조값(reference value)에 접근할 수 있음. 참조값은 생성된 객체가 저장된 메모리공간의주소, 그 자체임.</li>
<li>ex) var person = { name: ‘Lee’};<pre><code>  console.log(person); //&#123;name: &quot;Lee&quot;&#125; // person변수는 객체 &#123;name: &#39;Lee&#39;;&#125;를 가리키고point(참조하고)있음.
   (이어서)
   person.name = &#39;Kim&#39;; //  프로퍼티 값 갱신
   person.address = &#39;Seoul&#39;; // 프로퍼티 동적 생성
   console.log(person); //&#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125; // person변수는 객체 &#123;name: &#39;Lee;&#125;를 가리키고point(참조하고)있음. ,, // 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조값은 변경되지 않음.</code></pre>
</li>
<li>원시값은 변경 불가능한 값이므로 원시값을 갖는 변수의 값을 변경하려면 재할당을 통해 메모리에 원시값을 새롭게 생성해야함. 하지만 객체는 변경가능한 값으므로 메모리에 저장된 객체를 직접 수정할 수 있음. = 재할당없이 프로퍼티를 동적으로 추가할수도 있고 프로퍼티값을 갱신할수도 있으며 프로퍼티자체를 삭제할수도 있음. </li>
<li>메모리를 효율적으로 사용하기위해, 객체를 복사해 생성하는 비용을 절약해서 성능을 향상시키기위해 객체는 변경 가능한 값으로 설계되어있음. 메모리 사용의 효율성과 성능을 위해 어느정도의 구조적인 단점을 감안한 설계</li>
<li>구조적단점에 따른 부작용: 원시값과는 다르게 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것.<br> **얕은 복사(shallow copy)와 깊은 복사(deep copy)<pre><code>  :얕은복사 - 객체를 프로퍼티 값으로 갖는객체의 경우 한단계까지만 복사.
    깊은 복사 - 객체에 중첩되어있는 객체까지 모두 복사.</code></pre>
2-2.참조에 의한 전달<br>여러개의 식별자가 하나의 객체를 공유할 수 있다는것을 공부하자.</li>
<li>ex) var person = { name: ‘Lee’};<pre><code>   var copy = person // 참조값을 복사 (얕은복사)</code></pre>
객체를 가리키는 변수(원본,person)를 다른변수(사본,copy)에 할당하면 원본의 참조값이 복사되어 전달됨= 참조에의한전달pass by reference<br>원본person과 사본copy는 저장된 메모리 주소는 다르지만 동일한 참조값을 갖음= 모두 동일한 객체를 가리킴.=두개의 식별자가 하나의 객체를 공유함을 의미.= 원본이나 사본중 어느한쪽에서 객체를 변경(재할당이아닌 객체의 프로퍼티값을 변경하거나 프로퍼티추가,삭제)하면 서로 영향을 주고 받음.</li>
<li>ex) var person = { name=’Lee’};<pre><code>   var copy = person; // =&gt;참조값을 얕은 복사함. copy와person은 동일한 참조값 갖음.
   console.log(copy===person); //true =&gt;copy와 person은 동일한 객체를 참조함.
   copy.name = &#39;Kim&#39;; // =&gt;copy를 통해 객체를 변경
   person.address = &#39;Seoul&#39;; // =&gt;person을 통해 동적생성
   console.log(person); // &#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125;
   console.log(copy); // &#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125;
                                        =&gt;copy와person은 동일한객체가리킴.
                                            서로 영향 주고 받음.</code></pre>
</li>
<li>결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어있는 값을 복사해서 전달한다는 면에서 동일.<br>다만 식별자가 기억하는 공간=변수에 저장되어있는 값이 원시값이냐 참조값이냐 하는 차이만 있음.</li>
<li>자바스에는 “참조에 의한 전달”은 존재하지않고 “값에 의한 전달”만이 존재한다고 말할수있음.</li>
<li>따라서 교안에서는 전달되는 값의 종류가 원시값인지 참조값인지 구별해서 강조하는 의미에서 “값에의한전달”과 “참조에의한전달”로 구분해서 부르기로함.</li>
</ul>
<p><strong><em>퀴즈!!</em></strong><br>var person1 = {name=’Lee’};<br>var person2 = {name=’Lee’};<br>console.log(person1 === person2} //  false =&gt;객체의 변수이름이 다름(?)<br>console.log(person1.name === person2.name} //  true =&gt; 객체의 참조값이 같음.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/25/%EC%97%B0%EC%82%B0%EC%9E%90operator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%EC%97%B0%EC%82%B0%EC%9E%90operator/" class="post-title-link" itemprop="url">연산자operator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 22:20:35 / Modified: 22:20:48" itemprop="dateCreated datePublished" datetime="2020-08-25T22:20:35+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation)등을 수행해 하나의 값을 만듦. 이때 연산의 대상의 피연산자(operand)라 함. 피연산자는 값으로 평가될 수 있는 표현식이어야 함.</p>
<ul>
<li>피연산자가 “값”이라는 명사의 역할을 한다면,<br>연산자는 “피연산자를 연산하여 새로운 값을 만든다”라는 동사의 역할을 한다고 볼 수 있음.<br>= 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 함. 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만듦.</li>
</ul>
<ol>
<li>산술연산자<br>arithmetic operator<br>피연산자를 대상으로 수학적 계산을 수행해 새로운 값을 만듦. 산술 연산이 불가능할 경우 NaN을 반환함. 산술연산자는 피연산자의 개수에 따라 이항산술연산자와 단항산술연산자로 구분할 수 있음.<br>1-1. 이항(binary) 산술 연산자<br>binary산술 연산자는 2개의 피연산자를 산술연산해서 숫자값을 만듦.<br>모든 이행 산술연산자는 피연산자의 값을 변경하는 부수효과(side effect)가 없음. = 어떤 산술을 해도 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운값을 만들뿐!<br>종류: +덧셈 -뺼셈 *곱셈 /나누기 %나머지<br>1-2. 단항(unary) 산술 연산자<br>unary산술 연산자는 1개의 피연산자를 산술연산하여 숫자값을 만듦.<br>종류: ++증가(부수효과있음)<pre><code>    --감소(부수효과있음) 
   +어떠한효과없고 음수양수반전도 안하고 부수효과도 없음.
    -양수를음수로음수를양수로반전한값을 반환하고 부수효과는 없음.</code></pre>
증가++ 감소– 연산자는 피연산자의 값을 변경하는 부수효과가 있다는 것이 중요!!= 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적할당이 이루어짐.</li>
</ol>
<p>** 증가/감소(++/–)연산자는 위치에 의미가 있음!! 중요!!!</p>
<ul>
<li>피연산자 앞에 위치한 = 전위 증가/감소 연산자(prefix increment/ decrement operator)는 피연산자의 값은 먼저 증가/감소 시킨 후, 다른 연산을 수행.</li>
<li>피연산자 뒤에 위치한 = 후위 증가/감소 연산자(postfix increment/ decrement operator)는 다른 연산을 먼저 수행한 후 피연산자의 값을 증가/감소시킴.</li>
<li><ul>
<li>단항연산자는 피연산자에 어떠한 효과도 없음. 음수를 양수로 반전하지도 않음. 숫자타입이 아닌 피연산자에 +사용하면 숫자타입으로 변환한 값을 생성해서 반환함. 부수효과없음.</li>
</ul>
</li>
<li>-단항연산잔느 피연산자의 부호를 반전한 값을 반환함. +단항연산자와 마찬가지로 숫자타입이 아닌 피연산자에 사용하면 숫자타입으로 변환한 값을 생성하여 반환함. 피연산자를 변경한느것이 아닌 부호를 반전한 값을 생성해서 반환함. 부수효과 없음.<br>1-3. 문자열 연결 연산자<ul>
<li>연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작. 그 외의 경우는 산술연산자로 동작.</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>할당 연산자<br>assignment operator는 우항에 있는 피연산자의 평가결과를 좌항에 있는 변수에 할당. 할당연산자는 좌항의 변수에 값을 할당하므로 변수값이 변하는 부수효과가 있음.<br>종류: = -&gt; x = 5 , x = 5</p>
<pre><code> += -&gt; x += 5, x=x+5
  -= -&gt; x -= 5, x=x-5
  *= -&gt; x *= 5, x=x*5
  /= -&gt; x /= 5, x=x/5
  %= -&gt; x %= 5, x=x%5</code></pre>
<p>할당문은 표현식인 문일까 표현식이 아닌 문일까? = 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가됨. 할당문을 다른 변수에 할당하는 특징을 활용해 여러변수에 동일한 값을 연쇄할당할 수 있음<br>ex) var a, b, c;<br>   a = b = c = 0; //연쇄할당. 오른쪽에서 왼쪽으로 진행. c=0, b=0, a=0.<br>  console.log(a, b, c); // 0, 0, 0</p>
</li>
<li><p>비교 연산자<br>comparison operator는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환함. 비교 연산자는 if문이나 for문과 같은 제어문의 조건식에서 주로 사용함.<br>3-1. 동등/ 일치 비교 연산자<br>동등비교(loose equality)연산자와 일치비교(strict equality)연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는 지 비교해 불리언값을 반환함. 하지만 비교하는 엄격성의 정도가 다름! 동등비교는 느슨한비교, 일치비교는 엄격한비교. 부수효과 전부 없음.<br>종류 : == 동등비교, x == y, x와 y의 값이 같음.</p>
<pre><code>    === 일치비교, x === y, x와 y의 타입이 같음.
    != 부동등 비교, x != y, x와 y의 값이 다름.
    !== 불일치비교, x !== y, x와 y의 타입이 다름.</code></pre>
<p>동등비교(==)는 좌항과 우항의 피연산자를 비교할때 암묵적인 타입변환을 통해 타입일치시킨 후 같은 값인지 비교함.<br>ex) 0 == ‘ ‘; // true<br>   0 == ‘0’; // true<br>   ‘0’ == ‘ ‘; // false<br>동등비교연산자는 결과를 예측하기 어려우므로 일치비교(===)연산자를 사용한다.<br>ex) 5 === 5; // true<br>   5 === ‘5’; // false<br>일치비교(===)연산자에서 주의할 것은 NaN 이다!!!<br>NaN은 자신과 일치하지 않는 유일한 값임.<br>ex) NaN===NaN; // false<br>따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용.<br>ex) isNaN(NaN); // true</p>
<pre><code>isNaN(10); // false</code></pre>
<p>숫자 0도 주의!!!! 자바스에는 양의0과 음의0이 있는데 이들을 비교하면 true를 반환함.<br>ex) 0 === -0; // true</p>
<pre><code>0 == -0; // true</code></pre>
<dl><dt>(** Object.is 메서드</dt><dd>ES6에서 도입된 Object.is메서드는 예측 가능한 정확한 비교결과를 반환함. 그 외에는 일치비교(===)연산자와 동일하게 작동.<br>ex)  -0 === +0; // true</dd></dl><pre><code> Object.is(-0, +0); // false
 NaN === NaN; // false
 Object.is(NaN, NaN); // true</code></pre>
<p>)<br>부동등 비교연산자(!=)와 불일치 비교 연산자(!==)는 각각 동등비교(==)연산자와 일치비교(===)연산자의 반대개념임.<br>3-2. 대소 관계 비교 연산자<br>피연산자의 크기를 비교하여 불리언 값을 반환함. 부수효과 없음.<br>종류 : &gt; , x &gt; y, x가 y보다 크다.</p>
<pre><code>    &lt; , x &lt; y, x가 y보다 작다.
    &gt;= , x &gt;= y, x가 y보다 크거나 같다.
    &lt;= , x &lt;= y, x가 y보다 작거나 같다.</code></pre>
</li>
<li><p>삼항 조건 연산자<br>ternary operator는 조건식의 평가 결과에 따라 반환할 값을 결정함. 자바스의 유일한 삼항 연산자이며 부수효과 없음.<br>사용 예 : 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값<br>삼항조건연산자는 두번째 피연산자 또는 세번째 피연산자로 평가되는 표현식임.<br>물음표? 앞의 첫번째 피연산자는 조건식=불리언 타입의 값으로 평가될 표현식임. 조건식의 평가 결과가 불리언값이 아니어도 불리언값으로 암묵적타입변환됨. 이때 조건식이 참true이면 콜론:  앞의 두번째 피연산자가 평가되어 반환, 거짓false라면 콜론: 뒤의 세번째 피연산자가 평가되어 반환.<br>if~ else문을 사용해도 삼항조건 연산자 표현식과 유사하게 처리할 수 있음.<br>하지만 삼항조건연산자표현식은 값처럼 사용가능(=표현식인 문)하지만 if~else문은 값처럼 사용할 수 없음(=표현식이 아닌 문).</p>
</li>
<li><p>논리 연산자<br>logical operator는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다. 부수효과 없음.<br>종류 : || 논리합(OR)</p>
<pre><code>    &amp;&amp; 논리곱(AND)
    ! 부정(NOT) // 언제나 불리언 값을 반환함.</code></pre>
</li>
</ol>
<dl><dt>** 드 모르간의 법칙</dt><dd>논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 때가 있음. 이러한 경우 드 모르간 법칙을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환할 수 있음.<br>ex) !(x || y) === (!x &amp;&amp; !y)<br>      !(x &amp;&amp; y) === (!x || !y)</dd></dl><ol start="6">
<li><p>쉼표 연산자<br>, 쉼표 연산자는 왼쪽 피 연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가결과를 반환함.<br>ex)  var x, y, z;</p>
<pre><code>x = 1, y = 2, z = 3; // 3</code></pre>
</li>
<li><p>그룹 연산자<br>소괄호( ) 로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가함. 연산자의 우선순위 조절 가능. 연산자 우선순위가 가장 높음.<br>ex) 10 * 2 + 3; // 23<br>   10 * (2 + 3); // 50</p>
</li>
<li><p>typeof 연산자<br>데이터 타입을 문자열로 반환함. 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환함. “null”을 반환하는 경우 없음. 함수의 경우 “function”을 반환. = typeof연산자가 반환하는 문자열은 7개의 데이터 타입과 정확하게 일치하지 않음!!<br>typeof연산자로 null값을 연산해보면 “null”이 아닌”object”를 반환한다는 데 주의!!! 자바스의 첫번째 버전의 버그임. 기존코드에 영향을 줄 수 있기때문에 아직까지 수정되지못함.<br>= 따라서 값이 null 타입인지 확인할때는 typeof연산자말고 일치연산자(===)사용하자.<br>그리고 선언하지 않은 식별자를 typeof연산자로 연산해보면 ReferenceError가 발생하지않고 undefined를 반환함.</p>
</li>
<li><p>지수 연산자<br>ES7에서 도입된 지수연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자값을 반환함.<br>ex) 2 ** 2; //4<br>   2 ** 0; // 1<br>   2 ** -2; // 0.25<br>   2 ** 2.5; // 5.65685<br>지수연산자 도입전까진 Math.pow메서드를 사용했음. 지수연산자가 가독성이 더 좋음<br>음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 함.<br>ex) (-5) ** 2; // 25<br>다른 산술연산자와 마찬가지로 할당연산자와 함께 사용할 수 있음.<br>이항 연산자 중에서 우선순위가 가장 높음.</p>
</li>
<li><p>그 외의 연산자<br>종류 : ?.  옵셔널 체이닝 연산자</p>
<pre><code>   ??  null 병합 연산자
   delete 프로퍼티 삭제
   new 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
   instanceof 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
   in 프로퍼티 존재 확인</code></pre>
</li>
<li><p>연산자의 부수 효과<br>대부분의 연산자는 다른 코드에 영향을 주지 않음. 일부 연산자는 다른코드에 영향을 주는 부수효과(side effect)가 있음.<br>부수 효과가 있는 연산자는 할당(=), 증가(++), 감소(–), delete연산자 이다.</p>
</li>
<li><p>연산자 우선순위<br>우선순위가 높을수록 먼저 실행됨.</p>
</li>
<li><p>연산자 결합 순서<br>연산자의 어느쪽(좌항 또는 우항)부터 평가를 수행할 것인지를 나타내는 순서를 말함.<br>결합순서:<br>좌항-&gt;우항: + , - , / , % , &lt; , &lt;= , &gt; , &gt;= , &amp;&amp; , || , . , [] , () , ?? , ?. , in , instanceof<br>우항-&gt;좌항: ++ , – , 할당연산자, !x , +x , -x , ++x , –x , typeof , delete , ? … : …</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85-data-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85-data-type/" class="post-title-link" itemprop="url">데이터타입 data type</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 22:19:30 / Modified: 22:20:07" itemprop="dateCreated datePublished" datetime="2020-08-25T22:19:30+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>데이터타입(data type. 줄여서 ‘타입’이라고도 함)은 값의 종류를 말함. 자바스의 모든 값은 데이터 타입을 갖는다.<br>자바스는 원시타입6개, 객체타입1개. 총7개의 데이터타입을 제공함.</p>
<ul>
<li>원시타입(Primitive Type):<ul>
<li>숫자(number)타입: 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재</li>
<li>문자열(string)타입: 문자열</li>
<li>불리언(boolean)타입: 논리적 참(true)과 거짓(false)</li>
<li>undefined타입: var 키워드로 선언된 변수에 암묵적으로 할당되는 값</li>
<li>null타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값</li>
<li>심벌(symbol)타입: ES6에서 추가된 7번째 타입</li>
</ul>
</li>
<li>객체 타입(object/ reference type): 객체, 함수, 배열 등.<br>ex) 숫자타입 1 != 문자열타입 ‘1’. <pre><code>숫자타입의 값은 주로 산술연산을 위해 생성, 문자열타입의 값은 주로 텍스를 화면에 출력하기 위해 생성. 메모리공간 확보의 크기도 다름. 메모리에 저장되는 2진수도 다름. 읽어들이는 해석방식도 다름.</code></pre>
</li>
</ul>
<ol>
<li><p>숫자 타입<br>C언어나 자바의 경우, 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)를 구분해서 int, long, float, double등과 같은 다양한 숫자 타입 제공.<br>자바스의 경우, 독특하게 하나의 숫자타입만 존재.<br>ECMAScript 사양의 숫자타입의 값은 배정밀도 64비트 부동소수점형식을 따름. = 모든수를 실수로 처리, 정수만을 표현하기위한 데이터타입(integer type)별도 존재안함. = 정수로 표시된다해도 사실은 실수라는 것을 의미. = 정수끼리 나눠서 실수가 나올수 있는 이유임.<br>자바스는 2진수, 8진수 16진수를 표현하기위한 데이터타입을 제공하지 않기때문에 모두 10진수로 해석됨.<br>추가적으로 세가지 특별한 값들 표현 가능: </p>
<ul>
<li>Infinity : 양의 무한대</li>
<li>infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가(not-a-number)<br>자바스는 대소문자를 구별함= NaN을 nan Nan NAN등과 같이 표현하면 값이 아닌 식별자로 해석하기때문 에러발생. </li>
</ul>
</li>
<li><p>문자열 타입<br>String타입은 텍스트 데이터를 나타내는 데 사용. 문자열은 0개 이상의 16비트 유니코드 문자들의 집합으로 전 세계 대부분의 문자표현 가능.<br>문자열은 작은따옴표(‘’), 큰따옴표(“”), 백틱(``)으로 텍스트 감쌈. 자바스의 일반 표기법은 작은따옴표 사용.<br>따옴표로 감싸는 이유: 키워드나 식별자같은 토큰과 구분. 스페이스같은 공백 포함 가능.</p>
</li>
<li><p>템플릿 리터럴<br>멀티라인 문자열(multi-line string), 표현식 삽입(expression interpolation), 태그드 템플릿(tagged template) 등 편리한 문자열 처리 기능을 제공. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리됨.<br>백틱사용 표현이 일반적.<br>3-1. 멀티라인 문자열<br>일반문자열내에서는 줄바꿈 허용안됨. 백슬래시\로 시작하는 이스케이프 시퀀스 사용해야함.<br>3-2. 표현식 삽입<br>문자열은 문자열 연산자 +를 사용해 연결할 수 있음. + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작. 그 외의 경우는 덧셈 연산자로 동작.<br>표현식을 삽입하려면 ${ }으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입됨.<br>반드시! 템플릿 리터럴 내에서 사용해야 함. 템플릿 리터럴이 아닌 문자열에서의 표현식 삽입은 문자열로 취급됨.</p>
</li>
<li><p>불리언 타입<br>논리적 참, 거짓을 나타내는 true와 false뿐임.<br>조건문에서 자주 사용함.</p>
</li>
<li><p>undefined 타입<br>undefined 타입의 값은 undefined가 유일함.<br>var키워드로 선언한 변수는 암묵적으로 undefined로 초기화됨. = 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질때까지 빈상태(쓰레기값)로 내버려두지 않고 자바스엔진이 undefined로 초기화함. = 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환됨.<br>var foo;<br>console.log(foo); // undefined<br>개발자가 의도적으로 undefined를 변수에 할당하면 undefined의 본래 취지에 어긋나기때문에 권장안함. undefined을 할당하는 게 아닌 null 할당 사용.</p>
</li>
<li><p>null 타입<br>null 타입의 값은 null이 유일. 자바스는 대소문자 구별하므로 null은 Null,NULL등과 다름.<br>프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용. 변수에 null 할당=변수가 이전에 참조하던 값을 더이상 참조하지 않겠다, 명시적으로 제거하는 의미와 같음.= 자바스엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행함.</p>
</li>
<li><p>symbol 타입<br>ES6에서 추가된 7번째 타입. 변경불가능한 원시 타입의 값. 다른 값과 중복되지 않는 유일무이한 값. 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기위해 사용함.<br>symbol은 함수를 호출해 생성함. 이때 생성된 심벌값은 외부에 노출되지 않으며 다른 값과 절대 중복되지 않는 유일무이한 값임.</p>
</li>
<li><p>객체 타입<br>자바스의 데이터타입은 크게 원시타입과 객체타입으로 분류하는 이유는 근본적으로 다르기 때문이다. 자바스는 객체기반의 언어이며, 자바스를 이루고 있는 거의 모든 것이 객체이다.</p>
</li>
<li><p>데이터 타입의 필요성<br>9-1.데이터 타입에 의한 메모리 공간의 확보와 참조<br>ex) var score = 100;<br>ex의 코드가 실행되면 컴퓨터는 숫자값100을 저장위해 메모리공간확보한 후, 숫자값 100을 2진수로 저장. 이러한 처리를 하려면 숫자값을 저장할 때 확보되는 메모리공간의 크기를 알아야함.<br>값은 메모리에 저장하고 참조할 수 있어야함. 메모리에 값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 결정해야함. = 몇 바이트의 메모리 공간을 사용해야 낭비와 손실없이 값을 저장할 수 있는지 알아야 함.<br>자바스엔진은 데이터타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 변수에 할당되는 값의 데이터 타입에 따라 확보해야할 메모리공간의 크기가 결정됨.<br>값을 참조하는 경우! 식별자 score를 통해 숫자값100이 저장되어있는 메모리 공간의 선두 메모리셀의 주소를 찾아갈 수 있음. 이때 값을 참조하려면 한번에 읽어들여야할 메모리셀의개수-바이트수=메모리공간을 알아야함. 자바스엔진은 score변수에 숫자타입의 값이 할당되어 있어서 score변수를 숫자타입으로 인식. 숫자타입은 8바이트 단위로 저장되므로 score변수를 참조하면 8바이트 단위로 메모리 공간에 저장된 값을 읽어들임.<br>9-2.데이터 타입에 의한 값의 해석<br>메모리에서 읽어들인 2진수를 어떻게 해석하냐는 문제가 남아있음.!!<br>모든 값은 데이터 타입을 가지며 메모리에 2진수, 즉 비트 but의 나열로 저장됨. 메모리에 저장된 값은 데이터타입에 따라 다르게 해석될 수 있음.<br>ex) 01000001 -&gt;숫자로해석하면 65 / 문자열로 해석하면 A.<br>데이터타입은 값의 종류를 말함. 자바스의 모든 값은 데이터타입을 갖음. 데이터타입이 필요한 이유:</p>
<ul>
<li>값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어들여야 할 메모리공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li>
</ul>
</li>
<li><p>동적 타이핑<br>10-1. 동적 타입 언어와 정적  타입 언어<br>변수는 데이터타입을 가질까?<br>C나 자바같은 정적타입(static/strong type)언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류 = 데이터 타입을 사전에 선언해야 함. 이를 명시적타입선언(explicit type declaration)이라 함.</p>
<ul>
<li>정적 타입언어:  변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있음. , 컴파일 시점에 타입체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행함. 만약 타입체클르 통과하지 못했다면 에러를 발생시키고 프로그램의 실행자체를 막음. 이를 통해 타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임. , 대표적인 정적타입언어로 C, C++, 자바(Java), 코틀린(Kotlin), 고(Go), 하스켈(Haskell), 러스트(Rust), 스칼라(Scala)등이 있음.<br>자바스는 정적타입언어와 다르게 변수를 선언할 때 타입을 선언하지 않음.<br>다만, var, let, const키워드를 사용해서 변수를 선언할 뿐. 자바스의 변수는 정적타입언어처럼 미리 선언한 타입의 값만 할당할 수 있는것이 아님. 어떠한 데이터 타입의 값이라도 자유롭게 할당 가능.<br>typeof연산자로 변수를 연산하면 변수의 데이터 타입을 반환함= 변수의 데이터 타입을 반환하는것이 아니라 변수에 할당된 값의 데이터 타입을 반환한 것이 더 정확한 표현.<br>자바스의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입추론, type inference)됨. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음. 이러한 특징을 동적타이핑(dynamic typing)이라 하며, 자바스를 정적타입언어와 구별하기위해 동적타입(dynamic/weak type)언어라 함. 대표적인 동적타입언어로 자바스크립트, 파이썬(Python), PHP, 루비(Ruby), 리스프(Lisp), 펄(Perl)등이 있음.<br>처음질문의 답으로 기본적으로 변수는 타입을 갖지않음. 하지만 값은 타입을 갖음. 따라서 현재변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는것이 더 적절함. 변수는 값에 묶여 있는 값에 대한 별명이기 때문.<br>10-2.동적  타입 언어와 변수<br>변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있음. 이러한 동적타입언어의 특징은 데이터타입에 대해 무감각해질정도로 편리하다는 것. 하지만 위험도 있다.<br>모든 소프트웨어 아키텍처는 트레이드오프(trade-off: 두 개의 정책 목표가운데 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적관계를 의미)가 존재하며, 모든 애플리케이션에 적합한 은 탄환(Silver bullet:  고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책)은 없듯이 동적타입언어 또한 구조적인 단점이 있음.<br>변수값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수값을 추적하기 어려울 수 있음. 타입도 언제든지 변경될 수 있음. 따라서 동적타입언어의 변수는 값을 확인하기 전에는 타입을 확실할 수 없음!</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/24/%ED%91%9C%ED%98%84%EC%8B%9Dexpressin%EA%B3%BC-%EB%AC%B8statement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/%ED%91%9C%ED%98%84%EC%8B%9Dexpressin%EA%B3%BC-%EB%AC%B8statement/" class="post-title-link" itemprop="url">표현식expressin과 문statement</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 17:45:29 / Modified: 17:45:46" itemprop="dateCreated datePublished" datetime="2020-08-24T17:45:29+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>값</li>
</ol>
<p>-값(Value)은 식(표현식, Expression 수학의 식과 거의 유사. ex)10+20 )이 평가(Evaluate)되어 생성된 결과(30= 10+20의 결과30)를 말함.<br>-평가(Evaluate)란 식(표현식, Expression)을 해석해서 값을 생성하거나 참조하는 것을 의미. = 값을 도출하는 과정을 평가라고 한다.<br>ex) 10+20;//30 일때 10+20 은 평가되어 숫자 값 30을 생성함.<br>변수에 할당되는 것은 평가된 결과의 값이다.<br>ex) var sum = 10+20; 일때 변수sum에는10+20이 평가되어 생성된 숫자 30이 할당됨. 10+20은 할당 이전에 평가 되어 값을 생성해야 한다.<br>-모든 값은 데이터 타입을 갖으며 메모리에 2진수 = bit비트의 나열로 저장된다. 메모리에 저장된 값은 데이터타입에 따라 다르게 해석될 수 있다.<br>ex)0100 0001<br>    -&gt; 숫자로 해석 = 65<br>    -&gt; 문자열로 해석 = A<br>2. 리터럴<br>리터럴(Literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해서 값을 생성하는 표기 방식(Notation)을 말함.<br>3도 단순한 아라비아 숫자3이 아닌 숫자 리터럴 3이다. 자바스크립트엔진은 숫자리터럴 3을 평가해서 숫자 값 3을 생성한다.<br>이처럼 리터럴은 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등)나 또는 미리 약속된 기호(‘.’”,”.,[]{}//등)로 표기한 코드다.<br>자바스크립트 엔진은 코드가 실행되는 시점인 런타임(Runtime)에 리터럴을 평가해서 값을 생성한다.=리터럴을 작성하면 코드가 실행될 시점에서 상응하는 값을 생성한다.<br>즉, 리터럴은 값을 생성하기 위해 미리 약속된 표기법이라 할 수 있음.<br>리터럴을 사용하면 다양한 종류의 Data Type의 값을 생성할 수 있다. -&gt; 정수,부동소수점(실수), 2진수(0b로 시작),8진수(0o로 시작), 16진수(0x로 시작), 문자열, 불리언, null, undefined, 객체{}, 배열[], 함수Function() , 정규표현식 리터럴<br>3. 표현식—– 이해 더 필요!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 유툽강의 다시보기.<br>표현식(Expression)은 값으로 평가될 수 있는 문(Statement)이다. 즉 , 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. = 리터럴도 표현식이다. 리터럴은 그 자체로 표현식이다. 값으로 평가되는 문은 모두 표현식이다.<br>4. 문<br>문(Statement)과 표현식(Expression)용어 구분 필수! 확실히 이해!<br>문:  프로그램을 구성하는 기본 단위이자 최소 실행 단위임. 문의 집합이 프로그램. 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍!<br>-여러 토큰으로 구성된 것이 문이다. 토큰(Token)이란 문법적인 의미를 가지고, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미함.<br>ex) var sum = 1+2; 에서 각 키워드var, 식별자sum, 연산자=, 리터럴1, 연산자+, 리터럴2, 세미콜론; 이나 마침표. 가 토큰이다.<br>-문을 명령문이라고도 한다. 문=컴퓨터에 내리는 명령=문 실행= -&gt;명령실행-&gt;무슨일이 일어남.<br>-선언문, 표현식 문(할당문), 함수 선언문, 조건문, 반복문<br>5. 세미콜론(;)과 세미콜론 자동 삽입 기능<br>세미콜론(;): 문 의 종료를 나타냄.  = 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행함. 단 0개 이상의 문을 중괄호로 묵은 코드블록 ({ … })뒤에는 세미콜론을 붙이지 않는다. if문, for문, 함수등의 코드블록뒤에는 세미콜론을 붙이지 않는다. 코드블록은 언제나 문 의 종료를 의미하는 자체종결성(Self Closing)을 갖기 떄문이다.<br>문 의 끝에 붙이는 세미콜론은 옵션이라 생략이 가능하다. 자바스크립트 엔진은 자동으로 세미콜론 자동삽인기능(ASI)이 수행되기 때문이다. 하지만 ASI 동작과 개발자의 예측이 일치하지않는 경우가 간혹 있기때문에 세미콜론 사용을 기본으로 설정하는 습관을 들이자.<br>6. 표현식인 문과 표현식이 아닌 문<br>표현식은 문 의 일부일 수도 있고 그 자체로 문이 될수도 있다.!!!!!!!!!!!!!<br>구별하는 방법!: 변수에 할당해보자. 변수에 할당 할 수 있으면 표현식인 문이다.</p>
<ul>
<li>변수 선언문 =/= 표현식<br>ex) var x; //변수 선언문이다. =&gt; var foo = var x;// 는 SyntaxError,</li>
<li>할당문 === 표현식<br>ex) x=100; // 할당문이다. =&gt; var foo = x = 100; //을 console.log(foo);를 찍으면 100이 나온다.</li>
<li>완료 값(Completion Value): 크롬개발자도구에서 표현식이아닌 문 실행하면 언제나 undefined를 출력/ 표현식인 문을 실행하면 언제나 평가된 값을 반환.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/24/%EB%B3%80%EC%88%98variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/%EB%B3%80%EC%88%98variable/" class="post-title-link" itemprop="url">변수variable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-24 17:42:50" itemprop="dateCreated datePublished" datetime="2020-08-24T17:42:50+09:00">2020-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-04 20:25:21" itemprop="dateModified" datetime="2020-09-04T20:25:21+09:00">2020-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-변수란-무엇인가-왜-필요한가"><a href="#1-변수란-무엇인가-왜-필요한가" class="headerlink" title="1. 변수란 무엇인가? 왜 필요한가?"></a>1. 변수란 무엇인가? 왜 필요한가?</h1><p>변수란 데이터를 관리하기 위한 핵심 개념이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>자바스크립트를 해석하고 실행하는 자바스크립트 엔진이 위 코드를 계산(=평가evalution)하려면 10,20,+ 라는 기호의 의미를 알고 있어야 하며, 10+20이라는 식(=표현식expression)의 의미도 해석(=파싱parsing)할 수 있어야 한다.<br>10+20은 새로운 숫자값 30을 만들어 낸다.<br>컴퓨터는 CPU를 사용해서 연산하고, 메모리를 사용해서 데이터를 기억한다.<br>메모리(memory)는 데이터를 저장할 수 있는 메모리셀(memory cell)의 집합체이다. 메모리 셀 하나의 크기는 1바이트(byte)=8비트(bit)이며, 컴퓨터의 메모리 셀의 크기로(=1바이트 단위로) 데이터를 저장(write)하거나 읽어(read)들인다.<br><img src="https://user-images.githubusercontent.com/67843356/92218879-bc6da080-eed4-11ea-84ba-a8f82db0f4c7.jpg" alt="variable_memory_1" title="JS_memory"><br>각 셀은 고유의 메모리 주소(memory address)를 갖는다. 이 메모리 주소는 메모리공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현된다.<br>컴퓨터는 모든 데이터를 2진수로 처리하기때문에 메모리에 저장되는 데이터는 데이터의종류(숫자,텍스트,이미지,동영상)와 상관없이 모두 2진수로 저장된다.<br>위 예제에서 숫자값 10과20은 메모리상 임의의 위치(메모리주소)에 기억(=저장)되고 CPU는 이 값을 읽어들여 연산을 수행한다 -&gt; 연산된 결과로 생성된 숫자 값 30도 메모리상 임의의 위치에 저장된다.<br><img src="https://user-images.githubusercontent.com/67843356/92218884-bd9ecd80-eed4-11ea-9e40-2afb7d8c939c.jpg" alt="variable_memory_2"><br>편의상 10진수로 표기한 이미지이다. 하지만 우리는 메모리에 저장되는 모든 값이 2진수로 저장된다는것을 기억해야한다.<br>여기서 문제가 발생한다. CPU가 연산해서 만들어낸 숫자 값30을 <strong>재사용할수 없다</strong>는 것이다.<br>연산결과를 단 한번만 사용한다면 문제가 없겠지만 만약 연산 결과 30을 재사용하고싶다면 메모리주소를 통해 연산결과 30이 저장된 메모리 공간에 직접 접근하는것 이외에는 방법이 없다.<br>하지만 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다. 다시말해 메모리 주소를 통해 값에 직접 접근하려는 시도는 올바른 방법이 아니다.<br>프로그래밍 언언느 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어들여 <strong>재사용하기 위해 변수</strong>라는 메커니즘을 제공한다.<br><strong>변수는 <u>하나의 값을 저장</u>하기 위해 확보된 메모리 공간 자체(=<u>변수는 메모리 공간이다.</u>) 또는 그 <u>메모리공간을 식별하기 위해 붙인 이름</u>을 말한다.</strong>(상수도 변수이지만 일반적인 변수와 다른 성격을 갖고있다. 상수는 재할당이 안된다.)<br><strong><em>변수에 여러개의 값을 저장하는 방법</em></strong> : 변수는 하나의 값을 저장하기 위한 매커니즘이다. 여러개의 값을 지정하려면 여러개의 변수를 사용해야하지만 배열이나 객체같은 자료구조를 사용하면 관련이 있는 여러개의 값을 그룹화해서 하나의 값처럼 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffeeA = <span class="string">&#x27;latte&#x27;</span>; <span class="comment">// 하나의 값을 저장.</span></span><br><span class="line"><span class="keyword">var</span> coffeeShot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffee = &#123;<span class="string">&#x27;americano&#x27;</span>, <span class="string">&#x27;latte&#x27;</span>, <span class="string">&#x27;mocha&#x27;</span>, <span class="string">&#x27;hazelnut&#x27;</span>&#125;; <span class="comment">// 하나의 변수에 객체나 배열과 같은 자료구조 사용하여 여러개의 값 저장.</span></span><br><span class="line"><span class="keyword">var</span> coffeeAShot[</span><br><span class="line">    &#123;<span class="attr">coffeeA</span>: <span class="string">&#x27;latte&#x27;</span>, <span class="attr">coffeeShot</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">cooffeB</span>: <span class="string">&#x27;americano&#x27;</span>, <span class="attr">coffeeShot</span>: <span class="number">2</span>&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>변수를 사용해서 위의 코드를 다시 작성하면</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">10</span> + <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>으로, 변수 result에 10+20의 결과 값인 30을 메모리 공간에 저장된다. 이때 메모리공간에 저장된 값 30을 다시 읽어들여 <strong>재사용할 수 있도록</strong> 저장된 메모리공간에 상징적인 이름을 붙인것이 바로 변수이다.<br>변수에 값을 저장하는것을 할당(assignment, 대입, 저장)이라 하고,<br>변수에 저장된 값을 읽어 들이는 것을 참조(reference)라 한다.</p>
<p>사람이 이해할 수 있는 언어로 값이 저장된 메모리 공간에 붙인 상징적인 이름인 변수 이름을 통해 변수에 저장된 값의 의미를 명확히 이해할 수 있어 가독성을 높이는 부수적인 효과도 있다. 코드는 컴퓨터에게 내리는 명령이면서 개발자를 위한 문서이기때문에 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며, 이는 협업과 품질향상에도 도움을 준다. 변수의 이름을 심사숙고해서 지어야한다.</p>
<h1 id="2-식별자-‘8-식별자-네이밍-규칙’과-같이-보자"><a href="#2-식별자-‘8-식별자-네이밍-규칙’과-같이-보자" class="headerlink" title="2. 식별자 + ‘8.식별자 네이밍 규칙’과 같이 보자."></a>2. 식별자 + ‘8.식별자 네이밍 규칙’과 같이 보자.</h1><p>변수 이름(=식별자ID,identifer)은 <strong>어떤값을 구별해서 식별할 수 있는 고유한 이름</strong>으로 사람이름을 짓는거와 같다.<br>값은 메모리 공간에 저장되어 있기때문에 저장되어있는 어떤 값을 구별해서  식별해내야한다. 따라서 식별자는 이를위해 어떤값이 저장되어있는 메모리 주소를 기억(저장)해야한다.<br><strong>식별자는 값이 아니라 <u>메모리 주소를 기억</u>하고 있다는 것</strong>이 핵심이다.(=식별자는 메모리 주소에 붙인 이름이다.)<br><strong><em>!변수이름은 고유해야한다고 했다. 그렇다면 한 번 사용한 변수이름은 두 번 다시 못쓸까?!</em></strong> 결론부터 말하자면 <strong><u></u>아니다.</u></strong> 다시 쓸 수 있다. 쉽게말하면 파일이름지을때 <code>test.js</code>만들었다고 가정했을때 <code>test.js</code>를 같은 폴더에서는 못쓰고 다른 폴더에서 동일한 이름으로 사용할수있다. 이는 스코프에서 더 배우자!</p>
<h1 id="3-변수-선언"><a href="#3-변수-선언" class="headerlink" title="3. 변수 선언"></a>3. 변수 선언</h1><p>변수를 생성하는 것을 변수 선언(variable declaration)이라 한다. 즉, 값을 저장하기 위한 메모리 공간을 확보하고 변수이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언(변수 선언문)</span></span><br></pre></td></tr></table></figure>
<p>변수를 사용하려면 반드시 선언이 필요하다. <strong>변수 선언 키워드(keyword) -&gt; <code>var</code>, <code>let</code>, <code>const</code></strong><br>(!리바인딩과 변형mutation을 헷갈려서는 안된다. 리바인딩은 참조하는 식별자에 대한 변화이고 변형은 참조되는 값의 변화이다.</p>
<ul>
<li><code>var</code>키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 ‘선언단계’와 ‘초기화단계’가 한번에 진행된다. 재할당이 가능하다.<ul>
<li>선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.</li>
<li>초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화(initialization,변수가 선언된 이후 최초로 값을 할당함.)한다.</li>
<li><code>var score;</code>는 선언 단계를 통해 변수이름 <code>score</code>를 등록하고, 초기화 단계를 통해 <code>score</code>변수에 암묵적으로 <code>undefined</code>를 할당해 초기화한다.</li>
</ul>
</li>
<li><code>let</code>은 분리되어 진행된다. 즉, 런타임이전에 선언단계 실행되고 변수 선언문에 도달했을 때 초기화단계 실행한다. 재할당 가능하다.</li>
<li><code>const</code>는 반드시 선언과 동시에 초기화해야한다. 재할당이 금지된다.</li>
</ul>
<h1 id="4-변수-선언의-실행-시점과-변수-호이스팅"><a href="#4-변수-선언의-실행-시점과-변수-호이스팅" class="headerlink" title="4. 변수 선언의 실행 시점과 변수 호이스팅"></a>4. 변수 선언의 실행 시점과 변수 호이스팅</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//올바른 상태</span></span><br><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언문</span></span><br><span class="line"><span class="built_in">console</span>.log(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//호이스팅이 일어나는 상태</span></span><br><span class="line"><span class="built_in">console</span>.log(score); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언문</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//두개의 코드 모두 같은 결과를 도출함.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>변수 선언의 실행: <ul>
<li>변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점인 <strong>런타임(runtime)**이 아니라 **그 이전 단계에서 먼저 실행</strong>되기 때문에 선언문보다 변수를 참조하는 코드가 앞에 있다해서 <strong>참조에러ReferenceError를 발생시키지 않는다.</strong> 런타임단계를 실행하기 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드 실행을 위한 준비를 한다.</li>
</ul>
</li>
<li>변수 호이스팅: <ul>
<li>자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 즉, <strong>변수선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있다.</strong> (=변수선언(선언단계와 초기화단계)이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행된다는 증거===<strong><u>변수 선언문이 코드의 선두로 끌어 올려진것처럼 동작하는 자바스크립 고유의 특징을 변수 호이스팅(variable hoisting)</u></strong> 이라 한다.)</li>
<li>호이스팅 발생을 이용해서 무언갈 하려는 행위를 하면 안된다.</li>
<li>var는 호이스팅이 발생하지 않는것처럼 보이지만 let과 const로 바꾸면 에러가 발생한다.</li>
</ul>
</li>
</ul>
<p><em>!사실 호이스팅은 변수 선언 뿐만이 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.!</em></p>
<h1 id="5-값의-할당"><a href="#5-값의-할당" class="headerlink" title="5. 값의 할당"></a>5. 값의 할당</h1><p>할당(assignment,대입, 저장) 할 때는 할당 연산자’=’를 사용한다. 우변의 값을 좌변의 변수에 할당한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언(변수 선언문)</span></span><br><span class="line">score = <span class="number">80</span>; <span class="comment">// 값의 할당</span></span><br></pre></td></tr></table></figure>
<p>변수 선언과 값의 할당을 하나의 문(statement)으로 단축 표현할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>; <span class="comment">// 변수 선언(변수 선언문)과 값의 할당</span></span><br></pre></td></tr></table></figure>
<p>자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 표현해도 변수선언과 값의할당을 2개의 문으로 나누어 각각 실행한다.<br>주의할 점!!: 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다는 것이다.<br>변수에 값을 할당할때는 이전값(=초기된 값)이 저장되어있던 <strong>메모리를 덮어쓰는것이 아니다.</strong> <u>새로운 메모리공간을 <strong>확보</strong></u>하고 그 곳에 할당 된 값을 저장한다는 것이 중요하다.<br><img src="https://user-images.githubusercontent.com/67843356/92231416-ae754b00-eee7-11ea-8512-5f1999b4c24b.jpg" alt="variable_memory_3"><br><strong><em>!변수선언때 메모리공간에 할당한 값을 덮어쓰지 않는 이유는 자바스크립트 엔진이 원래있던 값을 지우는 동작을 부수적으로 실행해야하기 때문이다. 컴퓨터입장에서는 새로운 메모리공간을 확보하는것이 더 편하기 때문이다.!</em></strong><br>초기화된 값은 더이상 불러올 수 없다. 왜냐하면 초기화된 값의 변수이름이 할당된 변수의 이름으로 이동했기 때문에 초기화된 값의 변수이름이 없어서 부를 수가 없다. 사용할 수 없다는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DO-1</span></span><br><span class="line"><span class="keyword">var</span> score;   <span class="comment">//변수 선언 -①</span></span><br><span class="line">score = <span class="number">80</span>;  <span class="comment">//값의 할당 -②</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DO-2 </span></span><br><span class="line"><span class="comment">// score = 80; 값의 할당</span></span><br><span class="line"><span class="comment">// var score;  변수 선언</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(score); <span class="comment">// ?? -&gt; 80</span></span><br></pre></td></tr></table></figure>
<p>위의 코드 DO-1의 코드와 DO-1과 DO-2의 동작의 결과가 똑같이 일어나는 이유를 설명할 수 있어야 한다.</p>
<h1 id="6-값의-재할당"><a href="#6-값의-재할당" class="headerlink" title="6. 값의 재할당"></a>6. 값의 재할당</h1><p>이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.<br>var키워드로 선언한 <strong>변수는 값을 재할당하는게 가능</strong>하다. let도 가능하지만 const는 불가능하다.<br>만약 값을 재할당 할 수 없어 <u>한 번 정해지면 변하지 않는 값은 상수(constant)</u>라고 한다. const키워드도 상수를 표현할 수 있지만 반드시 상수만의 위해 사용하는것은 아니다.<br>초기값에 값을 할당하는것도 재할당이라고 할 수 있다.<br>재할당역시 새로운 메모리공간을 확보하고 재할당한 값을 저장한다.<br><em>!가비지 콜렉터(garbage collector) : 애플리케이션이 할당(allocate)한 메모리공간을 주기적으로 검사해서 더이상 사용되고 있지 않는 메모리, 즉 어떤 식별자도 참조하지 않는 <strong>메모리공간을 해제(release)</strong> 하는 기능을 말한다.</em><br><em>!언매니지드 언어(unmanaged language)와 매니지드 언어(managed language) : 프로그래밍 언어는 메모리 관리방식에 따라 분류할 수 있다.<br><u>C언어 같은 언매니지드 언어</u>는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 메모리 제어 기능을 제공하여 개발자가 주도할 수 있으므로 개발자의 역량에 따라  최적의 성능을 확보할수도 있지만 반대의 경우 치명적인 오류를 생산할 가능성도 있다.<br><u>자바스크립트같은 매니지드 언어</u>는 개발자가 명시적으로 메모리를 할당하고 해제할 수 없고, 메모리 해제는 가비지콜렉터가 수행하며 개발자가 관여할 수 없다. 개발자의 역량에 의존하는 부분이 상대적으로 작아져서 어느정도 일정한 생산성을 확보할 수 있지만 성능면에서 어느정도의 손실은 감수해야한다.!</em></p>
<h1 id="7-값의-교환"><a href="#7-값의-교환" class="headerlink" title="7. 값의 교환"></a>7. 값의 교환</h1><p>두 변수의 값을 교환하는 코드를 작성하라.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line"><span class="keyword">var</span> c = x;</span><br><span class="line"><span class="keyword">var</span> x = y;</span><br><span class="line"><span class="keyword">var</span> y = c;<span class="comment">// 2 1 교환재할당!.</span></span><br><span class="line"><span class="comment">//강사님의 또다른 풀이</span></span><br><span class="line">[x,y]=[y.x]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x,y); <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<h1 id="8-식별자-네이밍-규칙-‘2-식별자’와-같이-보자"><a href="#8-식별자-네이밍-규칙-‘2-식별자’와-같이-보자" class="headerlink" title="8. 식별자 네이밍 규칙 + ‘2.식별자’와 같이 보자."></a>8. 식별자 네이밍 규칙 + ‘2.식별자’와 같이 보자.</h1><p>외우자.<br>식별자는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름을 말하기때문에 식별자는 네이밍 규칙을 준수해야한다.<br>-식별자는 특수문자를 제외한 문자, 숫자, 언더스코어<em>, 달러기호$를 포함할 수 있다.<br>    - 단, 특수문자를 제외한 문자, 언더스코어</em>, 달러기호$로 시작해야함. 숫자로 시작하는건 허용하지 않는다.<br>-예약어(reserved word)는 식별자로 사용할 수 없다.(예약어는 프로그래밍 언어에서 사용되고 있거나 사용 예정인 단어를 말한다.)</p>
<ul>
<li>var first-name // SyntaxError가 나오는 이유는 -기호를 산술연산자로 인식하기 때문이다.</li>
<li>네이밍 컨벤션(naming convention)은 식별자를 만들 때 가독성이 좋게하여 단어를 한눈에 구분하기위해 규정한 명명규칙이다.<ul>
<li>네이밍 컨벤션 4가지 유형<ol>
<li>카멜 케이스 : firstName - 변수나 함수이름에 사용.</li>
<li>스네이크 케이스 : first_name</li>
<li>파스칼 케이스:FirstName - 생성자 함수, 클래스 이름에 사용.</li>
<li>헝가리언케이스: strFirstName//type+identifier , $elem=document.getElenentById(‘myId)//JQuery에서 DOM노드 요소를 나타냄, observable=fromEvent(document, ‘click’)//RxJS옵저버블</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>일반적으로 변수나 함수의 이름에는 카멜케이스를 사용하고,<br>생성자함수, 클래스의 이름에는 파스칼케이스를 사용하는 것이 좋다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/18/My-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/My-JavaScript/" class="post-title-link" itemprop="url">My JavaScript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-18 18:34:56" itemprop="dateCreated datePublished" datetime="2020-08-18T18:34:56+09:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-19 23:54:29" itemprop="dateModified" datetime="2020-08-19T23:54:29+09:00">2020-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hi there!!! It’s me again. LOL. welcome to my JIN BLOG :-)</p>
<p>매년 나오는 버전업그레이드. 특징들을 적극적으로 받아들여야한다. 높은 수준의 함수이지만 배워야한다.</p>
<p>웹페이지와 웹애플리케이션의 차이,구분은 애매하다. 만약 회사홈페이지를 만들었다면 그 상태도 웹페이지이고 로그인해야 게시판에 글을 쓰는것도 웹페이지라고 한다. 웹애플리케이션은 그 것을 가지고 일,업무를 하기위한 그런 느낌이다. 예를들면  vscode나 slack같은 프로그램들을 웹애플리케이션이라고 한다.</p>
<p>SPA에서 single page라는것은 html이 하나만있다는 뜻.</p>
<p>자바스크립트와 에크마스크립트<br>ECMAScript는 스펙상 용어이다. 노드랑 브라우저에서 동작 가능.<br>자바스크립트 alert(‘foo’);실행시키는 것을 nodejs에서 실행시키면 모른다고 나온다. 참조에러가 뜸. = 함수는 브라우저에서는 되고 노드에서는 안되는것이 있다. alert은 경고창이지만 브라우저에서 작동하는것이라 node는 브라우저가 없으니 실행이 안됨.<br>DOM!!!! 또한 브라우저가 있어야만 실행가능하기 때문에 node에서 동작안됨.</p>
<p>인터프리터! 중요. 컴파일러(like번역)와 인터프리터(like통역) 구분.<br>소스코드는 순수한 text파일을 말한다.<br>컴파일러의 단점은 컴파일을 해야한다는것이 단점이다.<br>컴파일중 수정사항이 생기면 다시 파일을 줘야한다.<br>프로그래머에게 편한건 인터프리터언어이지만,<br>실행속도가 빠른것은 컴파일러언어이다.<br>따라서 일부 컴파일을 쓴다. 인터프리터 언어다! 실행파일을 안만들기때문에 인터프리터 언어라고 말한다!</p>
<h2 id="변수에서의-값의-할당"><a href="#변수에서의-값의-할당" class="headerlink" title="변수에서의 값의 할당"></a>변수에서의 값의 할당</h2><p>변수는 초기값으로 쓰레기 값을 가지고 있다. 사용자(?)가 새로운 값을 할당해주면 쓰레기값의 메모리를 덮어씌우는 것이 아닌 새로운 메모리공간에 할당된 값을 저장한다는 개념이 중요하다.<br>키워드var, let, const중에서 var와 let은 값의 재할당이 가능하다.<br>따지면 쓰레기값에 값을 할당하는것도 재할당하는 것이다.<br>ex)<br>var mandoo; // mandoo라는 변수에는 값을 할당하지 않았지만 보이지않는 초기값인 쓰레기값을 갖고있다.<br>mandoo = 20; // mandoo라는 변수에 숫자20 값을 할당했다. = 쓰레기값에 숫자20을 재할당했다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/11/My-HTML5-CSS3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/My-HTML5-CSS3/" class="post-title-link" itemprop="url">My HTML5 & CSS3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-11 16:45:49" itemprop="dateCreated datePublished" datetime="2020-08-11T16:45:49+09:00">2020-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-19 23:55:42" itemprop="dateModified" datetime="2020-08-19T23:55:42+09:00">2020-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hi, This is my TIL(Today I Learn). Welcome.</p>
<h2 id="HTML의-ATTRIBUTE-와-CSS의-PROPERTY의-차이"><a href="#HTML의-ATTRIBUTE-와-CSS의-PROPERTY의-차이" class="headerlink" title="HTML의 ATTRIBUTE 와 CSS의 PROPERTY의 차이"></a>HTML의 ATTRIBUTE 와 CSS의 PROPERTY의 차이</h2><ul>
<li><strong>HTML의 ATTRIBUTE</strong>: 속성이라는 뜻. html문서에서 elements(요소들)에 추가적인 정보를 넣을 때 사용되는 요소. 정적(변하지 않음)이다.<br>예) <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my-study&quot;</span>&gt;</span>HI<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
위의 코드에서 <code>&quot;my-study&quot;</code>는 <code>&lt;div&gt;</code>의 element(요소)이고, <code>class</code>는 attribute(속성, <strong>추가정보</strong>)가 된다.<br><code>my-study&quot;</code>는 class attribute의 value(값)가 됨.</li>
<li><strong>CSS의 PROPERTY</strong>: 특성, 요소라는 뜻. html DOM안에서 attribute를 가리키는/대신하는 표현. 동적(값이 변할 수 있음)이다.<br>예) 위의 예에서 DOM 노드트리로 표현한 것에서  className <code>&quot;my-study&quot;</code>가 property가 됨.<br>CSS에서의 font-size와 color는 property이다. font-size와 color는 태어날 때부터 가지고 있는 속성이 있지만 바뀔 수 있다. 그래서 동적과 정적이라고 함.</li>
</ul>
<h2 id="HTML이란"><a href="#HTML이란" class="headerlink" title="HTML이란"></a>HTML이란</h2><ul>
<li><strong>H</strong>yper<strong>T</strong>ext<strong>M</strong>arkup<strong>L</strong>anguage =  문서와 문서가 태그로 이루어져있고 링크로 연결되어있는 언어. 마크업 언어이다.</li>
<li>웹의 아버지 : 팀 버너스리<br>웹을 이루는 가장 기초적인 구성 요소이다.<br>hypertext는 다른 text에 대한 link를 포함하는 text이다. = text와 text가 link로 연결되어 있다.</li>
</ul>
<p><strong>1. W</strong>eb Standards 웹표준기술<br><strong>2. W</strong>eb Accessibilty 윕 접근성 - 한가지 대안만 사용하지 않는다.</p>
<ul>
<li>예) 계단 옆의 경사로. </li>
<li>접근을 생각해보면 떠오르는 장애 접근성. </li>
<li>장애에 대한 이해: 시각장애(전맹, 저시력), 청각장애, 지체장애(절단 및 지체기능 장애), 뇌변병장애</li>
<li>장애 환경에 대한 이해: 다양한 Platform, Cross Browsing(크롬이나 익스플로러등 다양한 환경), SEO(Search Engine Optimization), 저사양 또는 저속 회선</li>
<li>장애는 틀린것이 아닌 다른것임. 다름을 인정해야 한다.</li>
</ul>
<p><strong>3.</strong> HTML의 탄생 ( 운영체제 - vender )</p>
<ul>
<li>IE - MS</li>
<li>Chrome - Google</li>
<li>Safari - Apple</li>
<li>Firefox - Gojira</li>
<li>Opera - Opera</li>
</ul>
<p><strong>4. WHATWG</strong></p>
<ul>
<li>웹 하이퍼텍스트 애플리케이션 테크놀로지 워킹 그룹(Web Hypertext Application Technology Working Group, WHATWG)은 HTML 및 관련 기술을 발전시키는 데 관심이 있는 사람들의 모임이다. 2004년 애플, 모질라 재단, 오페라 소프트웨어의 개인들이 설립하였다. 그 후, 당시 WHATWG 규격의 편집장이었던 이안 힉슨(Ian Hickson)이 오페라 소프트웨어에서 구글로 이직함에 따라 구글도 WHATWG의 일원이 됐다.<br>WHATWG는 멤버스(Members)로 불리는 초대 전용의 조그마한 감시 위원회를 가지고 있으며 이 위원회는 규격을 맡은 편집장을 탄핵할 권한을 가지고 있다. 누구든지 WHATWG 메일링 리스트에 참가하여 기여자로 참여할 수 있다.</li>
</ul>
<h2 id="CSS란"><a href="#CSS란" class="headerlink" title="CSS란"></a>CSS란</h2><ul>
<li><strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets = 사용자에게 문서를 표시하는 방법을 지정하는 언어.<br>웹 이전부터 워드프로세서 등에서 사용했던 개념.</li>
<li>프론트 엔드의 3대장(HTML5, CSS3, JavaScript)중 1대장은 JavaScript이다.</li>
<li>Web기술의 설정 값으로 HTML5는 건강한 신체이고  CSS3은 근사한 스타일링을 맡는다고 할 수 있다.<br>CSS는 스타일링할때에 설계가 필요하고 기획, 디자인 또한 필요하다.<br>JavaScript는 스마트한 두뇌의 역할이라 코어까지 들어가면 어렵게 느껴질 수 있다.</li>
<li>요소 배치 방법<br>: display, float, position, table, flex, grid</li>
</ul>
<p><strong>1.</strong> FLOAT 배치방법 </p>
<ul>
<li>classic버전.</li>
<li>도움이 되는 동영상 = <a target="_blank" rel="noopener" href="https://youtu.be/xara4Z1b18I" title="CSS float이해">Youtube</a>링크 클릭.</li>
<li>노멀플로우(Normal Flow)는 띄워지지 않은, 바닥에 위치해있는 기본위치를 의미한다.<br>float과 position(중 absolute)를 요소에 지정하면 공중에 띄워진다.</li>
<li>float의 기본 값은 none이고 left와 right를 지정할 수 있다.</li>
<li>float은 block레이아웃의 사용을 뜻하기 때문에 float을 하면 block요소로 바뀐다.</li>
<li>group에 float을 적용하게 되면 부모인 main이 자식요소인 group을 알 수 없게 되어 높이를 잃어버리고, 뒤쪽에 오는 다른 요소들에게도 float이 영향을 끼치게 되기 때문에 clearfix를 사용하여 float을 해제하고 부모가 자식의 높이를 인지할 수 있도록 해줘야 한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/11/My-Brand-New-POST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/My-Brand-New-POST/" class="post-title-link" itemprop="url">My Brand New POST</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-11 15:49:58" itemprop="dateCreated datePublished" datetime="2020-08-11T15:49:58+09:00">2020-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-12 12:44:36" itemprop="dateModified" datetime="2020-08-12T12:44:36+09:00">2020-08-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HELLO WORLD!</p>
<p>What a beautiful World!! lol</p>
<p>Hi, there!<br>Nice to meet you!</p>
<p>Do you know <strong>Eddie Redmayne</strong>?<br>He is my favorite actor in space.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JinSol</p>
  <div class="site-description" itemprop="description">All Dev stories found in here</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JinSol</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
