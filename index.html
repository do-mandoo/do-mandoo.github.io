<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"do-mandoo.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All Dev stories found in here">
<meta property="og:type" content="website">
<meta property="og:title" content="JINLOG">
<meta property="og:url" content="https://do-mandoo.github.io/index.html">
<meta property="og:site_name" content="JINLOG">
<meta property="og:description" content="All Dev stories found in here">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JinSol">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://do-mandoo.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>JINLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JINLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Awesome</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/09/16/let-const-and-block-level-scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/let-const-and-block-level-scope/" class="post-title-link" itemprop="url">let, const and block-level scope</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-16 22:20:13 / Modified: 22:20:53" itemprop="dateCreated datePublished" datetime="2020-09-16T22:20:13+09:00">2020-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>var 키워드로 선언한 변수의 문제점</li>
</ol>
<ul>
<li>ES5까지 변수를 선언할수 있는 유일한 방법은 var키워드를 사용하는것이었다. var키워드로 선언된 변수는 다음과같은 특징이 있다. 이는 다른 언어와는 구별되는 독특한 특징으로, 주의를 기울이지 않으면 심각한 문제를 발생시킬수 있다.<br>1-1. 변수 중복 선언 허용</li>
<li>var키워드로 선언한 변수는 중복선언이 가능하다.<br>var x = 1;<br>var y = 1;</li>
</ul>
<p>// var키워드로 선언된 변수는 같은 스코프내에서 중복선언을 허용한다.<br>// 초기화문이 있는 변수선언문은 자바스크립트엔진에 의해 var키워드가 없는것처럼 동작한다.<br>var x = 100;<br>// 초기화문이 없는 변수선언문은 무시된다.<br>var y;</p>
<p>console.log(x); // 100<br>console.log(y); // 1<br>위 코드를 보면 var 키워드로 선언한 변수를 중복선언하면 초기화문(변수선언과 동시에 초기값을 할당하는 문) 유무에 따라 다르게 동작한다. 초기화문이 있는 변수선언문은 자바스크립트엔진에 의해 var키워드가 없는것처럼 동작하고, 초기화문이 없는 변수선언문은 무시된다. 이때 에러는 발생하지 않는다.<br>위 코드와 같이 만약 동일한 이름의 변수가 이미 선언되어있는것을 모르고 변수를 중복선언하면서 값까지 할당했다면 의도치않게 먼저선언된변수의 값이 변경되는 부작용이 발생한다.<br>1-2. 함수 레벨 스코프</p>
<ul>
<li>var 키워드로 선언한 변수는 오로지 함수의 코드블록만을 지역스코프로 인정한다. 따라서 함수 외부에서 var키워드로 선언한변수는 코드블록내에서 선언해도 모두 전역변수가 된다.<br>var x = 1;<br>if(true) {<br>// x는 전역변수다. 이미선언된 전역변수 x가 있으므로 x변수는 중복선언된다.<br>// 이는 의도치않게 변수값이 변경되는 부작용을 발생시킨다.<br>var x = 10;<br>}<br>console.log(x); // 10</li>
<li>for문의 변수선언문에서 var키워드로 선언한 변수도 전역변수가 된다.<br>var i = 10;<br>// for문에서 선언한 i는 전역변수이다. 이미선언된 전역변수 i가 있으므로 중복선언된다.<br>for(var i = 0; i&lt;5; i++) {<br>console.log(i); // 0 1 2 3 4<br>}<br>//의도치않게 i변수의 값이 변경되었다.<br>console.log(i); // 5<br>함수 레벨 스코프는 전역변수를 남발할 가능성을 높인다. 이로인해 의도치않게 전역변수가 중복선언되는 경우가 발생한다.<br>1-3. 변수 호이스팅</li>
<li>var키워드로 변수를 선언하면 변수호이스팅에의해 변수선언문이 스코프의 선두로 끌어올려진것처럼 동작한다. 즉, 변수호이스팅에의해 var키워드로 선언한 변수는 변수선언문 이전에 참조할수 있다. 단, 할당문이전에 변수를 참조하면 언제나 undefined를 반환한다.<br>// 이 시점에는 변수 호이스팅에 의해 이미 foo 변수가 선언되었다.( 1.선언단계)<br>// 변수 foo는 undefined로 초기화된다.( 2.초기화단계)<br>console.log(foo); // undefined</li>
</ul>
<p>//변수에 값을 할당( 3.할당 단계)<br>foo = 123;<br>console.log(foo); // 123</p>
<p>// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행된다.<br>var foo;</p>
<p>변수선언문 이전에 변수를 참조하는것은 변수호이스팅에의해 에러를 발생시키지는않지만 프로그램의 흐름상 맞지않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.</p>
<ol start="2">
<li>let키워드</li>
</ol>
<ul>
<li>앞에서 살펴본 var키워드의 단점을 보완하기위해 ES6에서는 새로운 변수 선언 키워드인 let과 const를 도입했다. var키워드와의 차이점을 중심으로 let키워드를 살펴보자.<br>2-1. 변수 중복 선언 금지</li>
<li>var 키워드로 이름이 동일한 변수를 중복선언하면 아무런 에러가 발생하지 않는다. 이때 변수를 중복선언하면서 값까지 할당했다면 의도치않게 먼저 선언된 변수값이 재할당되어 변경되는 부작용이 발생한다. </li>
<li>하지만 let키워드로 이름이 같은 변수를 중복선언하면 문법에러(SyntaxError)가 발생한다.<br>var foo = 123; // var키워드로 선언된 변수는 같은 스코프내에서 중복선언을 허용한다.<br>var foo = 456; // 자바스크립트엔진에 의해 var키워드가 없는것처럼 동작한다.<br>let bar = 123; // let이나 const 키워드로 선언된 변수는 같은 스코프내에서 중복선언을 허용하지않는다.<br>let bar = 456; // SyntaxError: Identifier ‘bar’ has already been declared<br>2-2. 블록 레벨 스코프</li>
<li>var키워드로 선언한 변수는 오로지 함수의 코드블록만을 지역스코프로 인정하는 함수레벨스코프를 따른다. 하지만 let키워드로 선언한 변수는 모든 코드블록(함수, if문, for문, while문, try/catch문 등)을 지역스코프로 인정하는 블록레벨스코프(block-level scope)를 따른다.</li>
<li>다음 코드를 살펴보자<br>let foo = 1; // 전역변수<br>{<br>let foo = 2; // 지역변수<br>let bar = 3; // 지역변수<br>}<br>console.log(foo); // 1<br>console.log(bar); // ReferenceError: bar is not defined</li>
</ul>
<p>let키워드로 선언된 변수는 블록레벨스코프를 따른다. 따라서 위 예제의 코드블록내에서 선언된 foo변수와 bar변수는 지역변수다. 전역에서 선언된 foo변수와 코드블록내에서 선언된 foo변수는 다른별개의 변수다. 또한 bar변수도 블록레벨스코프를 갖는 지역변수다. 따라서 전역에는 bar변수를 참조할수 없다.<br>함수도 코드블록이므로 스코프를 만든다. 이때 함수내의 코드블록은 함수레벨스코프에 중첩된다.<br>2-3. 변수 호이스팅</p>
<ul>
<li>var 키워드로 선언한 변수와 달리 let키워드로 선언한 변수는 변수호이스팅이 발생하지 않는것처럼 동작한다.<br>console.log(foo); //ReferenceError: foo is not defined<br>let foo;</li>
</ul>
<p>이처럼 let키워드로 선언한 변수를 변수선언문 이전에 참조하면 참조에러(ReferenceError)가 발생한다.<br>var 키워드로 선언한 변수는 런타임이전에 자바스크립트 엔진에 의해 암묵적으로 “선언단계”와 “초기화단계”가 한번에 진행된다.</p>
<p>즉, 선언단계에서 스코프(실행컨텍스트의 렉시컬환경(Lexical Environment))에 변수 식별자를 등록해 자바스크립트 엔진에 변수의 존재를 알린다. 그리고 즉시 초기화단계에서 undefined로 변수를 초기화한다. 따라서 변수선언문 이전에 변수에 접근해도 스코프에 변수가 존재하기때문에 에러가 발생하지않는다. 다만 undefined를 반환한다. 이후 변수할당문에 도달하면 비로소 값이 할당된다.</p>
<p>// var 키워드로 선언한 변수는 런타임이전에 선언단계와 초기화단계가 실행된다.<br>// 따라서 변수선언문 이전에 변수를 참조할수 없다.<br>console.log(foo); // undefined<br>var foo;<br>console.log(foo); // undefined<br>foo = 1; // 할당문에서 할당단계가 실행된다.<br>console.log(foo); // 1<br>설명:<br>let키워드로 선언한 변수는 “선언단계”와 “초기화단계”가 분리되어 진행된다. 즉, 런타임이전에 자바스크립트엔진에 의해 암묵적으로 선언단계가 먼저 실행되지만 초기화단계는 변수선언문에 도달했을때 실행된다.<br>만약 초기화단계가 실행되기 이전에 변수에 접근하려고하면 참조에러(ReferenceError)가 발생한다. let키워드로 선언한 변수는 스코프의 시작지점부터 초기화단계시작지점(변수선언문)까지 변수를 참조할수없다. 스코프의 시작지점부터 초기화시작지점까지 변수를 참조할수 없는 구간을 일시적사각지대(Temporal Dead Zone; TDZ)라고 부른다.</p>
<p>// 런타임이전에 선언단계가 실행된다. 아직변수가 초기화되지 않았다.<br>// 초기화이전의 일시적 사각 지대에서는 변수를 참조할수 없다.<br>console.log(foo);// ReferenceError: foo is not defined</p>
<p>let foo; // 변수선언문에서 초기화단계가 실행된다.<br>console.log(foo); // undefined</p>
<p>foo = 1; // 할당문에서 할당단계가 실행된다.<br>console.log(foo); // 1<br>설명 :<br>결국 let 키워드로 선언한 변수는 변수호이스팅이 발생하지않는것처럼 보인다. 하지만 그렇지 않다.<br>let foo = 1; // 전역변수<br>{<br>  console.log(foo); // ReferenceError: Cannot access ‘foo’ before initialization<br>  let foo = 2; //지역변수<br>}<br>설명:<br>let 키워드로 선언한 변수의 경우, 변수호이스팅이 발생하지않는다면 위 코드는 전역변수foo의 값을 출력해야한다. 하지만 let키워드로 선언한 변수도 여전히 호이스팅이 발생하기때문에 참조에러(ReferenceError)가 발생한다.<br>자바스크립트는 ES6에서 도입된 let, const를 포함해서 모든 선언(var, let, const, function, function*, class 등)을 호이스팅한다. 단,ES6에서 도입된 let, const, class를 사용한 선언문은 호이스팅이 발생하지않는것처럼 동작한다.<br>2-4. 전역 객체와 let</p>
<ul>
<li>var키워드로 선언한 전역변수와 전역함수, 그리고 선언하지않은 변수에 값을 할당한 암묵적 전역은 전역객체에 window의 프로퍼티가 된다. 전역객체의 프로퍼티를 참조할때 window를 생략할수 있다.<br>// 이 코드 예제는 브라우저 환경에서 실행해야 한다.<br>//전역변수<br>var x=1;<br>//암묵적전역<br>y=2;<br>//전역함수<br>function foo() {}</li>
</ul>
<p>//var키워드로 선언한 전역변수는 전역객체 window의 프로퍼티다.<br>console.log(window.x); // 1<br>//전역객체 window의 프로퍼티는 전역변수처럼 사용할수 있다.<br>console.log(x); // 1</p>
<p>//암묵적 전역은 전역객체 window의 프로퍼티다.<br>console.log(window.y); // 2<br>console.log(y); // 2</p>
<p>//함수선언문으로 정의한 전역함수는 전역객체 window의 프로퍼티다.<br>console.log(window.foo); // f foo() {}<br>//전역객체 window의 프로퍼티는 전역변수처럼 사용할수 있다.<br>console.log(foo); // f foo() {}<br>설명:<br>let키워드로 선언한 전역변수는 전역객체의 프로퍼티가 아니다. 즉,window.foo와같이 접근할수 없다. let전역변수는 보이지않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드. 이에 대해서는 ‘실행 컨텍스트’에서 자세히 공부하자.)내에 존재하게 된다.<br>// 이 코드 예제는 브라우저 환경에서 실행해야한다.<br>let x = 1;</p>
<p>//let. const키워드로 선언한 전역변수는 전역객체 window의 프로퍼티가 아니다.<br>console.log(window.x); // undefined<br>console.log(x); // 1</p>
<ol start="3">
<li>const 키워드</li>
</ol>
<ul>
<li>const 키워드는 상수(constant)를 선언하기위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다. 이에 대해서는 후반부에 설명한다. const키워드의 특징은 let키워드와 대부분 동일하므로 let키워드와 다른점을 중심으로 살펴보자.<br>3-1. 선언과 초기화</li>
<li>const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야한다.<br> const foo = 1;<br> 그렇지않으면 문법에러가 발생한다.<br> const foo; // SyntaxError: Missing initializer in const declaration</li>
<li>const키워드로 선언한 변수는 let키워드로 선언한 변수와 마찬가지로 블록레벨스코프를 가지며, 변수호이스팅이 발생하지않는것처럼 동작한다.<br> {<br>   // 변수 호이스팅이 발생하지 않는 것처럼 동작한다.<br>   console.log(foo); // ReferenceError: Cannot access ‘foo’ before initialization<br>   const foo = 1;<br>   console.log(foo); // 1<br> }<br> //블록 레벨 스코프를 갖는다.<br> console.log(foo); // ReferenceError: foo is not defined<br>3-2. 재할당 금지</li>
<li>var 또는 let키워드로 선언한 변수는 재할당이 자유로우나 const키워드로 선언한 변수는 재할당이 금지된다.<br>const foo = 1;<br>foo = 2; // TypeError: Assignment to constant variable.<br>3-3. 상수</li>
<li>const키워드로 선언한 변수에 원시값을 할당한경우 변수값을 변경할수 없다. 원시값은 변경불가능한 값(immutable value)이므로 재할당없이 값을 변경할수있는 방법이 없기때문이다. 이러한 특징을 이용해 const키워드를 상수를 표현하는데에 사용하기도 한다.</li>
<li>변수의 상대개념인 상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기위한 메모리공간이 필요하므로 변수라고 할수있다. 단, 변수는 언제든지 재할당을 통해 변수값을 변경할수 있지만 재할당이 금지된다.</li>
<li>상수는 상태유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야한다.<br>//세전가격<br>let preTaxPrice = 100;</li>
</ul>
<p>//세후가격<br>//0.1의 의미를 명확히 알기 어렵기때문에 가독성이 좋지 않다.<br>let afterTaxPrice = preTaxPrice+(preTaxPrice*0.1);<br>console.log(afterTaxPrice); // 110<br>설명:<br>코드내에서 사용한 0.1은 어떤의미로 사용했는지 명확히 알기 어렵기 때문에 가독성이 좋지않다. 또한 세율을 의미하는 0.1은 쉽게바뀌지않는 값이며, 프로그램전체에서 고정된 값을 사용해야한다. 이때 세율을 상수로 정의하면 값의 의미를 쉽게 파악할수있고 변경될수없는 고정값으로 사용할수있다.<br>const 키워드로 선언된 변수는 재할당이 금지된다. const 키워드로 선언된 변수에 원시값을 할당한 경우, 원시값은 변경할 수 없는 값(immutable value)이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다. 또한 상수는 프로그램 전체에서 공통적으로 사용하므로 나중에 세율이 변경되면 상수만을 변경하면 되기 때문에 유지보수성이 대폭 향상된다.<br>일반적으로 상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다. 여러 단어로 이뤄진 경우에는 언더스코어(_)로 구분해서 스네이크 케이스로 표현하는 것이 일반적이다.<br>//세율을 의미하는 0.1은 변경할 수 없는 상수로서 사용할 값이다.<br>//변수 이름을 대문자로 선언해 상수임을 명확히 나타낸다.<br>const TAX_RATE = 0.1;</p>
<p>//세전 가격<br>let preTaxPrice = 100;</p>
<p>//세후 가격<br>let afterTaxPrice = preTaxPrice+(preTaxPrice*TAX_RATE);<br>console.log(afterTaxPrice); // 110<br>3-4. const 키워드와 객체</p>
<ul>
<li>const 키워드로 선언된 변수에 원시값을 할당한경우 값을 변경할수 없다. 하지만 const키워드로 선언된 변수에 객체를 할당한 경우, 값을 변경할수 있다. 변경불가능한 값인 원시값은 재할당없이 변경(교체)할수 있는 방법이 없지만 변경가능한 값인 객체는 재할당없이도 직졉변경이 가능하기 때문이다.<br>const person = {<br>name: ‘Lee’<br>};<br>//객체는 변경 가능한 값이다. 따라서 재할당없이 변경이 가능하다.<br>person.name = ‘Kim’;<br>console.log(person); // {name:”Kim”}<br>설명:<br>const키워드는 재할당을 금지할뿐 “불변(immutable)”을 의미하지 않는다. 다시말해, 새로운 값을 재할당하는것은 불가능하지만 프로퍼티 동적 생성, 삭제, 프로퍼티값의 변경을 통해 객체를 변경하는것은 가능하다. 이때 객체가 변경되더라도 변수에 할당된 참조값은 변경되지 않는다.</li>
</ul>
<ol start="4">
<li>var vs. let vs. const</li>
</ol>
<ul>
<li>변수선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는것이 좋다. const키워드를 사용하면 의도치않은 재할당을 방지하기 때문에 좀 더 안전하다.</li>
<li>var, let, const키워드는 다음과 같이 사용하는것을 권장한다.<br>ES6를 사용한다면 var키워드는 사용하지 않는다.<br>재할당이 필요한 경우에 한정해 let키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.<br>변경이 발생하지않고 읽기전용으로 사용하는 (재할당이 필요없는 상수)원시값과 객체에는 const키워드를 사용한다. const키워드는 재할당을 금지하므로 var, let키워드보다 안전하다.</li>
<li>변수를 선언하는 시점에는 재할당이 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당하는 경우가 드물다.(Angular, React, Vue.js와 같은 SPA프레임워크에서는 상태가 변경되었음을 명확히 하기위해 변경된 객체를 재할당하는 경우도 있다.) 따라서 변수를 선언할때는 일단 const키워드를 사용하자. 반드시 재할당이 필요하다면(반드시 재할당이 필요한지 한번생각해볼 일이다.)그때 const키워드를 let키워드로 변경해도 결코 늦지 않는다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/09/16/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90problem-of-global-variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90problem-of-global-variable/" class="post-title-link" itemprop="url">전역변수의 문제점problem of global variable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-16 22:19:32 / Modified: 22:20:40" itemprop="dateCreated datePublished" datetime="2020-09-16T22:19:32+09:00">2020-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>전역변수의 무분별한 사용은 위험하다. 전역변수를 반드시 사용해야할 이유를 찾지못한다면 지역변수를 사용해야한다. </li>
<li>전역변수의 문제점과 전역변수의 사용을 억제할 수 있는 방법을 살펴보자.</li>
</ul>
<ol>
<li>변수의 생명 주기<br>1-1. 지역 변수의 생명 주기</li>
</ol>
<ul>
<li>변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가는 소멸한다.= 변수는 생물과 유사하게 생성되고 소멸되는 생명주기(life cycle)가 있다. 변수에 생명주기가 없다면 한번선언된 변수는 프로그램을 종료하지않는 한 영원히 메모리공간을 점유하게 된다.</li>
<li>변수는 자신이 선언된 위치에서 생성되고 소멸한다. 전역변수의 생명주기는 애플리케이션의 생명주기와 같다. 하지만 함수내부에서 선언된 지역변수는 함수가 호출되면 생성되고, 함수가 종료하면 소멸한다.<br>function foo() {<br>var x = ‘local’;<br>console.log(x); // local<br>return x;<br>}<br>foo();<br>console.log(x); // ReferenceError: x is not defined</li>
<li>설명:<br>-지역변수 x는 foo함수가 호출되기 이전까지는 생성되지 않는다. foo함수를 호출하지않으면 함수내부의 변수선언문이 실행되지않기 때문이다.<ul>
<li>‘4변수.4변수선언의실행시점과변수호이스팅’에서 살펴보았듯이 변수선언은 선언문이 어디에 있든 상관없이 가장먼저 실행된다. 다시말해, 변수선언은 코드가 한줄씩 순차적으로 실행되는 시점인 런타임에 실행되는것이 아니라 런타임이전단계에서 자바스크립트엔진에 의해 먼저 실행된다.<br>그런데, 엄밀히 말하자면 위 설명은 전역변수에 한정된 것이다. 함수내부에서 선언한 변수는 함수가 호출된 직후에 함수몸체의 코드가 한줄씩 순차적으로 실행되기이전에 자바스크립트 엔진에 의해 먼저 실행된다.</li>
<li>위 코드의 foo함수를 호출하면 함수 몸체의 다른 문들이 순차적으로 실행되기 이전에 x변수의 선언문이 자바스크립트엔진에 의해 가장 먼저 실행되어 x 변수가 선언되고 undefined로 초기화된다. 그후, 함수몸체를 구성하는 문들이 순차적으로 실행되기 시작하고 변수할당문이 실행되면 x변수에 값이 할당된다. 그리고 함수가 종료하면 x변수도 소멸되어 생명주기가 종료된다. 따라서 함수내부에서 선언된 지역변수 x는 foo함수가 호출되어있는 동안에만 유효하다. 즉, 지역변수의 생명주기는 함수의 생명주기와 일치한다.</li>
</ul>
</li>
<li>함수 몸체내부에서 선언되 지역변수의 생명주기는 함수의생명주기와 대부분일치하지만 지역변수가 함수보다 오래생존하는 경우도 있다.</li>
<li>변수는 하나의 값을 저장하기위해 확보한 메모리공간 자체 또는 그 메모리공간을 식별하기위해 붙인 이름이다. 따라서 변수의 생명주기는 메모리공간이 확보(allocate)된 시점부터 메모리공간이 해제(release)되어 가용메모리풀(memory pool)에 반환되는 시점까지다.</li>
<li>함수내부에서 선언된 지역변수는 함수가 생성한 스코프에 등록된다. 함수가 생성한 스코프는 렉시컬환경이라 부르는 물리적인 실체가 있다고 했다. 따라서 변수는 자신이 등록된 스코프가 소멸(스코프가 메모리에서 해제)될때까지 유효하다. 할당된메모리공간은 더이상 그누구도 참조하지않을때 가비지콜렉터에 의해 해제되어 가용메모리풀에 반환된다. 즉, 누군가 메모리 공간을 참조하고 있으면 해제되지않고 확보된 상태로 남아있게된다. 이는 스코프도 마찬가지다. 누군가 스코프를 참조하고있으면 스코프는 스멸하지않고 생존하게 된다.</li>
<li>일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸한다. 하지만 누군가가 스코프를 참조하고있다면 스코프는 해제되지않고 생존하게 된다. 클로저에서 자세히 공부해보자.</li>
<li>변형 문제 풀어보자<br>var x = ‘global’;<br>function foo() {<br>console.log(x); // ?-1<br>var x = ‘local’;<br>console.log(x); // ?-2 -&gt; 여기서는 x변수에 재할당된 local이 출력된다.<br>}<br>foo();<br>console.log(x);// global<br>나: ?-1: global , 정답: undefined<br>설명: foo함수내부에서 선언된 지역변수 x는 ?-1의 시점에 이미선언되었고 undefined로 초기화되어있다. 따라서 전역변수 x를 참조하는것이 아니라 지역변수 x를 참조해 값을 출력한다. 즉, 지역변수는 함수전체에서 유효하다. 단, 변수할당문이 실행되기이전까지는 undefined값을 갖는다.</li>
</ul>
<p>이처럼 호이스팅은 스코프단위로 동작한다.<br>전역변수의 호이스팅은 전역변수의 선언이 전역스코프의 선두로 끌어올려진것처럼 동작한다. 따라서 전역변수는 전역 전체에서 유효하다.<br>지역변수의 호이스팅은 지역변수의 선언이 지역스코프의 선두로 끌어올려진것처럼 동작한다. 따라서 지역변수는 함수 전체에서 유효하다.<br>즉, 호이스팅은 변수선언이 스코프의 선두로 끌어올려진것처럼 동작하는 자바스크립트 고유의 특징을 말한다.</p>
<p>1-2. 전역 변수의 생명 주기</p>
<ul>
<li><p>함수와 달리 전역코드는 명시저인 호출없이 실행된다. 다시말해, 전역코드는 함수호출과 같이 전역코드를 실행하는 특별한 진입점(entry point)이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.<br> **** 진입점(entry point): C나 자바로 작성된 코드를 실행하면 가장먼저 main함수가 호출된다. 이 main함수는 프로그램이 시작되는 지점이므로 이를 진입점 또는 시작점이라고 한다.</p>
</li>
<li><p>함수는 함수몸체의 마지막 문 또는 반환문이 실행되면 종료한다. 하지만 전역코드에는 반환문을 사용할수 없으므로 마지막 문이 실행되어 더이상 실행할 문이 없을때 종료한다.</p>
</li>
<li><p>var키워드로 선언한 전역변수는 전역객체의 프로퍼티가 된다. 이는 전역변수의 생명주기가 전역객체의 생명주기와 일치한다는것을 말한다.<br> **** 전역 객체(global object): 전역 객체는 코드가 실행되기 이전단계에 자바스크립트엔진에 의해 어떤 객체보다도 먼전 생성되는 특수한 객체다. 전역객체는 클라이언트사이드환경(브라우저)에서는 window, 서버사이드환경(Node.js)에서는 global객체를 의미한다. 환경에 따라 전역객체를 가리키는 다양한 식별자(window, self, this, frames, global)가 존재했으나 ES11(ECMAScript 11) 에서 globalThis로 통일되었다. 전역객체에는 표준빌트인객체(Object, String, Number, Function, Array..)와 환경에 따른 호스트객체(클라이언트 Web API 또는 Node.js의 호스트 API), 그리고 var키워드로 선언한 전역변수와 전역함수를 프로퍼티로 갖는다. 전역객체와 표준빌트인객체는 빌트인객체에서 공부하자.</p>
</li>
<li><p>브라우저환경에서 전역객체는 window이므로 브라우저환경에서 var키워드로 선언한 전역변수는 전역객체 window의 프로퍼티다. 전역객체 window는 웹페이지를 닫기전까지 유효하다. 따라서 브라우저환경에서 var키워드로 선언한 전역변수는 웹페이지를 닫을때까지 유효하다. 즉, var키워드로 선언한 전역변수의 생명주기는 전역객체의 생명주기와 일치한다.</p>
</li>
<li><p>—————————————————사진넣기</p>
</li>
</ul>
<ol start="2">
<li><p>전역 변수의 문제점</p>
<p>암묵적 결합<br>전역변수를 선언한 의도는 전역, 즉 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역변수를 참조하고 변경할수 있는 암묵적결합(implicit coupling)을 허용하는것이다. 변수의 유효범위가 크면클수록 코드의 가독성은 나빠지고 의도치않게 상태가 변경될수있는 위험성도 높아진다.</p>
<p>긴 생명주기<br>전역변수는 생명주기가 길다. 따라서 메모리리소스도 오랜기간 소비하고 전역변수의 상태를 변경할수 있는 시간도 길고 기회도 많다. 더욱이 var키워드는 변수의 중복선언을 허용하므로 생명주기가 긴 전역변수는 변수이름이 중복될 가능성이 있다. 변수이름이 중복되면 의도치않은 재할당이 이루어진다.<br>ex)<br>var x = 1;<br>// …<br>// 변수의 중복선언. 기존변수에 값을 재할당한다.<br>var x = 100;<br>console.log(x); // 100</p>
</li>
</ol>
<p>지역변수는 전역변수보다 생명주기가 훨씬 짧다. 크지않은 함수의 지역변수는 생존시간이 극히 짧다. 따라서 지역변수의 상태를 변경할수 있는 시간도 짧고 기회도 적다. 이는 전역변수보다 상태 변경에 의한 오류가 발생할 확률이 작다는 것을 의미한다. 또한 메모리 리소스도 짧은 기간만 소비한다.</p>
<p>  스코프 체인 상에서 종점에 존재<br>전역변수는 스코프 체인상에서 종점에 존재한다. 이는 변수를 검색할때 전역변수가 가장 마지막에 검색된다는것을 말한다. 즉, 전역변수의 검색속도가 가장 느리다. 검색속도의 차이는 그다지 크지않지만 속도의 차이는 분명히 있다.</p>
<p>  네임스페이스 오염<br>자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어있다해도 하나의 전역스코프를 공유한다는것이다. 따라서 다른파일내에서 동일한 이름으로 명명된 전역변수나 전역함수가 같은 스코프내에 존재할경우 예상치 못한 결과를 가져올 수 있다.</p>
<ol start="3">
<li>전역 변수의 사용을 억제하는 방법</li>
</ol>
<ul>
<li>전역변수의 무분별한 사용은 위험하다. 전역변수를 반드시 사용해야할 이유를 찾지못한다면 지역변수를 사용해야한다. 변수의 스코프는 좁을수록 좋다. 전역변수를 절대 사용하지말라는 의미가 아닌 무분별한 전역변수의 남발은 억제해야한다는 것이다.<br>전역변수의 사용을 억제할 수 있는 몇가지 방법을 보자.</li>
</ul>
<p>3-1. 즉시 실행 함수</p>
<ul>
<li>함수정의와 동시에 호출되는 즉시실행함수는 단 한번만 호출된다. 모든코드를 즉시실행함수로 감싸면 모든변수는 즉시실행함수의 지역변수가 된다. 이러한 특성을 이용해 전역변수의 사용을 제한하는 방법이다. 이 방법을 사용하면 전역변수를 생성하지않으므로 라이브러리등에 자주 사용된다.<br>(function() {<br> var foo = 10; // 즉시 실행 함수의 지역 변수<br> // …<br>}());<br>console.log(foo); // ReferenceError: foo is not defined</li>
</ul>
<p>3-2. 네임스페이스 객체</p>
<ul>
<li>전역에 네임스페이스(Namespace)역할을 담당할 객체를 생성하고 전역변수처럼 사용하고싶은 변수를 프로퍼티로 추가하는 방법이다.<br>var MYAPP = {}; // 전역 네임스페이스 객체<br>MYAPP.name = ‘Lee’;<br>console.log(MYAPP.name); // Lee</li>
<li>네임스페이스 객체에 또 다른 네임스페이스 객체를 프로퍼티로 추가해서 네임스페이스를 계층적으로 구성할수도 있다.<br>var MYAPP = {}; // 전역 네임스페이스 객체<br>MYAPP.person = {<br> name: ‘Lee’,<br>address: ‘Seoul’<br>};<br>console.log(MYAPP.person.name); // Lee<br>네임스페이스를 분리해서 식별자 충돌을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역변수에 할당되므로 그다지 유용해보이지는 않는다.</li>
</ul>
<p>3-3. 모듈 패턴</p>
<ul>
<li><p>모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다. 모듈패턴의 특징은 전역변수의 억제는 물론 캡슐화까지 구현할 수 있다는것이다.</p>
</li>
<li><p>캡슐화(encapsulation)는 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할수있는 동작(behavior)인 메서드를 하나로 묶는것을 말한다. 캡슐화는 객체의 특정프로퍼티나 메서드를 감출목적으로 사용하기도 하는데 이를 정보은닉(information hiding)이라 한다.</p>
</li>
<li><p>대부분의 객체지향 프로그래밍언어는 클래스를 구성하는 멤버에대해 public, private, protected등의 접근제한자(access modifier)를 사용해 공개범위를 한정할 수 있다. public으로 선언된 데이터 또는 메서드는 외부에서 접근이 가능하지만  private으로 선언된 경우는 외부에서 접근할수 없고 내부에서만 사용된다. 이것은 클래스외부에는 제한된 접근권한을 제공하며 원하지않는 외부의 접근으로부터 내부를 보호하는 기능을 한다.</p>
</li>
<li><p>하지만 자바스크립트는 public, private, protected 등의 접근 제한자를 제공하지 않는다. 모듈패턴은 전역네임스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용한다.<br>var Counter = (function() {<br>// Private 변수<br>var num = 0;</p>
<p>// 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.<br>return{<br>  increase() {</p>
<pre><code>return ++num;</code></pre>
<p>  },<br>  decrease() {</p>
<pre><code>return --num;</code></pre>
<p>  }<br>};<br>}());</p>
</li>
</ul>
<p>// private 변수는 외부로 노출되지 않는다.<br>console.log(Counter.num); // undefined</p>
<p>console.log(Counter.increase()); // 1<br>console.log(Counter.increase()); // 2<br>console.log(Counter.decrease()); // 1<br>console.log(Counter.decrease()); // 0<br>위 코드의 즉시 실행함수는 객체를 반환한다. 이 객체에는 외부에 노출하고싶은 변수나 함수를 담아 반환한다. 이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버(public member)이다. 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지않으면 외부에서 접근할수 없는 프라이빗 멤버(private member)가 된다. 클로저에서 더 공부해보자.</p>
<p>3-4. ES6 모듈</p>
<ul>
<li>ES6 모듈을 사용하면 더는 전역변수를 사용할수 없다. ES6 모듈은 파일자체의 독자적인 모듈스코프를 제공한다. 즉, 모듈내에서 var키워드로 선언한 변수는 더는 전역변수가 아니며 window객체의 프로퍼티도 아니다.</li>
<li>모던 브라우저(Chrome 61, FF 60, SF 10:1, Edge 16이상)에서 ES6 모듈을 사용할 수 있다. script태그에 type=”module”어트리뷰트를 추가하면 로드된 자바스크립트파일은 모듈로서 동작한다. 모듈의 파일확장자는 mjs를 권장한다.<script type=”module” src=”lib.mjs></script>
<script type=”module” src=”app.mjs></script>
ES6 모듈은 IE를 포함한 구형브라우저에서는 동작하지않으며, 브라우저의 ES6 모듈기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기때문에 아직까지는 브라우저가 지원하는 ES6모듈기능보다는 Webpack등의 모듈번들러를 사용하는것이 일반적이다.</li>
<li>모듈과 Webpack등의 모듈 번들러를 도입한느 방법에 대해서는 다음(48,49)에 더 자세히 공부하자.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/09/16/%EC%8A%A4%EC%BD%94%ED%94%84scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/%EC%8A%A4%EC%BD%94%ED%94%84scope/" class="post-title-link" itemprop="url">스코프scope</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-16 22:15:32 / Modified: 22:16:02" itemprop="dateCreated datePublished" datetime="2020-09-16T22:15:32+09:00">2020-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>스코프란?</li>
</ol>
<ul>
<li><p>스코프(scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어에서 기본적이며 중요한 개념이다. 스코프의 이해가 부족하면 다른개념을 이해하기 어려울수 있다. 자바스크립트의 스코프는 다른언어의 스코프와 구별되는 특징이 있으므로 더욱 주의가 필요하다. </p>
</li>
<li><p>var키워드로 선언한 변수와 let 또는 const키워드로 선언한 변수의 스코프도 다르게 동작한다. </p>
</li>
<li><p>스코프는 변수와 함수에 깊은 관련이 있다.</p>
</li>
<li><p>function add(x,y){<br>   console.log(x,y); // 2 5<br>   return x+y;<br>}<br>add(2,5);<br>console.log(x,y); // ReferenceError: x is not defined<br>위와 같이 우리는 함수의 매개변수는 함수몸체내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다는걸 알고있다. 매개변수를 참조할 수 있는 유효범위, 즉 스코프가 함수 몸체내부로 한정되기 때문인걸 이미 배운 셈이다.</p>
</li>
<li><p>변수는 코드의 가장 바깥 영역뿐 아니라 코드블록이나 함수몸체내에서도 선언할 수 있다. 이때 코드블록이나 함수는 중첩될 수 있다.<br>var var1 = 1; // 코드의 가장 바깥영역에서 선언한 변수</p>
</li>
</ul>
<p>if(true) {<br>  var var2 = 2; // 코드 블록내에서 선언한 변수<br>  if(true) {<br>    var var3 = 3; // 중첩된 코드블록 내에서 선언한 변수<br>  }<br>}</p>
<p>function foo() {<br>  var var4 = 4; // 함수 내에서 선언한 변수<br>  function bar() {<br>    var var5 = 5; // 중첩된 함수 내에서 선언한 변수<br>  }<br>}</p>
<p>console.log(var1); // 1<br>console.log(var2); // 2<br>console.log(var3); // 3<br>console.log(var4); // ReferenceError: var4 is not defined<br>console.log(var5); // ReferenceError: var5 is not defined<br>변수는 자신이 선언된 위치에 의해, 자신이 유효한 범위, 즉 다른코드가 변수자신을 참조할 수 있는 범위가 결정된다. 변수뿐만아니라 모든 식별자가 그렇다.<br>모든식별자(변수이름, 함수이름, 클래스이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다. 이를 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.</p>
<ul>
<li>다음 코드를 예측해보자.<br>var x = ‘global’;<br>function foo() {<br>var x = ‘local’;<br>console.log(x); // ?-1<br>}<br>foo();<br>console.log(x); // ?-2</li>
</ul>
<p>*나: ?-1은 ‘local’. ?-2는 ‘global’ - 정답!! 맞음!!</p>
<p>교안 설명: 코드의 가장 바깥영역과 foo함수 내부에 같은 이름을 갖는 x변수를 선언했고 ?-1과 ?-2에서 x변수를 참조했다. 이때 자바스크립트 엔진은 이름이 같은 두개의 변수중에서 어떤 변수를 참조해야할 것인지를 결정해야한다. 이를 식별자결정(identifier resolution)이라 한다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야할 것인지 결정하기때문에 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고 말 할 수도 있다.<br>자바스크립트 엔진은 코드를 실행할 때 코드의 문맥(context)을 고려한다. 코드가 어디서 실행되며 주변에 어떤 코드가 있는지에 따라 위 예제의 ?-1과 ?-2처럼 동일한 코드도 다른 결과를 만들어 낸다.<br>  ****코드의 문맥(context)과 환경(environment) :  ‘코드가 어디서 실행되며 주변에 어떤 코드가 있는지’를 렉시컬환경(lexical environment)이라고 부른다. 즉, 코드의 문맥(context)은 렉시컬 환경으로 이뤄진다. 이를 구현한 것이 “실행 컨텍스트(execution context)”이며, 모든 코드는 실행컨텍스트에서 평가되고 실행된다. 스코프는 실행 컨텍스트와 깊은 관련이 있다.</p>
<p>위 예제에서 코드의 가장 바깥영역에 선언된 x변수는 어디서든 참조할 수 있지만 foo함수 내부에서 선언된 x변수는 foo함수내부에서만 참조할 수 있고 foo함수 외부에서는 참조할 수 없다. 이때 두개의 x변수는 식별자이름이 동일하지만 자신이 유효한 범위,=스코프가 다른 별개의 변수다.<br>만약 스코프라는 개념이 없다면 같은 이름을 갖는 변수는 충돌을 일으키기 떄문에 프로그램 전체에서 하나밖에 사용할 수 없다.<br>식별자(identifier)에 대해 다시 생각해보자. 변수나 함수의 이름과 같은 식별자는 어떤 값을 구별하여 식별해낼수있는 고유한 이름을 말한다. 사람을 고유한 이름으로 구별하듯이 값도 사람이 이해할 수 있는 언어로 지정한 고유한 식별자인 변수이름에 의해 구별하여 참조할 수 있다.<br>식별자는 어떤값을 구별할 수 있어야하는 유일(unique)한 것이기 때문에 식별자인 변수이름은 중복될 수 없다. 즉, 하나의 값은 유일한 식별자에 연결(name binding)되어야 한다.<br>ex) 파일이름도 하나의 파일을 구별하여 식별할 수 있는 식별자이다. 폴더(디렉터리)를 나누어서 파일을 만들면 똑같은 이름의 파일을 각 폴더에 만들 수 있다.<br>이와 마찬가지로 프로그래밍 언어에서는 스코프(유효범위)를 통해 식별자인 변수이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다. 스코프내에서 식별자는 유일해야하지만 다른 스코프에서는 같은 이름의 식별자를 사용할 수 있다.= 스코프는 네임스페이스다.<br> **** var 키워드로 선언한 변수의 중복선언: 같은 스코프내에서 중복선언이 허용되지만, 의도치않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다. 하지만 let이나 const키워드로 선언된 변수는 같은 스코프내에서 중복선언을 허용하지 않는다.</p>
<ol start="2">
<li>스코프의 종류<br>코드는 전역(global)과 지역(local)으로 구분할 수 있다.</li>
</ol>
<p>구분<br>설명<br>스코프<br>변수<br>전역<br>코드의 가장 바깥 영역<br>전역 스코프<br>전역 변수<br>지역<br>함수 몸체 내부<br>지역 스코프<br>지역 변수</p>
<p>이때 변수는 자신이 선언된 위치(전역 또는 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다. 즉, 전역에서 선언된 변수는 전역스코프를 갖는 전역변수이고, 지역에서 선언된 변수는 지역스코프를 갖는 지역변수이다.<br>2-1. 전역과 전역스코프</p>
<ul>
<li>전역이란 코드의 가장 바깥 영역을 말한다. 전역은 전역스코프(global scope)를 만든다. 전역에 변수를 선언하면 전역스코프를 갖는 전역변수(global variable)가 된다. 전역변수는 어디서든지 참조할 수 있다.<br>2-2. 지역과 지역 스코프</li>
<li>지역이란 함수 몸체 내부를 말한다. 지역은 지역스코프(local scope)를 만든다. 지역에 변수를 선언하면 지역스코프를 갖는 지역변수(local variable)가 된다. 지역변수는 자신이 선언된 지역과 하위지역(중첩함수)에서만 참조할 수 있다. 지역변수는 자신의 지역스코프와 하위지역스코프에서 유효하다.</li>
</ul>
<ol start="3">
<li>스코프 체인</li>
</ol>
<p>-함수는 전역에서 정의할 수도 있고 함수 몸체내부에서 정의할수도 있다. 함수몸체내부에서 함수가 정의된것을 ‘함수의 중첩’이라 한다. 그리고 함수 몸체 내부에서 정의한 함수를 ‘중첩함수(nested function)’, 중첩함수를 포함하는 함수를 ‘외부함수(outer function)’라고 한다.</p>
<ul>
<li>함수는 중첩될수 있으므로 함수의 지역스코프도 중첩될수있다. 이는 스코프가 함수의 중첩에 의해 계층적구조를 갖는다는것을 의미한다. 다시말해, 중첩함수의 지역스코프는 중첩함수를 포함하는 외부함수의 지역스코프와 계층적구조를 갖고, 외부함수의 지역스코프를 중첩함수의 상위스코프라 한다.</li>
<li>모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역스코프의 최상위스코프는 전역스코프이다. 이렇게 스코프가 계층적으로 연결된것을 스코프체인(scope chain)이라 한다.</li>
<li>변수를 참조할 때 자바스크립트엔진은 스코프체인을 통해 변수를 참조하는 코드의 스코프에서 시작해서 상위스코프 방향으로 이동하며, 선언된 변수를 검색(identifier resolution)한다. 이를 통해 상위스코프에서 선언한 변수를 하위스코프에서도 참조할 수 있다.</li>
<li>스코프체인은 물리적인 실체로 존재한다. 자바스크립트엔진은 코드(전역코드와 함수코드)를 실행하기에 앞서 자료구조인 렉시컬 환경(Lexical Environment)을 실제로 생성한다. 변수선언이 실행되면 변수식별자가 이 자료구조(렉시컬환경)에 키로 등록되고, 변수할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다. 변수의 검색도 이 자료구조상에서 이뤄진다.</li>
<li>*****렉시컬환경(Lexical Environment) : 스코프체인은 실행컨텍스트의 렉스컬환경을 단방향으로 연결(chaining)한 것이다. 전역 렉시컬환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬환경은 함수가 호출되면 곧바로 생성된다. 실행컨텍스트에서 더 다룬다.<br>3-1. 스코프 체인에 의한 변수 검색</li>
<li>자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위스코프방향으로 이동하면서 선언된 변수를 검색한다. 절대 하위스코프로 내려가면 식별자를 검색하는 일은 없다. 이는 상위스코프에서 유효한 변수는 하위스코프에서 자유롭게 참조할수있지만 하위스코프에서 유효한 변수를 상위스코프에서 참조할수 없다는것을 의미한다.</li>
<li>스코프체인으로 연결된 스코프의 계층적구조는 부자관계로 이뤄진 상속(inheritance)과 유사하다. 상속을 통해 부모의 자산(재산)을 자식이 자유롭게 사용할 수 있지만 자식의 자산(재산)을 부모가 사용할수는 없다. 스코프체인도 마찬가지 개념이다.<br>3-2. 스코프 체인에 의한 함수 검색<br>전역에서 정의된 foo함수와, bar함수 내부에서 정의된 foo함수가 있는 코드를 살펴보자.<br>//전역함수<br>function foo() {<br>console.log(‘global function foo’);<br>}</li>
</ul>
<p>function bar() {<br>  //중첩함수<br>  function foo() {<br>    console.log(‘local function foo’);<br>  }<br>  foo(); // ?-1<br>}</p>
<p>bar();<br>나: foo: ‘global function foo’, bar: undefined??<br>결과: foo: ‘local function foo’, bar: ‘ ‘</p>
<ul>
<li>교안 설명 : 함수선언문으로 함수를 정의하면 런타임이전에 함수객체가 먼저 생성되고 자바스크립트 엔진은 함수이름과 동일한이름의 식별자를 암묵적으로 선언하고 생성된 함수객체를 할당한다.<br>따라서 위 예제의 모든함수는 함수이름과 동일한 이름의 식별자에 할당된다. ?-1에서 함수를 호출하면 자바스크립트 엔진은 함수를 호출하기위해 먼저 함수를 가리키는 식별자 foo를 검색한다.<br>이처럼 함수도 식별자에 할당하기때문에 스코플르 갖는다. 사실 함수는 식별자에 함수객체가 할당된 것 외에는 일반변수와 다를 바가 없다. 따라서 스코프를 “변수를 검색할때 사용하는 규칙”이라고 표현하기보다는 “식별자를 검색하는 규칙”이라고 표현하는 편이 좀더 적합하다.</li>
</ul>
<ol start="4">
<li>함수 레벨 스코프</li>
</ol>
<ul>
<li>지역은 함수몸체내부를 말하고 지역은 지역스코프를 만든다고 했다. 이는 코드블록이 아닌 함수에 의해서만 지역스코프가 생성된다는 의미이다.</li>
<li>C나 자바 등을 비롯한 대부분의 프로그래밍 언어는 함수몸체만이 아니라 모든코드블록(if, for, while, try/catch 등)이 지역스코프를 만든다. 이러한 특성을 블록레벨스코프(block level scope)라 한다. var키워드로 선언된 변수는 오로지 함수의 코드블록(함수 몸체)만을 지역스코프를 인정한다. 이러한 특성을 함수레벨스코프(function level scope)라 한다.</li>
<li>다음 코드를 살펴보자.<br>var x = 1;<br>if(true) {<br> // var 키워드로 선언된 변수는 함수의 코드블록(함수몸체)만을 지역스코프로 인정한다.<br> // 함수 밖에서 var키워드로 선언된 변수는 코드블록내에서 선언되었다할지라도 모두 전역변수다.<br> // 따라서 x는 전역변수다. 이미 선언된 전역변수x가 있으므로 x변수는 중복선언된다.<br> // 이는 의도치않게 변수값이 변경되는 부작용을 발생시킨다.<br> var x = 10;<br>}<br>console.log(x); // 10<br>설명: 위 코드에서 전역변수 x가 선언되었고 if문의 코드블록 내에도 x변수가 선언되었다. 이때 if문의 코드블록내에서 선언된 x변수는 전역변수다.<br>var키워드로 선언된 변수는 블록레벨스코프를 인정하기때문에 함수밖에서 var키워드로 선언된변수는 코드블록내에서 선언되었다할지라도 모두전역변수다. 따라서 전역변수x는 중복선언되고 그 결과 의도치않은 전역변수의 값이 재할당된다.</li>
</ul>
<p>-다른 코드 더 보자.<br>var i = 10;<br>//for문에서 선언한 i는 전역변수이다. 이미 선언된 전역변수 i가 있으므로 중복선언된다.<br>for(var i=0; i&lt;5; i++) {<br>  console.log(i); // 0 1 2 3 4<br>}<br>//의도치않게 변수의 값이 변경되었다.<br>console.log(i); // 5<br>설명: 블록레벨스코프를 지원하는 프로그래밍언어에서는 for문에서 반복을위해 선언된 i변수가 for문의 코드블록내에서만 유효한 지역변수다. 이 변수를 for문 외부에서 사용할 일은 없기때문이다. 하지만 var 키워드로 선언된 변수는 블록레벨스코프를 인정하지않기때문에 i변수는 전역변수가 된다. 따라서 전역변수 i는 중복선언되고 그결과 의도치않은 전역변수의 값이 재할당된다.<br>var키워드로 선언된 변수는 오로지 함수의 코드블록만을 지역스코프로 인정하지만, ES6에서 도입된 let, const 키워드는 블록레벨스코프를 지원한다.</p>
<ol start="5">
<li>렉시컬 스코프</li>
</ol>
<ul>
<li>다음코드의 실행결과를 예측해보자<br>var x = 1;<br>function foo() {<br>var x = 10;<br>bar();<br>}</li>
</ul>
<p>function bar() {<br>  console.log(x);<br>}<br>foo(); // ?-1<br>bar(); // ?-2<br>나 : ?-1: 10, ?-2: 10// 정답: 1, 1<br>설명 : 위 코드의 실행결과는 bar함수의 상위스코프가 무엇인지에 따라 결정어 두가지 패턴을 예측할수 있다.</p>
<ol>
<li>함수를 어디서 호출했는지에 따라 함수의 상위스코프를 결정한다,</li>
<li>함수를 어디서 정의했는지에 따라 함수의 상위스코프를 결정한다,</li>
</ol>
<p>첫번째 방식으로 함수의 상위스코프를 결정한다면 bar함수의 상위스코프는 foo함수의 지역스코프와 전역스코프일것이다.<br>두번째 방식으로 함수의 상위스코프를 결정한다면 bar함수의 상위스코프는 전역스코프일것이다.<br>프로그래밍 언어는 일반적으로 이 두가지 방식중 한가지 방식으로 함수의 상위스코프를 결정한다.</p>
<p>첫번째 방식을 동적스코프(dynamic scope)라 한다. 함수를 정의하는 시점에서 어디서 호출될지 알수없다. 따라서 함수가 호출되는 시점에 동적으로 상위스코프를 결정해야하기때문에 동적스코프라 부른다.<br>두번째 방식을 렉시컬스코프(lexical scope)또는 정적스코프(static scope)라 한다. 동적스코프방식처럼 상위스코프가 동적으로 변하지않고 함수 정의가 평가되는 시점에 상위스코프가 정적으로 결정되기때문에 정적스코프라고 부른다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.</p>
<p>자바스크립트는 렉시컬스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위스코프를 결정한다. 함수가 호출된 위치는 상위스코프 결정에 어떠한 영향도 주지 않는다. 즉, 함수의 상위스코프는 언제나 자신이 정의된 스코프다.</p>
<p>이처럼 함수의 상위스코프는 함수정의가 실행될때 정적으로 결정된다. 함수정의(함수선언문 또는 함수표현식)가 실행되어 생성된 함수객체는 이렇게 결정된 상위스코프를 기억한다. 함수가 호출될때마다 함수의 상위스코프를 참조할 필요가 있기 떄문이다.</p>
<p>위 코드의 bar함수는 전역에서 정의된 함수다. 함수선언문으로 정의된 bar함수는 전역코드가 실행되기 전에 먼저 평가되어 함수객체를 생성한다. 이때 생성된 bar함수 객체는 자신이 정의된 스코프=전역스코프를 기억한다. 그리고 bar 함수가 호출되면 호출된곳이 어디인지 관계없이 언제나 자신이 기억하고있는 전역스코프를 상위스코프로 사용한다. 따라서 위 예제를 실행하면 전역변수 x의 값 1을 두번 출력한다.</p>
<p>렉시컬 스코프는 클로저와 깊은 관계가 있다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/09/11/%EC%A0%9C%EC%96%B4%EB%AC%B8%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/11/%EC%A0%9C%EC%96%B4%EB%AC%B8%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/" class="post-title-link" itemprop="url">제어문연습문제</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-11 19:19:32 / Modified: 19:44:03" itemprop="dateCreated datePublished" datetime="2020-09-11T19:19:32+09:00">2020-09-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="제어문-연습-문제"><a href="#제어문-연습-문제" class="headerlink" title="제어문 연습 문제"></a>제어문 연습 문제</h1><h1 id="control-flow-statement-practice"><a href="#control-flow-statement-practice" class="headerlink" title="control flow statement practice."></a>control flow statement practice.</h1><hr>
<h2 id="과제-1"><a href="#과제-1" class="headerlink" title="과제 1"></a>과제 1</h2><p><strong>if문 코드를 삼항조건 연산자코드로 변경하기.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> res;</span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</span><br><span class="line">  res = <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">  res = <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  res = <span class="string">&#x27;홀수&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>
<p>TODO</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> res = x === <span class="number">0</span> ? <span class="string">&#x27;영&#x27;</span> : x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>
<h2 id="과제-2-16문제"><a href="#과제-2-16문제" class="headerlink" title="과제 2- 16문제"></a>과제 2- 16문제</h2><p><strong>1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">10</span> &lt; x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">    result+=i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result+<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span>===<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(count&lt;<span class="number">10</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(count%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">  &#125;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(count%<span class="number">2</span>===<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">  &#125;</span><br><span class="line">  count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  sum=sum+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
<p><strong>8. 1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span>!==<span class="number">0</span> &amp;&amp; i%<span class="number">3</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">    sum=sum+i;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
<p><strong>9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i%<span class="number">2</span>===<span class="number">0</span> || i%<span class="number">3</span>===<span class="number">0</span>)&#123;</span><br><span class="line">    sum=sum+i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
<p><strong>10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>; j&lt;<span class="number">6</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j+i===<span class="number">6</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>11. 삼각형 출력하기 - pattern 1</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> line1=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> star1=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=line1; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">    star1+=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  star1+=<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(star1);</span><br></pre></td></tr></table></figure>
<p><strong>12. 삼각형 출력하기 - pattern 2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blank=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> result=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> line=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=line; i&gt;<span class="number">0</span>; i--)&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=i; j&lt;i+<span class="number">1</span>; j++)&#123;</span><br><span class="line">    blank+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> star=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">1</span>; k&lt;=i; k++)&#123;</span><br><span class="line">    star+=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result+=blank+star+<span class="string">`\n`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p><strong>13. 삼각형 출력하기 - pattern 3</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> star2=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> line=<span class="number">5</span>; line&gt;<span class="number">0</span>; line--)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>; j&lt;=line; j++)&#123;</span><br><span class="line">    star2+=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  star2+=<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(star2);</span><br></pre></td></tr></table></figure>
<p><strong>14. 삼각형 출력하기 - pattern 4</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> line=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=line; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">  <span class="keyword">var</span> star=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> blank=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">6</span>-i; k&gt;<span class="number">0</span>; k--)&#123;</span><br><span class="line">    star+=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">    blank+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result+=blank+star+<span class="string">`\n`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p><strong>15. 정삼각형 출력하기</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> line=<span class="number">1</span>; line&lt;=<span class="number">5</span>; line++)&#123;</span><br><span class="line">  <span class="keyword">var</span> blank=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> star=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>; k&lt;line*<span class="number">2</span><span class="number">-1</span>; k++)&#123;</span><br><span class="line">    star+=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=line; j&lt;=<span class="number">5</span>; j++)&#123;</span><br><span class="line">    blank+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result+=blank+star+<span class="string">`\n`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p><strong>16. 역정삼각형 출력하기</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> line=<span class="number">1</span>; line&lt;=<span class="number">5</span>; line++)&#123;</span><br><span class="line">  <span class="keyword">var</span> blank=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> star=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">9</span>; j&gt;=line*<span class="number">2</span><span class="number">-1</span>; j--)&#123;</span><br><span class="line">    star+=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k=line; k&gt;<span class="number">0</span>; k--)&#123;</span><br><span class="line">    blank+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result+=blank+star+<span class="string">`\n`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/09/02/%ED%95%A8%EC%88%98function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/%ED%95%A8%EC%88%98function/" class="post-title-link" itemprop="url">함수function</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-02 22:14:08 / Modified: 22:14:20" itemprop="dateCreated datePublished" datetime="2020-09-02T22:14:08+09:00">2020-09-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>함수란?</li>
</ol>
<ul>
<li><p>자바스에서 가장 중요한 핵심 개념1!!!!!</p>
</li>
<li><p>또다른 자바스의 핵심개념인 스코프,실행컨텍스트,클로저,생성자함수에의한객체생성,메서드,this,프로포타입,모듈화 등이 모두 함수와 깊은 관련이 있다. = 함수는 자바스를 정확히 이해하고 사용하기 위해 피해갈수 없는 핵심중의 핵심임.</p>
</li>
<li><p>수학의 함수는 “입력(input)”을 받아 “출력(output)”을 내보내는 일련의 과정을 정의한것. 예를들어, f(x,y)=x+y라는 함수를 정의하고 이 함수에 두개의 입력 2,5를 전달하면 함수는 정의된 일련의 과정, 즉 x+y를 실행해서 7을 출력함. 함수는 마치 재료를 투입받아 제품을 생산하는 기계와 같음.</p>
</li>
<li><p>미리 정의해둔 함수를 실행하는것을 수식으로 표현하면 f(2,5)=7임.<br> 이때 함수 x,y는 함수내부로 입력을 받아들이는 변수이고,<br> 2,5는 함수에서 정의된 일련의 과정을 실행하기 위해 필요한 입력이고,<br> 7은 함수의 실행결과인 출력임.</p>
</li>
<li><p>이때 함수를 실행하기 위해 필요한 입력인 2,5는 입력을 받아들이는 변수 x,y를 통해 함수외부에서 함수내부로 전달됨. 함수의 실행결과인 출력은 함수 외부로 반환됨.</p>
</li>
<li><p>프로그램언어의 함수도 수학의 함수와 같은개념임</p>
</li>
<li><p>함수f(x,y)=x+y를 자바스함수로 표현해보자.<br> =&gt; function add(x,y){ </p>
<pre><code>      return x+y;
   &#125; // = f(x,y)=x+y
   add(2,5); // 7 = f(2,5)=7</code></pre>
<p>프로그래밍 언어의함수는 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행단위로 정의한것.<br>교안의 img참고</p>
</li>
<li><p>함수는 함수정의(function definition)를 통해 생성. 자바스의 함수는 다양한 방법으로 정의할 수 있음.<br>ex)  function add( x , y ) { </p>
<pre><code>      return x + y;
    &#125; // =&gt; 함수정의
    var result = add (2, 5); // =&gt; 함수호출
    console.log(result); // 7 =&gt;함수add에 인수2,5를전달하면서 호출하면 반환값 7을 반환함.</code></pre>
</li>
</ul>
<ol start="2">
<li>함수의 사용 이유</li>
</ol>
<ul>
<li>필요할 때 여러번 호출할 수 있음 = 실행시점으 ㄹ개발자가 결정할 수 있고 몇번이든 재사용이가능.= 코드의 재사용이라는 측면에서 코드중복을 제거하여 매우 유요하고 효율적임.</li>
<li>코드중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있음.</li>
<li>함수는 객체타입의 값임.=이름(식별자)을 붙일수 있음. 함수이름은 변수이름과 마찬가지로 함수자신의 역할을 잘 설명해서 함수내부코드를 이해하지 않고도 함수의 역할을 파악할 수 있게도와 코드의 가독성을 향상시킴.</li>
<li>코드는 동작하는것만이 존재목적이 아님. 코드는 개발자를 위한 문서임.= 사람이 이해할 수 있는코드 - 가독성이 좋은코드가 좋은 코드임!!</li>
</ul>
<ol start="3">
<li>함수 리터럴<br>자바스의 함수는 객체타입임.=숫자값을 리터럴로 생성하고 객체를 객체리터럴로 생성하는것처럼 함수도 함수리터럴로 생성할수 있음. 함수리터럴은 function키워드, 함수이름, 목록, 함수몸체 로 구성됨.</li>
</ol>
<ul>
<li>함수리터럴의 구성요소<ol>
<li>함수 이름<ul>
<li>식별자임=식별자 네이밍 규칙을 준수해야 함.</li>
<li>몸체 내에서만 참조할 수 있는 식별자임.</li>
<li>생략할 수 있음.이름이 있는 함수를 기명함수(named function),이름이 없는함수를 무명,익명함수(anonymous function)라 함.</li>
</ul>
</li>
<li>매개변수 목록<ul>
<li>0개 이상의 매개변수를 소괄호()로 감싸고 쉼표,로 구분함.</li>
<li>각 매개변수는 함수를 호출할 때 지정한 인수가 순서대로 할당됨.=매개변수 목록은 순서에 의미가 있음.</li>
<li>함수몸체내에서 변수와 동일하게 취급됨.  </li>
</ul>
</li>
<li>함수 몸체<ul>
<li>함수가 호출되었을 때 일괄적으로  실행될 문들을 하나의 실행 단위로 정의한 코드블록임.</li>
<li>함수몸체는 함수호출에 의해 실행됨.</li>
</ul>
</li>
</ol>
</li>
<li>리터럴은 값을 생성하기 위한 표기법임.notation. 따라서 함수리터럴도 평가되어 값을 생성하며, 이 값은 객체임. 즉 함수는 객체임.</li>
<li>함수는 객체지만 일반객체와 다름. 일반객체는 호출할 수 없지만 함수는 호출할 수 있음. 일반객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖음.</li>
<li>함수가 객체라는 사실!!! 은 다른 프로그래밍 언어와 구별되는 자바스의 중요한 특징임.</li>
</ul>
<ol start="4">
<li>함수 정의</li>
</ol>
<ul>
<li>함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말함. 자바스엔진에 의해 평가되어 함수객체가 됨.</li>
<li>함수 정의방법 4가지 (모든 함수정의 방식은 함수를 정의한다는 면에서 동일함.)<br>  ① 함수 선언문(function declaration/ function statement)<pre><code>   ex) function add( x, y ) &#123; return x + y; &#125;</code></pre>
  ② 함수 표현식(function expression)<pre><code>   ex) var add = function ( x, y ) &#123; return x + y; &#125;;</code></pre>
  ③ Function 생성자 함수(function constructor)<pre><code>   ex) var add = new function (&#39; x&#39; , &#39; y&#39; , &#39;return x + y&#39; );</code></pre>
  ④ 화살표 함수(arrow function) : ES6<pre><code>   ex) var add = ( x, y ) =&gt; x + y;</code></pre>
**변수 선언과 함수 정의!<pre><code>  : 변수는 &#39;선언(declaration)&#39; 한다고 했지만 함수는 &#39;정의(definition)&#39;한다고 표현했음. 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당됨. 따라서 ECMAScript사양에서도 변수에는 선언(variable declaration), 함수에는 정의(function definition)라고 표현함. 선언과 정의 차이!</code></pre>
4-1.함수 선언문</li>
<li>함수 선언문 사용해 함수 정의하는 방식<br>function add( x, y ) { <pre><code> return x + y; </code></pre>
 } // =&gt;함수 선언문<br>console.dir(add); // f add (x,y) . =&gt;함수 참조, 함수객체의 프로퍼티까지 출력.<br>console.log(add(2,5)); // 7 . =&gt; 함수 호출</li>
<li>함수 리터럴과 혛태가 동일하지만, 함수 선언문은 함수 이름을 생략할 수 없음!!<br> ex) function (x, y){… // 안됨.</li>
<li>표현식이 아닌 문.=변수에 할당할 수 없음. 하지만 함수선언문이 변수에 할당되는 것처럼 보임.<ul>
<li>이유: 자바스엔진이 코드의 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문 인 함수선언문으로 해석하는 경우와 표현식인 문 인 함수리터럴표현식으로 해석하는 경우가 있기 때문임. 함수선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수리터럴과 형태가 동일함. 이는 함수이름이 있는 기명함수리터럴은 함수선언문 또는 함수리터럴 표현식으로 해석될 가능성이 있다는 의미임.</li>
<li>예를 들어, { }은 블록문일수도 있고 객체리터럴일수도 있음.- 중의적표현임. 자바스엔진은 { }처럼 중의적인 코드안의 코드의 문맥에 따라 해석을 달리함. { }이 단독으로 존재하면 블록문으로, { }이 값으로 평가되어야할 문맥에서 피연산자로 사용되면 객체리터럴로 해석 = 동일한 코드도 코드의 문맥에 따라 해석이 달라질수있음.</li>
<li>가명함수리터럴도 중의적인 코드임. = 코드의 문맥에 따라 해석이 달라질 수 있음. 자바스엔진은 함수이름이 있는 함수리터럴을 단독으로 사용(값으로 평가되어야 하는 문맥에서 함수리터럴을 사용하지않는경우=함수리터럴을 피연산자로 사용하지 않는 경우)하면 함수선언문으로 해석, 함수리터럴값으로 평가되어야하는 문맥(함수리터럴을 변수에 할당하거나 피연산자로 사용)으로 사용하면 함수리터럴표현식으로 해석함. !!함수선언문이든 함수리터럴표현식이든 함수가 생성되는 것은 동일함. 하지만 함수생성할때 내부동작에는 차이가 있음.<br>ex1. 가명함수리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.<pre><code>    함수 선언문에서는 함수이름을 생략할 수 없다.
       function foo( ) &#123; console.log(&#39; foo &#39;); &#125;
       foo( ); // foo</code></pre>
ex2. 함수 리터럴을 피연산자로 사용하면 함수 선언문이아니라 함수리터럴표현식으로 해석된다.<pre><code>    함수 리터럴에서는 함수이름을 생랼할 수 있다.
       (function bar( ) &#123; console.log(&#39; bar &#39;);  &#125;);
       bar( ); // ReferenceError: bar is not defined</code></pre>
ex1에서 단독으로 사용된 함수리터럴(foo)은 함수 선언문으로 해석됨.<br>ex2에서 그룹연산자( )내에 있는 함수리터럴(bar)은 함수리터럴표현식으로 해석됨.</li>
<li>자바스엔진은 생성된 함수를 호출하기위해 함수이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 생성된곳에 생성된함수객체를 할당함.</li>
<li>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출함.<br>   ex) var add = function add( x, y ) { return x + y; } ; <pre><code>      console.log(add( 2, 5)); //7</code></pre>
 일때 함수 선언문으로 생성한 함수를 호출한것은 함수이름 add(function add)가아니라 자바스엔진이 암묵적으로 생성한 식별자 add(var add)인것임. 함수이름과 변수이름이 일치해서 함수이름으로 호출되는것같지만 사실은 식별자로 호출된것임.!!  단, 함수선언문과 함수표현식이 정확히 동일하게 동작하는것은 아님.<br>4-2.함수 표현식</li>
</ul>
</li>
<li>자바스의 함수는 객체타입의 값임. 자바스함수는 값처럼 변수에 할당할 수도 있고, 프로퍼티값이 될수도 있고, 배열의 요소가 될수도 있음. 값의 성질을 갖는 객체를 일급 객체(first-class object)라 함. 자바스함수는 일급객체임!! = 함수를 값처럼 자유롭게 사용할 수 있다는 의미.</li>
<li>일급객체인 함수는 함수리터럴로 생성한 함수객체를 변수에 할당할 수 있음.  = 함수정의방식을 함수표현식(function expression)이라 함.<br>  ex) 함수선언문으로 정의함 add 함수를 함수 표현식으로 바꿔서 정의함.<pre><code>     var add = function ( x, y ) &#123; return x + y; &#125;;
     console.log(add(2,5)); // 7</code></pre>
 함수리터럴의 함수이름을 생략할 수 있고, 생략하는것이 일반적임.=익명함수(anonymous function) <ul>
<li>함수를 호출할때는 함수이름이 아니라 함수객체를 가리키는 식별자사용. 함수이름은 함수몸체 내부에서만 유효한 식별자!!이므로 함수이름으로 함수호출할 수 없음.<br>ex)  var add = function foo ( x, y ) { return x + y; };<pre><code>   console.log(add(2,5)); // 7
   console.log(foo(2,5)); // ReferenceError: foo is not defined</code></pre>
</li>
<li>함수 선언문 = “표현식이 아닌 문”</li>
<li>함수 표현식 = “표현식인 문”<br>4-3.함수 생성 시점과 함수 호이스팅<br>ex)</li>
<li>함수 참조      console.dir(add); // f add( x,y )<pre><code>                  console.dir(sub); // undefined   </code></pre>
</li>
<li>함수 호출      console.log(add(2,5)); // 7<pre><code>                  console.log(sub(2,5)); // TypeError: sub is nat a function</code></pre>
</li>
<li>함수 선언문  function add(x,y) { return x+y; }</li>
<li>함수 표현식  var sub = function (x,y) { return x- y ; };</li>
</ul>
</li>
</ul>
<p>ex에서와 같이 함수 선언문으로 정의한 함수는 함수선언문이전에 호출할 수 있음. 함수표현식으로 정의한 함수는 함수표현식이전에 호출할수 없음. =&gt; 함수선언문으로 정의한 함수와 함수표현식으로 정의한 함수의 생성시점이 다르기때문.<br>모든 선언문이 그렇듯 함수선언문도 코드가 한줄씩 순차적으로 실행되는 시점인(runtime) 이전에 자바스엔진에 의해 먼저 실행됨.= 함수선언문으로 함수를 정의하면 런타임 이전에 함수객체가 먼저 생성됨, 자바스 엔진은 함수이름과 동일한이름의 식별자를 암묵적으로 생성하고 생성된함수객체를 할당함.=&gt; 코드가 한줄씩 순차적으로 실행되기시작하면 런타임에는 이미 함수객체가 생성되어있고 함수이름과 동일한 식별자에 할당까지 완료된상태임. 따라서 함수선언문 이전에 함수를 참조할 수 있으며 호출할수도 있음.<br>이처럼 함수선언문이 코드의 선두로 끌어올려진것처럼 동작하는 자바스 고유의 특징을 함수 호이스팅(Function Hoisting)이라 함.<br>함수호이스팅과 변수호이스팅은 미묘한 차이가 있음.<br>var키워드를 사용한 변수선언문과 function키워드를 사용하는 함수선언문은 런타임 이전에 자바스엔진에 의해 먼저실행되어 식별자를 생성한다는 점에서 동일하지만 var키워드로 선언된 변수는 undefined로 초기화되고, 함수선언문을 통해 암묵적으로 생성된식별자는 함수객체로 초기화됨. 따라서 bar키워드를 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가!되지만 함수선언문으로 정의한 함수를 함수선언문이전에 호출하면 함수호이스팅에 의해 호출!이가능함.<br>함수표현식은 변수에 할당되는 값이 함수리터럴인 문임. 따라서 함수표현식은 변수선언문과 변수할당문을 한번에 기술한 축약표현과 동일하게 동작함.<br>변수선언은 런타임이전에 실행되어 undefined로 초기화되지만, 변수할당문의 값은 할당문이 실행되는 시점인 런타임에 평가되므로 함수표현식의 함수리터럴도 할당문이 실행되는 시점에 평가되어 함수객체가 됨.<br>따라서 함수표현식으로 함수를정의하면 함수호이스팅이 발생한느것이 아니라 변수호이스팅이 발생함.!!<br>함수표현식으로 정의한 함수는 반드시 함수표현식 이후에 참조 또는 호출해야함.<br>함수호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야한다는 당연한 규칙을 무시하기때문에 함수선언문대신 함수표현식 사용을 권장함.<br>4-4.function 생성자 함수<br>자바스가 기본제공하는 빌트인 함수인 Function 생성자함수(=constructor function, 객체를 생성하는 함수를 말함. 생성방식은 객체리터럴 외에도 다양한 방벙이 있음.)에 매개변수목록과 함수몸체를 문자열로 전달하면서 new연산자와함께 호출하면 함수객체를 생성해서 변환함. (new연산자 없이 호출해도 결과는 동일.)</p>
<ul>
<li>Function생성자함수로 add함수 생성해보기<ol>
<li>var add1 = new Function ( ‘x’, ‘y’, ‘return x + y’ );<br>  console.log(add1(2,5)); // 7</li>
<li>var add2 = (function( ) {<pre><code>   var a = 10;
   return function ( x, y) &#123;
      return x + y + a;
   &#125;</code></pre>
  }( ));<br> console.log(add2(1,2)); // 13   </li>
<li>var add3 = (function( ) {<pre><code>   var a = 10;
   return  new Function ( &#39;x&#39;, &#39;y&#39;, &#39;return x + y + a;&#39;);</code></pre>
  }( ));<br> console.log(add3(1,2)); // ReferenceError: a is not defined<br>Function 생성자함수로 함수를 생성하는 방식은 일반적이지않으며 바람직하지도 않음.<br>4-5.화살표 함수<br>ES6에서 새롭게 도입된 화살표함수(arrow function)는 function 키워드 대신 화살표 (=&gt;, fat arrow)를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있음.<br>화살표함수는 항상 익명함수로 정의함.<br>ex) const add = ( x, y ) =&gt; x + y;<br>console.log(add(2,5)); // 7<br>화살표함수는 기존함수선언문 또는 함수표현식을 완전히 대체하기위해 디자인된것은 아님. 화살표함수는 기존함수보다 표현만 간략한것이 아니라 내가부동작또한 간략화되어있음.<br>화살표함수는 생성자함수로 함부로사용할수 없고, 기존의 함수와 this바인딩방식이 다르고, prototype프로퍼티가 없고, arguments객체를 생성하지않음.</li>
</ol>
</li>
</ul>
<ol start="5">
<li>함수 호출<br>함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출함. 함수호출연산자 내에는 0개 이상의 인수를 쉼표로 구분해서 나열함. 함수를 호출하면 현재의 실행흐름을 중단하고 호출된 함수로 실행흐름을 옮김. 이때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행됨.<br>5-1.매개변수와 인수<br>함수를 실행하기위해 필요한 값을 함수외부에서 함수내부로 전달할 필요가 있는경우 매개변수(parameter,인자)를 통해 인수(argument)를 전달함. 인수는 값으로 평가될 수 있는 표현식이어야함. 인수는 함수를 호출할때지정,개수와 타입에 제한이 없음.<br>매개변수는 함수를 정의할때 선언, 함수몸체내부에서 변수와 동일하게 취급함.=함수가 호출되면 함수 몸체내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당됨. 함수가 호출될때마다 매개변수가 거치는 단계는 교안을 통해서 보자.<br>매개변수는 함수몸체내부에서만 참조할수있고 함수몸체외부에서는 참조할수없음.= 매개변수의 스코프(유효범위)는 함수내부임.<br>함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크함. = 함수를 호출할때 매개변수의 개수만큼 인수를 전달하는것이 일반적이지만 그렇지않은 경우에도 에러가 발생하지는 않는다. 인수가 부족해서 인수가 할당되지않은 매개변수의 값은 undefined임.<br>예를 들어<br>function add (x,y) {<br>   return x+y;<br> }<br>console.log(add(2)); // NaN<br>일때 매개변수x에는 인수2가 전달되지만, 매개변수y에는 전달할인수가 없어서 undefined로 초기화된 상태 그대로임. 따라서 함수몸체의 문 x+y 는 2+undefined와 같아서 NaN이 반환됨.<br>매개변수보다 인수가 더 많은 경우 초과된 인수는 암묵적으로 arguments객체의 프로퍼티로 보관이 됨.<br>예를 들어<br>function add (x,y) {<br> console.log(arguments); // Arguments(3) [2,5,10, callee: f Symbol(Symbol.iterator): f]<br>  return x+y;<br>}<br>console.log(add(2, 5, 10)); // 7<br>arguments객체는 함수를 정의할 때, 매개변수 개수를 확정할 수 없는 가변인자함수를 구할때 유용하게 사용됨.<br>5-2.인수 확인<br>ex) function add(x,y) {<pre><code>   return x+y;
&#125;
console.log(add(2)); // NaN
console.log(add(&#39;a&#39;, &#39;b&#39;)); // &#39;ab&#39;</code></pre>
예를 보면 자바스 문법상 어떠한 문제도 없으므로 자바스엔진은 아무런 이의없이 위 코드를 실행할것임. 이러한 상황이 발생한 이유 두가지.<pre><code>1). 자바스함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음.
2). 자바스는 동적타입언어. = 자바스함수는 매개변수의 타입을 사전에 지정할수 없음.</code></pre>
따라서 자바스의 경우 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있음.!</li>
</ol>
<ul>
<li>함수 내부에서 적절한 인수가 전달되었는지 확인하더라도 부적절한 호출은 사전에 방지할 수는 없고 에러는 런타임에 발생하게됨. 따라서 타입스크립트와같은 정적타입을 선언할수있는 자바시의 상위확장을 도입해서 컴파일시점에 부적절한 호출을 방지할수있게하는것도 하나의 방법임</li>
<li>단축평가를 사용해 매개변수에 기본값을 할당하는 방법도 있음.</li>
<li>ES6에서 도입된 매개변수기본값을 사용하면 함수내에서 수행하던 인수체크및 초기화를 간소화할수있음. 매개변수기본값은 매개변수에 인수를 전달하지않았을경우와 undefined를 전달한 경우에만 유효함.<br>5-3. 매개변수의 최대 개수</li>
<li>ECMAScript 사양에서는 매개변수의 최대개수에대해 명시적으로 제한하고있지않지만, 물리적한계는 있으므로 자바스엔진마다 매개변수의 최대개수에 대한 제한이 있겠지만 충분히 많은 매개변수르 지정할수 있음.</li>
<li>매개변수는 순서에 의미가 있음. = 매개변수가 많아지면 함수를 호출할때나 전달해야할 인수의 순서를 고려해야함. 이는 함수의 사용법을 이해하기 어렵게만들고, 실수를 발생시킬가능성을 높이고, 유지보수성이 나쁘다(매개변수의 개수나 순서가 변경되면 함수의 호출방법도 바뀌므로 함수를 사용하는 코드전체가 영향을 받음).</li>
<li>따라서 이상적인 매개변수 개수는 0개이며 적을수록 좋고, 한 가지 일만 해야하며 가급적 작게 만들어야 함. 최대 3개이상을 넘지않는것을 권장함.</li>
<li>객체를 인수로 사용하는경우 프로퍼티키만 정확히지정하면 매개변수의 순서를 신경쓰지않아도 됨. 또한 명시적으로 인수의 의미를 설명하는 프로퍼티키를 사용하게되므로 코드의 가독성도 좋아지고 실수도 줄어드는 효과도 있음.</li>
<li>하지만 주의!! 함수 외부에서 함수내부로 전달한 객체를 함수내부에서 변경하면 함수외부의 객체가 변경되는 부수효과(side effect)가 발생함.<br>5-4. 반환문</li>
<li>함수는 return키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행결과를 함수외부로 반환(return)할수있음.</li>
<li>multiply함수는 두개의 인수를 전달받아 곱한 결과값을 return키워드를 사용해 반환함. 함수는 return키워드를 사용해 자바스에서 사용가능한 모든값을 반환할 수 있음. 함수호출표현식은 return키워드가 반환한 표현식의 평가결과=반환값으로 평가됨.</li>
<li>반환문의 역할 두가지<br> 1). 반환문은 함수의 실행을 중단하고 함수몸체를 빠져나감. 반환문이후에 다른문이 존재하면 그 문은 실행되지않고 무시됨.<br> 2). 반환문은 return키워드 뒤에오는 표현식을 평가해 반환함. return키워드뒤에 반환값으로 사용할표현식을 명시적으로 지정하지않으면 undefined가 반환됨.</li>
<li>반환문은 생략할수 있음 .이때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환함.</li>
<li>return키워드와 반환값으로 사용할 표현식사이에 줄바꿈이 있으면 세미콜론 자동삽입기능에의해 세미콜론이 추가되어 의도치않은 결과가 발생할 수있음.</li>
<li>반환문은 함수 몸체내부에서만 사용할수 있음. 전역에서 반환문사용하면 문법에러(SyntaxError: Illegal return statement)가 발생.</li>
<li>참고로 Node.js는 모듈 시스템에 의해 파일별로 독립적인 파일스코프를 갖음. 따라서 Node.js환경에서는 파일의 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않음.</li>
</ul>
<ol start="6">
<li>참조에 의한 전달과 외부 상태의 변경</li>
</ol>
<ul>
<li>원시값은 값에 의한 전달(pass by value), 객체는 참조에 의한 전달(pass by reference) 방식으로 동작함. 매개변수도 함수몸체내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에의한전달, 참조에의한전달방식을 그대로 따름.</li>
<li>함수를 호출하면서 매개변수에 값을 전달하는 방식을 값에의한 호출 (call by value), 참조에 의한 호출(call by reference)로 구별해 부르는 경우도 있으나 동작방식은 값에 의한 전달, 참조에 의한 전달과 동일함.</li>
<li>원시타입인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경(재할당을 통한 교체)해도 원본은 훼손되지 않음.= 외부상태, 함수외부에서 함수몸체내부로 전달한 원시값의 원본을 변경하는 어떠한 부수효과도 발생하지 않음.</li>
<li>하지만 객체타입인수는 참조값이 복사되어 매개변수에 전달되기때문에 함수몸체에서 참조값을 통해 객체를 변경할 경우 원본이 훼손됨.=외부상태,함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원본객체가 변경되는 부수효과가 발생함.</li>
<li>이처럼 하수가 외부상태를 변경하면 상태변화를 추적하기 어려워짐. 이는 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 됨. 함수 내부의 동작을 유심히 관찰하지 않으면 외부상태가 변하는지 아닌지 알기어렵기때문. 언제나 그러하듯 논리가 간단해야 버그가 숨어들지 못한다!</li>
<li>이러한 현상은 객체가 변경할 수 있는 값이며, 참조에의한 전달방식으로 동작하기때문에 발생하는 부작용임. 여러 변수가 참조에 의한 전달방식을 통해 참조값을 공유하고있다면 이 변수들은 언제든지 참조하고있는 객체를 직접 변경할수있다. 복잡한 코드에서 의도치않은 객체의 변경을 추적하는것은 어려운일이다. 객체의 변경을 추적하려면 옵저버(Observer)패턴등을 통해 객체를, 참조를공유하는 모든이들에게 변경사실을 통지하고 이에 대처하는 추가대응이 필요함.</li>
<li>이러한 문제의 해결방법중 하나는 객체를 불변객체(immutable object)로 만들어 사용하는것임. 객체의 복사본을 새롭게 생성하는 비용은 들지만 객체를 마치 원시값처럼 변경불가능한 값으로 동작하게 만드는 것. 이를통해 객체의 상태변경을 원천봉쇄하고 객체의 상태변경이 필요한경우에는 객체의 방어적복사(defensive copy)를 통해 원본객체를 완전히 복제,=깊은복사(Deep copy)를 통해 새로운 객체를 생성하고 재할당을 통해 교체함. 이를 통해 외부상태가 변경되는 부수효과를 없앨수 있다.</li>
<li>외부상태를 변경하지않고 외부상태에 의존하지도않는 함수를 순수함수라 함. 순수함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍패러다임을 함수형프로그래밍이라 함.</li>
</ul>
<ol start="7">
<li>다양한 함수의 형태<br>7-1.즉시 실행 함수</li>
</ol>
<ul>
<li>함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행함수(IIFE,Immediately Invoked Function Expression)라고 함. 즉시 실행함수는 단 한번만 호출되며 다시 호출할수 없음.</li>
<li>즉시실행함수는 이름이 없는 익명함수를 사용하는것이 일반적임. 함수이름이 있는 기명즉시실행함수도 사용할수 있지만 그룹연산자( ) 내의 기명함수는 함수선언문이 아니라 함수리터럴로 평가되며 함수이름은 함수몸체에서만 참조할수있는 식별자이므로 즉시실행함수를 다시 호출할수는 없음.<br>ex) 익명 즉시 실행 함수           기명 즉시 실행 함수<pre><code> (function( ) &#123;....&#125; ( )) ;            (function foo( ) &#123;....&#125; ( )) ;</code></pre>
</li>
<li>즉시 실행함수는 반드시 그룹연산자 ( )로 감싸야함. 안그러면 에러발생. 기명함수도 마찬가지임.</li>
<li>익명 즉시 실행함수에서  그룹연산자( )로 감싸지 않을경우 생기는 에러의 이유 : 함수 선언문으로 인식하고, 함수 선언문은 함수이름을 생략할 수 없어서 함수선언문의 형식에 맞지않아 에러가 발생함.</li>
<li>기명 즉시 실행함수에서 그룹연산자( )로 감싸지 않을경우 생기는 에러의 이유 : 자바스엔진이 암묵적으로 수행하는 세미콜론 자동삽입기능에 의해 함수선언문이 끝나는위치, 즉 함수코드 블록의 닫는 중괄호{ } 뒤에 ; 이 암묵적으로 추가되기 때문에 함수 선언문 뒤의 ( )는 함수 호출연산자가 아닌 그룹연산자로 해석되고, 그룹연산자에 피연산자가 없기때문에 에러가 발생함.</li>
<li>그룹연산자의 피연산자는 값으로 평가되므로 기명 또는 무명함수를 그룹연산자로 감싸면 함수리터럴로 평가되어 함수객체가 됨.</li>
<li>즉, 그룹연산자로 함수를 묶은 이유는 먼저 함수리터럴을 평가해서 함수객체를 생성하기위해서임. 따라서 먼저 함수리터럴을 평가해서 함수객체를 생성할수있다면 그룹연산자이외의 연산자를 사용해도 좋지만 우리는<br>   ( function ( ) {<pre><code>     //  ...
&#125;( )) ;</code></pre>
의 방식을 사용함.</li>
<li>즉시 실행함수도 일반함수처럼 값을 반환할 수 있고 인수를 전달할수도 있음.<br>-&gt; 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있음.<pre><code>var res = (function () &#123;
   var a = 3;
   var b = 5;
   return a * b;</code></pre>
   }());<br>   console.log(res); // 15</li>
</ul>
<p>-&gt;즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있음.<br>    res = (function (a, b) {<br>         return a * b;<br>    }(3, 5));<br>    console.log(res); // 15<br>즉시 실행함수내에 코드를 모아두면 혹시있을수도있는 변수나 함수이름의 충돌을 방지할수있다.<br>7-2.재귀함수</p>
<ul>
<li>함수가 자기자신을 호출하는것을 재귀호출(recursive call)이라 함. 재귀함수(recursive function)는 자기자신을 호출하는 행위, 즉 재귀호출을 수행하는 함수를 말함.</li>
<li>반복문없이 구현할수 있음.</li>
<li>재귀함수는 자신을 무한재귀호출한다. 따라서 재귀함수내에는 재귀호출을 멈출수있는 탈출조건을 반드시 만들어야함. 탈출조건이 없으면 함수가 무한호출되어 스택 오버플로(stack overflow)에러가 발생함.</li>
<li>재귀함수는 반복되는처리를 반복문없이 구현할수 있다는장점이 있지만 무한반복에 빠질 위험이있고, 이로인해 스택오버플로 에러를 발생시킬수 있으므로 주의해서 사용해야함. </li>
<li>재귀함수는 반복문을 사용하는것보다 재귀함수를 사용하는편이 더 직관적으로 이해하기쉬울때만 한정적으로 사용하는것이 바람직함,<br>7-3. 중첩함수</li>
<li>함수 내부에 정의된 함수를 중첩함수(nested function)또는 내부함수(inner function)이라 함. 그리고 중첩함수를 포함하는 함수는 외부함수(outer function)라 부름. 일반적으로 중첩함수는 자신을 포함하는 외부함수를 돕는 헬퍼함수(helper function)의 역할을 함.<br>ex)<br>function outer() {<br>var x = 1;<br>function inner() {  // -&gt;중첩 함수<br>  var y = 2;<br>  console.log(x + y); // 3 ,-&gt;외부 함수의 변수를 참조할 수 있다.<br>}<br>inner();<br>}<br>outer();</li>
<li>스코프와 클로저에 깊은 관련이 있음.<br>7-4. 콜백 함수</li>
<li>교안 깊이 공부</li>
<li>함수의 매개변수를 통해 다른함수의 내부로 전달되는 함수를 콜백함수(callback function)라고 하며, 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차함수(Higher-Order Function, HOF)라고 함. 매개변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍 패러다임에서 고차함수라 함.</li>
<li>중첩함수가 외부함수를 돕는 헬퍼함수의 역할을 하는것처럼 콜백함수도 고차함수에 전달되어 헬퍼함수의 역할을 함. 단, 중첩함수는 고정되어있어서 교체하기 곤란하지만 콜백함수는 함수외부에서 고차함수내부로 주입하기때문에 자유롭게 교체할수 있다는 장점이 있음.= 고차함수는 콜백함수를 자신의 일부분으로 합성함.</li>
<li>고차함수는 매개변수를 통해 전달받은 콜백함수의 호출시점을 결정해서 호출함. = 콜백함수는 고차함수에 의해 호출되며 이때 고차함수는 필요에따라 콜백함수에 인수를 전달할수 있음. 따라서 고차함수에 콜백함수를 전달할때 콜백함수를 호출하지않고 함수자체를 전달해야함.</li>
<li>콜백함수는 비동기처리뿐 아니라 배열고차함수에서도 사용됨.자바스에서 배열은 사용빈도가 매우 높은 자료구조이고 배열을 다룰때 배열고차함수는 매우 중요함.<br>7-5.순수 함수와 비순수 함수</li>
<li>함수형 프로그래밍에서는 어떤 외부 상테에 의존하지도않는, 즉 부수효과가 없는 함수를 순수 함수(pure function)라 하고, 외부상태에 의존하거나 외부상태를변경하는, 즉 부수효과가 있는 함수를 비순수 함수(impure function)라고 함.</li>
<li>순수 함수<ul>
<li>순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수임. = 순수함수는 어떤 외부상태에도 의존하지않고 오직 매개변수를 통해 함수내부로 전달된 인수에게만 의존해 반환값을 만듦. 함수의 외부상태에 의존하는 함수는 외부상태에 따라 반환값이 달라짐.</li>
<li>특징은 함수의 외부상태를 변경하지 않는다는것. = 순수함수는 어떤 외부상태에도 의존하지않으며 외부상태를 변경하지도 않는 함수임.</li>
</ul>
</li>
<li>비순수 함수<ul>
<li>반대로 함수의 외부상태에따라 반환값이 달라지는 함수, 외부상태에 의존하는 함수를 비순수 함수라고 함.</li>
<li>특징은 순수함수와는 달리 함수외부의 상태를 변경하는 부수효과(side effect)가 있다는 것. 비순수함수는 외부상태에 의존하거나 외부상태를 변경하는 함수임.</li>
</ul>
</li>
<li>함수 내부에서 외부상태를 직접참조하면 외부상태에 의존하게 되어 반환값이 변할수 있고, 외부 상태도 변경할 수 있으므로 비순수 함수가 됨. 함수 내부에서 외부상태를 직접참조하지않더라도 매개변수를 통해 객체를 전달받으면 비순수 함수가 됨.</li>
<li>함수가 외부상태를 변경하면 상태변화를 추적하기 어려워짐. 따라서 함수외부상태의 변경을 지양하는 순수함수를 사용하는것이 좋음. 비순수 함수는 코드의 복잡성을 증가시킴. 비순수 함수를 최대한 줄이는 것은 부수효과를 최대한 억제하는것과 같음.</li>
<li>함수형 프로그래밍은 순수함수와 보조함수의 조합을 통해 외부상태를 변경하는 부수효과를 최소화해서 불변성(immutability)을 지향하는 프로그래밍패러다임임. 로직내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결하며, 변수사용을 억제하거나 생명주기를 최소화해서 상태변경을 피해 오류를 최소화하는것을 목표로 함. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게해서 가독성을 해치고, 변수의 값은 누군가에 의해 언제든지 변경될수있어 오류발생의 근본적원인이 될수있기 떄문임.</li>
<li>함수형 프로그래밍은 결국 순수함수를 통해 부수효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이라고 할 수있음. 자바스는 멀티 패러다임언어이므로 객체지향 프로그래밍뿐만아니라 함수형프로그래밍을 적극적으로 활용하고 있음.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/27/%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4object/" class="post-title-link" itemprop="url">객체리터럴object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:43:52 / Modified: 17:44:04" itemprop="dateCreated datePublished" datetime="2020-08-27T17:43:52+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>객체란?<br>Object. 자바스는 객체기반의 프로그래밍 언어이며, 자바스를 구성하는 거의 “모든 것”이 객체. 원시값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체임.<br>원시 타입은 단 하나의 값만을 나타내지만 객체타입(object/ reference type)은 다양한 타입의 값(원시값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조(data structure)임. 또한 원시타입의 값 = 원시값은 변경불가능한 값(immutable value)이지만, 객체타입의값=객체는 변경가능한 값(mutable value)임.<br>객체는 0개 이상의 프로퍼티로 구성된 집합, 프로퍼티는 키(key)와 값(value)으로 구성됨.<br>ex) var person = {</p>
<pre><code> name : &#39;Lee&#39;,
 age : 20</code></pre>
<p>   }; // name과 age는 프로퍼티 키, Lee와 20은 프로퍼티 값. 이 둘을 어우르는것이 프로퍼티.<br>자바스에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있음. 자바스의 함수는 일급객체이므로 값으로 취급할 수 있음. 따라서 함수도 프로퍼티 값으로 사용 할 수 있음. 프로퍼티 값이 함수일경우 일반함수와 구분하기 위해 메서드(method)라고 부른다.<br>ex) var counter = {</p>
<pre><code>  num : 0,                   //프로퍼티
  increase : function() &#123;   //메서드영역 시작
    this.num++;
  &#125;                                        //메서드영역 끝</code></pre>
<p>   };<br>이처럼 객체는 프로퍼티와 메서드로 구성된 집하체임.<br>프로퍼티와 메서드의 역할 : </p>
<ul>
<li>프로퍼티: 객체의 상태를 나타내는 값(data)</li>
<li>메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)<br>이처럼 객체는 상태와 동작을 하나의 단위로 구조화할 수 있어 유용함.<br>** 객체와 함수<br>: 자바스의 객체는 함수와 밀접한 관계를 가짐. 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 함. 자바스에서 함수와 객체는 분리해서 생각할 수 없는 개념=객체를 이해해야 함수를 제대로 이해, 함수를 이해해야 객체를 정확히 이해 가능.</li>
</ul>
</li>
<li><p>객체 리터럴에 의한 객체 생성</p>
</li>
</ol>
<ul>
<li>C++이나 자바와 같은 클래스기반 객체지향언어는 클래스를 사전에 정의하고 필요한 시점에 new연산자와 함께 생성자(constructor)를 호출하여 인스턴스(instance: 클래스에 의해 생성되어 메모리에 저장된 실체를 말함. 객체지향프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념임. 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 함. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성함.</li>
<li>자바스는 프로토타입 객체지향언어로 클래스기반 객체지향언어와는달리 다양한 객체 생성 방법을 지원함. -&gt; 객체 리터럴, Object생성자 함수, 생성자함수, Object.create메서드, 클래스(ES6)<br>이러한 객체 생성 방법중에서 가장일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법임. 리터럴literal은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법을 말함. 객체리터럴은 객체를 생성하기 위한 표기법임.!!!!</li>
<li>객체 리터럴은 중괄호({…})내에 0개 이상의 프로퍼티를 정의함. 변수에 할당이 이루어지는 시점에 자바스엔진은 객체리터럴을 해석해서 객체를 생성함.<br>만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성됨.<br>객체 리터럴의 중괄호는 코드블록을 의미하지 않음!!! 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않음. 하지만 객체 리터럴은 값으로 평가되는 표현식임. = 객체리터럴의 닫는 중괄호 뒤에는 세미콜론 붙임.</li>
<li>객체리터럴은 자바스의 유연함과 강력함을 대표하는 객체 생성 방식임. 객체를 생성하기 위해 클래스를 먼저 정의하고 new연산자와 함께 생성자를 호출할 필요가 없음. 숫자값이나 문자열을 만드는것과 유사하게 리터럴로 객체를 생성함. 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있음.</li>
<li>객체리터럴 외의 객체생성방식은 모두 함수를 사용해 객체를 생성함</li>
</ul>
<ol start="3">
<li>프로퍼티</li>
</ol>
<ul>
<li>객체는 프로퍼티property들의 집합이며 프로퍼티는 키key와 값value로 구성됨.</li>
<li>프로퍼티 나열할때는 쉼표( , )로 구분. 일반적으로 마지막프로퍼티뒤에는 쉼표사용안하지만 사용해도 됨.</li>
<li>프로퍼티 키와 프로퍼티 값으로 사용할수 있는 값:<br>  -프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값<br>  -프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값</li>
<li>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로서 식별자역할을 함. 하지만 반드시 식별자네이밍규칙을 따라야하는것은 아님. 단! 미묘한차이는 있음.</li>
<li>심벌값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용함. 이때 프로퍼티 키는 문자열이므로 따옴표( ‘ ‘ 또는 “ “ )로 묶어야 함. 하지만 식별자네이밍규칙을 준수하는 이름(=자바스에서 사용가능한 유요한 이름)인경우 따옴표 생략 가능.= 식별자네이밍규칙 따르지 않는 이름에는 반드시 따옴표 사용!</li>
<li>가급적 식별자네이밍규칙을 준수하는 프로퍼티 키를 사용할것을 권장!!</li>
<li>문자열 또는 문자열로 평가할수있는 표현식을 사용해 프로퍼티키를 동적으로 생성할수 있음. 사용할 프로퍼티키를 대괄호( […] )로 묶어서 사용.</li>
<li>빈 문자열을 프로퍼티키로 사용해도 에러는나지않지만 키로서 의미를갖지 못하니까 권장하지 않음.</li>
<li>프로퍼티 키에 문자열이나 심벌값 이외의 값을 사용하면 암묵적타입변환을 통해 문자열이 됨. ex)프로퍼티키로 숫자리터럴사용하면 따옴표는 붙지않지만 내부적으로는 문자열로 변환됨.</li>
<li>var, function과 같은 예약어를 프로퍼티 키로 사용해도 에러발생안함.하지만 예상치 못한 에러발생의 여지가 있으니 권장안함.</li>
<li>이미 존재하는 프로퍼티키를 중복선언하면 나중에 선언한프로퍼티로 덮어씀. 에러가 발생하지않으니 주의!!</li>
</ul>
<ol start="4">
<li><p>메서드<br>자바스에서 사용할 수 있는 모든 값은 프로퍼티값으로 사용할수 있다고 했다. 자바스의 함수는 객체다. 따라서 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있음.<br>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드method라 부름.= 메서드는 객체에 묶여있는 함수를 의미.<br>메서드 내부에서 사용한 this키워드는 객체자신을 가리키는 참조변수임.일단간단하게 이렇게 알고있기.</p>
</li>
<li><p>프로퍼티 접근</p>
</li>
</ol>
<ul>
<li>접근방법 두가지<br>  1- 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법(dot notation)<br>  2- 대괄호 프로퍼티 접근 연산자([…])를 사용하는 대괄호 표기법(bracket notation)</li>
<li>프로퍼티키가 식별자네이밍규칙을 준수하는 이름(=자바스에서 사용가능한 이름)이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있음.</li>
<li>마침표 프로퍼티 접근 연산자 또는 대괄호 프로퍼티 접근 연산자의 좌측에는 객체로 평가되는 표현식을 기술함. 마침표 프로퍼티 접근 연산자의 우측 또는 대괄호 프로퍼티 접근 연산자의 내부에는 프로퍼티 키를 지정함.</li>
<li>대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 함. 그렇지않으면 자바스엔진은 식별자로 해석하기 때문. ex) [‘name’] (O) . <a href="X">name</a></li>
<li>객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환함. 이때 ReferenceError가 발생하지 않게 주의!!!</li>
<li>프로퍼티키가 식별자네이밍규칙을 준수하지않는 이름(=자바스에서 사용가능하지 않는 이름)은 반드시 대괄호 표기법을 사용해야함. 단! 프로퍼티키가 숫자로 이루어진 문자열인경우 따옴표 생략가능. 그 외의 경우는 반드시 대괄호 내에 따옴표로 감싼 문자열이어야만 함!!</li>
<li>ex) person.last-name; // 1.브라우저환경: NaN , 2.Node.js환경:ReferenceError  //person[‘last-name’]; 이 맞는 표기.<br>브라우저 환경과 Node.js 환경에서의 실행결과가 다른 이유는  person.last-name을 실행할때 ①자바스엔진은 person.last를 평가②name식별자로 해석됨. Node.js환경은 name식별자 선언이 없으므로, 브라우저환경은 name이라는 전역변수가 암묵적을 존재. 간단하게는 이렇게 다르다. 자세한 것은 교안(나중에 잘 정리해서 추가하기)확인.</li>
</ul>
<ol start="6">
<li><p>프로퍼티 값 갱신<br>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됨.<br>ex) var person = { name: ‘Lee’ };</p>
<pre><code> person.name = &#39;Kim&#39;; //person 객체에 name프로퍼티가 존재하므로 name프로퍼티 값이 갱신됨.
 console.log(person); // &#123;name: &quot;Kim&quot;&#125;</code></pre>
</li>
<li><p>프로퍼티 동적 생성<br>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당됨.<br>ex) var person = { name: ‘Lee’};</p>
<pre><code> person.age=20; // person객체에 age프로퍼티 존재안함. 선언때 프로퍼티가 동적으로 생성되고 값이 할당됨.
 console.log(person);// &#123;name: &quot;Lee&quot;, age: 20&#125;</code></pre>
</li>
<li><p>프로퍼티 삭제<br>delete연산자는 객체의 프로퍼티를 삭제함. 이때 delete연산자의 피연산자는 프로퍼티값에 접근할 수 있는 표현식이어야 함. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시됨.!<br>ex) var person = { name: ‘Lee’};</p>
<pre><code>  person.age=20; // 프로퍼티 동적 생성
  delete person.age; // person 객체에 age프로퍼티 존재하므로 삭제가능.
  delete person.address; // person객체에 address프로퍼티 존재안함으로 에러 발생하지 않음.
  console.log(person); // &#123;name: &quot;Lee&quot;&#125;</code></pre>
</li>
<li><p>ES6에서 추가된 객체 리터럴의 확장 기능<br>ES6에서는 더욱 간편하고 표현력있는 객체 리터럴의 확장기능을 제공함.<br>9-1.프로퍼티 축약 표현<br>객체리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성됨. 프로퍼티 값은 변수에 할당된 값= 식별자 표현식일 수도 있음.<br>ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수이름과 프로퍼티 키가 동일한 이름일때, 프로퍼티키를 생략(property shorthand)할 수 있음. 이때 프로퍼티 키는 변수 이름으로 자동 생성됨.<br>9-2.계산된 프로퍼티 이름<br>문자열 또는 문자열로 타입변환할 수있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도있음. 단, 프로퍼티키로 사용할 표현식을 대괄호([…])로 묶어야 함. 이를 계산된 프로퍼티 이름(computed property name)이라 함.<br>ES6에서는 객체리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생산할 수 있음.<br>9-3.메서드 축약 표현<br>ES6에서 : 메서드 정의할 때, function키워드를 생략한 축약표현 사용가능, </p>
<pre><code>                 ex)ES5에서: sayHi: function()&#123;&#125;/  ES6에서:sayHi()&#123;&#125;
           메서드 축약표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작!</code></pre>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/27/%EC%9B%90%EC%8B%9C%EA%B0%92primitive-%EA%B3%BC-%EA%B0%9D%EC%B2%B4object-reference-%EC%9D%98-%EB%B9%84%EA%B5%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/%EC%9B%90%EC%8B%9C%EA%B0%92primitive-%EA%B3%BC-%EA%B0%9D%EC%B2%B4object-reference-%EC%9D%98-%EB%B9%84%EA%B5%90/" class="post-title-link" itemprop="url">원시값primitive 과 객체object/reference 의 비교</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:42:38 / Modified: 17:43:04" itemprop="dateCreated datePublished" datetime="2020-08-27T17:42:38+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ㅠ(“6.데이터타입”) 참고<br>자바스가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체타입)은 크게 원시타입(primitive type)과 객체(object/ reference type)타입으로 구분.<br>구분하는 이유는? : 근본적으로 다른다는 의미. 세가지 측면에서 다름</p>
<ul>
<li>원시타입의 값(= 원시값)은 변경 불가능한 값(immutable value)임.,<br>객체(참조)타입의 값(=객체)는 변경 가능한 값(mutable value)임.</li>
<li>원시값을 변수에 할당하면 변수(확보된 메모리공간)에는 실제 값이 저장됨. ,<br>객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조값이 저장됨.</li>
<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달됨. 이를 값에 의한 전달(pass by value)라 함.<br> 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨. 이를 참조에 의한 전달(pass by reference)라 함.</li>
</ul>
<ol>
<li>원시값<br>1-1.변경 불가능한 값<br>primitive type=immutable type </li>
</ol>
<ul>
<li><p>한 번 생성된 원시값은 읽기전용(read only)값이라 변경할 수 없음.</p>
</li>
<li><p>값을 변경할 수 없다 : 변수와 값을 구분해서 생각하자. </p>
<pre><code>                                   - 변수: 하나의 값을 저장하기 위해 확보한 메모리공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름,
                                   - 값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과.
                                     따라서  변경 불가능하다는 것은 변수가 아니라 값에 대한 진술임.  = 즉, &quot;원시값은 변경 불가능하다&quot;는 말은 원시값 자체를 변경할 수 없다는 것이지 변수값을 변경할 수 없다는것이 아님!! 변수는 언제든지 재할당을 통해 변수값을 변경(엄밀히 말하자면 교체)할 수 있기때문에 변수라고 부름.</code></pre>
</li>
<li><p>변수의 상대개념인  상수는 재할당이 금지된 변수를 말함. 상수도 값을 저장하기 위한 메모리공간이 필요하므로 변수라고 할 수 있음. 단, 변수는 언제든지 재할당을 통해 변수값을 변경(교체)할 수 있지만 상수는 단 한번만 할당이 허용되므로 변수값을 변경(교체)할 수 없음. =&gt; 상수와 변경불가능한값을 동일시하면 안됨. 상수는 재할당이 금지된 변수일 뿐임!!</p>
</li>
<li><p>원시값은 변경불가능한 값= 읽기 전용 값. = 불변 = 데이터의 신뢰성 보장.</p>
</li>
<li><p>재할당하면 메모리공간 덮어쓰기가 아닌 새로운 메모리공간을 확보하고 저장. 주소가 바뀌는 것. 이러한 특성을 불변성immutability라 함.<br>1-2.문자열과 불변성</p>
</li>
<li><p>데이터 타입에 의한 메모리 공간의 확보가 필요. 단 ECMAScript사양에 문자열타입(2byte)과 숫자타입(8byte)이외의 원시타입은 크기를 명확히규정하고있지않음=브라우저 제조사의 구현에따라 다름.</p>
</li>
<li><p>원시값인 문자열만의 독특한 특징: 문자열은 0개 이상의 문자(character)로 이뤄진 집합을 말하며, 1개의 문자는 2바이트의 메모리공간에 저장됨.=문자열은 몇개의 문자로 이뤄졌느냐에 따라 필요한 메모리공간의 크기가 결정됨. 숫자값은 1도, 1,000,000도 동일한 8byte가 필요하지만 문자열의 경우(단순계산때) 1개의 문자열은 2byte, 10개로 이뤄진 문자열은 20byte필요.</p>
</li>
<li><p>이런 이유들로 C에서는 하나의 문자를 위한 데이터타입(char)만 있을 뿐 문자열 타입은 존재하지 않음. C에서는 문자열을 문자들의 배열로 처리하고 자바에서는 문자열을 String객체로 처리함.</p>
</li>
<li><p>하지만!  -&gt;자바스의 장점: 개발자의 편의를 위해 원시타입인 문자열타입을 제공!! 자바스의 문자열은 원시타입,변경불가능.=문자열이 생성된 이후에는 변경할수없음을 의미</p>
<pre><code> ex) var str = &#39;hello&#39;;
        str = &#39;world&#39;;</code></pre>
<p>  일때, 첫번째문을 실행해서 hello가 저장된 메모리 공간의 첫번째 메모리셀 주소를 가리킨다. 두번째문 실행하면 world메모리생성하고 식별자str은 이것을 가리킴. hello를 수정해서 world를 덮어씌우는게 아니다. hello와world는 모두 메모리에 존재함. 식별자 str이 문자열 hello를 가리키고 있다가 문자열world를 가리키도록 변경되었을 뿐!!!!!!</p>
</li>
<li><p>문자열은 유사배열객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있음.<br>  ** 유사배열객체array-like object란, </p>
<pre><code>   : 마치 배열처럼 인덱스로 프로퍼티 값에 접근할수있고 length프로퍼티를 갖는 객체를 말함. 
      문자열은 마치 배열처럼 인데스를 통해 각 문자에 접근할 수 있고, length프로퍼티를 갖기 때문에 유사배열객체이고 for문으로 순회할수도있음.</code></pre>
<p>1-3.값에 의한 전달</p>
</li>
<li><p>ex) var score = 80;</p>
<pre><code>  var copy = score;

  console.log(score); // 80
  console.log(copy); // 80</code></pre>
<p>일때, 변수에 변수를 할당했을때 어떻게 전달되는가가 핵심이다.<br>copy=score에서 변수값80으로 평가되므로 copy변수에도 80이 할당(새로운 숫자값 80이 생성되어 copy변수에 할당됨)</p>
</li>
<li><blockquote>
<p>변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달됨 = 값에 의한 전달(Pass by value)라 함.<br>score변수와 copy변수의 값 80은 다른 메모리공간에 저장된 별개의 값임!!</p>
</blockquote>
<p>ex) 위 ex에 연결.</p>
<pre><code>   score = 100;

   console.log(score); // 100
   console.log(copy); // ??? (정답: 80)</code></pre>
<p>에서 score변수와 copy변수의 값 80은 다른 메모리공간에 저장된 별개의 값이라 했음. 따라서 score변수의 값을 100으로 재할당 해도 copy변수의 값에는 어떠한 영향도 주지 않음!!</p>
</li>
<li><p>ECMAScript사양에는 “값에 의한 전달”이라는 용어등장하지 않음.<br>“값에 의한 전달”과 “참조에 의한 전달” “공유에의한전달”이라고 표현.</p>
</li>
<li><p>정확히는 “값에 의한 전달”은 값을 전달하는 것이 아닌 메모리 주소를 전달하는것임. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음.</p>
</li>
<li><p>두변수의 원시값은 서로 다른 메모리공간에 저장된 별개의 값이되어 어느한쪽에서 재할당을 통해 값을 변경해도 서로 간섭할수 없음!!!</p>
</li>
</ul>
<ol start="2">
<li>객체</li>
</ol>
<ul>
<li>프로퍼티 개수가 정해져 있지 않으며, 동적으로 추가됙고 삭제할 수 있음. 또한 프로퍼티의 값에도 제약이 없음. = 객체는 원시값과 같이 확보해야할 메모리공간의 크기를 사전에 정해둘 수 없음.</li>
<li>객체는 복합적인 자료구조이므로 객체 관리 방식이 원시값과 비교해서 복잡함. 원시값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에따라 크기가 매우클수도 있음. 객체 생성하고 프로퍼티에 접근하는것도 원시값과 비교할때 비용이 많이 드는 일임. = 객체는 원시값과는 다른 방식으로 동작하게 설계되어있음.<br>2-1.변경가능한 값</li>
<li>객체(참조)타입의 값= 객체는 변경 가능한 값(mutable value)임.</li>
<li>원시값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리공간에 접근하면 원시값에 접근할수있음. = 원시값을 할당한 변수는 원시값자체를 값으로 갖음. !하지만! 객체를 할당한 변수가 기억하는 메모리주소를 통해 메모리공간에 접근하면 참조값(reference value)에 접근할 수 있음. 참조값은 생성된 객체가 저장된 메모리공간의주소, 그 자체임.</li>
<li>ex) var person = { name: ‘Lee’};<pre><code>  console.log(person); //&#123;name: &quot;Lee&quot;&#125; // person변수는 객체 &#123;name: &#39;Lee&#39;;&#125;를 가리키고point(참조하고)있음.
   (이어서)
   person.name = &#39;Kim&#39;; //  프로퍼티 값 갱신
   person.address = &#39;Seoul&#39;; // 프로퍼티 동적 생성
   console.log(person); //&#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125; // person변수는 객체 &#123;name: &#39;Lee;&#125;를 가리키고point(참조하고)있음. ,, // 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조값은 변경되지 않음.</code></pre>
</li>
<li>원시값은 변경 불가능한 값이므로 원시값을 갖는 변수의 값을 변경하려면 재할당을 통해 메모리에 원시값을 새롭게 생성해야함. 하지만 객체는 변경가능한 값으므로 메모리에 저장된 객체를 직접 수정할 수 있음. = 재할당없이 프로퍼티를 동적으로 추가할수도 있고 프로퍼티값을 갱신할수도 있으며 프로퍼티자체를 삭제할수도 있음. </li>
<li>메모리를 효율적으로 사용하기위해, 객체를 복사해 생성하는 비용을 절약해서 성능을 향상시키기위해 객체는 변경 가능한 값으로 설계되어있음. 메모리 사용의 효율성과 성능을 위해 어느정도의 구조적인 단점을 감안한 설계</li>
<li>구조적단점에 따른 부작용: 원시값과는 다르게 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것.<br> **얕은 복사(shallow copy)와 깊은 복사(deep copy)<pre><code>  :얕은복사 - 객체를 프로퍼티 값으로 갖는객체의 경우 한단계까지만 복사.
    깊은 복사 - 객체에 중첩되어있는 객체까지 모두 복사.</code></pre>
2-2.참조에 의한 전달<br>여러개의 식별자가 하나의 객체를 공유할 수 있다는것을 공부하자.</li>
<li>ex) var person = { name: ‘Lee’};<pre><code>   var copy = person // 참조값을 복사 (얕은복사)</code></pre>
객체를 가리키는 변수(원본,person)를 다른변수(사본,copy)에 할당하면 원본의 참조값이 복사되어 전달됨= 참조에의한전달pass by reference<br>원본person과 사본copy는 저장된 메모리 주소는 다르지만 동일한 참조값을 갖음= 모두 동일한 객체를 가리킴.=두개의 식별자가 하나의 객체를 공유함을 의미.= 원본이나 사본중 어느한쪽에서 객체를 변경(재할당이아닌 객체의 프로퍼티값을 변경하거나 프로퍼티추가,삭제)하면 서로 영향을 주고 받음.</li>
<li>ex) var person = { name=’Lee’};<pre><code>   var copy = person; // =&gt;참조값을 얕은 복사함. copy와person은 동일한 참조값 갖음.
   console.log(copy===person); //true =&gt;copy와 person은 동일한 객체를 참조함.
   copy.name = &#39;Kim&#39;; // =&gt;copy를 통해 객체를 변경
   person.address = &#39;Seoul&#39;; // =&gt;person을 통해 동적생성
   console.log(person); // &#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125;
   console.log(copy); // &#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125;
                                        =&gt;copy와person은 동일한객체가리킴.
                                            서로 영향 주고 받음.</code></pre>
</li>
<li>결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어있는 값을 복사해서 전달한다는 면에서 동일.<br>다만 식별자가 기억하는 공간=변수에 저장되어있는 값이 원시값이냐 참조값이냐 하는 차이만 있음.</li>
<li>자바스에는 “참조에 의한 전달”은 존재하지않고 “값에 의한 전달”만이 존재한다고 말할수있음.</li>
<li>따라서 교안에서는 전달되는 값의 종류가 원시값인지 참조값인지 구별해서 강조하는 의미에서 “값에의한전달”과 “참조에의한전달”로 구분해서 부르기로함.</li>
</ul>
<p><strong><em>퀴즈!!</em></strong><br>var person1 = {name=’Lee’};<br>var person2 = {name=’Lee’};<br>console.log(person1 === person2} //  false =&gt;객체의 변수이름이 다름(?)<br>console.log(person1.name === person2.name} //  true =&gt; 객체의 참조값이 같음.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/25/%EC%97%B0%EC%82%B0%EC%9E%90operator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%EC%97%B0%EC%82%B0%EC%9E%90operator/" class="post-title-link" itemprop="url">연산자operator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 22:20:35 / Modified: 22:20:48" itemprop="dateCreated datePublished" datetime="2020-08-25T22:20:35+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation)등을 수행해 하나의 값을 만듦. 이때 연산의 대상의 피연산자(operand)라 함. 피연산자는 값으로 평가될 수 있는 표현식이어야 함.</p>
<ul>
<li>피연산자가 “값”이라는 명사의 역할을 한다면,<br>연산자는 “피연산자를 연산하여 새로운 값을 만든다”라는 동사의 역할을 한다고 볼 수 있음.<br>= 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 함. 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만듦.</li>
</ul>
<ol>
<li>산술연산자<br>arithmetic operator<br>피연산자를 대상으로 수학적 계산을 수행해 새로운 값을 만듦. 산술 연산이 불가능할 경우 NaN을 반환함. 산술연산자는 피연산자의 개수에 따라 이항산술연산자와 단항산술연산자로 구분할 수 있음.<br>1-1. 이항(binary) 산술 연산자<br>binary산술 연산자는 2개의 피연산자를 산술연산해서 숫자값을 만듦.<br>모든 이행 산술연산자는 피연산자의 값을 변경하는 부수효과(side effect)가 없음. = 어떤 산술을 해도 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운값을 만들뿐!<br>종류: +덧셈 -뺼셈 *곱셈 /나누기 %나머지<br>1-2. 단항(unary) 산술 연산자<br>unary산술 연산자는 1개의 피연산자를 산술연산하여 숫자값을 만듦.<br>종류: ++증가(부수효과있음)<pre><code>    --감소(부수효과있음) 
   +어떠한효과없고 음수양수반전도 안하고 부수효과도 없음.
    -양수를음수로음수를양수로반전한값을 반환하고 부수효과는 없음.</code></pre>
증가++ 감소– 연산자는 피연산자의 값을 변경하는 부수효과가 있다는 것이 중요!!= 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적할당이 이루어짐.</li>
</ol>
<p>** 증가/감소(++/–)연산자는 위치에 의미가 있음!! 중요!!!</p>
<ul>
<li>피연산자 앞에 위치한 = 전위 증가/감소 연산자(prefix increment/ decrement operator)는 피연산자의 값은 먼저 증가/감소 시킨 후, 다른 연산을 수행.</li>
<li>피연산자 뒤에 위치한 = 후위 증가/감소 연산자(postfix increment/ decrement operator)는 다른 연산을 먼저 수행한 후 피연산자의 값을 증가/감소시킴.</li>
<li><ul>
<li>단항연산자는 피연산자에 어떠한 효과도 없음. 음수를 양수로 반전하지도 않음. 숫자타입이 아닌 피연산자에 +사용하면 숫자타입으로 변환한 값을 생성해서 반환함. 부수효과없음.</li>
</ul>
</li>
<li>-단항연산잔느 피연산자의 부호를 반전한 값을 반환함. +단항연산자와 마찬가지로 숫자타입이 아닌 피연산자에 사용하면 숫자타입으로 변환한 값을 생성하여 반환함. 피연산자를 변경한느것이 아닌 부호를 반전한 값을 생성해서 반환함. 부수효과 없음.<br>1-3. 문자열 연결 연산자<ul>
<li>연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작. 그 외의 경우는 산술연산자로 동작.</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>할당 연산자<br>assignment operator는 우항에 있는 피연산자의 평가결과를 좌항에 있는 변수에 할당. 할당연산자는 좌항의 변수에 값을 할당하므로 변수값이 변하는 부수효과가 있음.<br>종류: = -&gt; x = 5 , x = 5</p>
<pre><code> += -&gt; x += 5, x=x+5
  -= -&gt; x -= 5, x=x-5
  *= -&gt; x *= 5, x=x*5
  /= -&gt; x /= 5, x=x/5
  %= -&gt; x %= 5, x=x%5</code></pre>
<p>할당문은 표현식인 문일까 표현식이 아닌 문일까? = 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가됨. 할당문을 다른 변수에 할당하는 특징을 활용해 여러변수에 동일한 값을 연쇄할당할 수 있음<br>ex) var a, b, c;<br>   a = b = c = 0; //연쇄할당. 오른쪽에서 왼쪽으로 진행. c=0, b=0, a=0.<br>  console.log(a, b, c); // 0, 0, 0</p>
</li>
<li><p>비교 연산자<br>comparison operator는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환함. 비교 연산자는 if문이나 for문과 같은 제어문의 조건식에서 주로 사용함.<br>3-1. 동등/ 일치 비교 연산자<br>동등비교(loose equality)연산자와 일치비교(strict equality)연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는 지 비교해 불리언값을 반환함. 하지만 비교하는 엄격성의 정도가 다름! 동등비교는 느슨한비교, 일치비교는 엄격한비교. 부수효과 전부 없음.<br>종류 : == 동등비교, x == y, x와 y의 값이 같음.</p>
<pre><code>    === 일치비교, x === y, x와 y의 타입이 같음.
    != 부동등 비교, x != y, x와 y의 값이 다름.
    !== 불일치비교, x !== y, x와 y의 타입이 다름.</code></pre>
<p>동등비교(==)는 좌항과 우항의 피연산자를 비교할때 암묵적인 타입변환을 통해 타입일치시킨 후 같은 값인지 비교함.<br>ex) 0 == ‘ ‘; // true<br>   0 == ‘0’; // true<br>   ‘0’ == ‘ ‘; // false<br>동등비교연산자는 결과를 예측하기 어려우므로 일치비교(===)연산자를 사용한다.<br>ex) 5 === 5; // true<br>   5 === ‘5’; // false<br>일치비교(===)연산자에서 주의할 것은 NaN 이다!!!<br>NaN은 자신과 일치하지 않는 유일한 값임.<br>ex) NaN===NaN; // false<br>따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용.<br>ex) isNaN(NaN); // true</p>
<pre><code>isNaN(10); // false</code></pre>
<p>숫자 0도 주의!!!! 자바스에는 양의0과 음의0이 있는데 이들을 비교하면 true를 반환함.<br>ex) 0 === -0; // true</p>
<pre><code>0 == -0; // true</code></pre>
<dl><dt>(** Object.is 메서드</dt><dd>ES6에서 도입된 Object.is메서드는 예측 가능한 정확한 비교결과를 반환함. 그 외에는 일치비교(===)연산자와 동일하게 작동.<br>ex)  -0 === +0; // true</dd></dl><pre><code> Object.is(-0, +0); // false
 NaN === NaN; // false
 Object.is(NaN, NaN); // true</code></pre>
<p>)<br>부동등 비교연산자(!=)와 불일치 비교 연산자(!==)는 각각 동등비교(==)연산자와 일치비교(===)연산자의 반대개념임.<br>3-2. 대소 관계 비교 연산자<br>피연산자의 크기를 비교하여 불리언 값을 반환함. 부수효과 없음.<br>종류 : &gt; , x &gt; y, x가 y보다 크다.</p>
<pre><code>    &lt; , x &lt; y, x가 y보다 작다.
    &gt;= , x &gt;= y, x가 y보다 크거나 같다.
    &lt;= , x &lt;= y, x가 y보다 작거나 같다.</code></pre>
</li>
<li><p>삼항 조건 연산자<br>ternary operator는 조건식의 평가 결과에 따라 반환할 값을 결정함. 자바스의 유일한 삼항 연산자이며 부수효과 없음.<br>사용 예 : 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값<br>삼항조건연산자는 두번째 피연산자 또는 세번째 피연산자로 평가되는 표현식임.<br>물음표? 앞의 첫번째 피연산자는 조건식=불리언 타입의 값으로 평가될 표현식임. 조건식의 평가 결과가 불리언값이 아니어도 불리언값으로 암묵적타입변환됨. 이때 조건식이 참true이면 콜론:  앞의 두번째 피연산자가 평가되어 반환, 거짓false라면 콜론: 뒤의 세번째 피연산자가 평가되어 반환.<br>if~ else문을 사용해도 삼항조건 연산자 표현식과 유사하게 처리할 수 있음.<br>하지만 삼항조건연산자표현식은 값처럼 사용가능(=표현식인 문)하지만 if~else문은 값처럼 사용할 수 없음(=표현식이 아닌 문).</p>
</li>
<li><p>논리 연산자<br>logical operator는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다. 부수효과 없음.<br>종류 : || 논리합(OR)</p>
<pre><code>    &amp;&amp; 논리곱(AND)
    ! 부정(NOT) // 언제나 불리언 값을 반환함.</code></pre>
</li>
</ol>
<dl><dt>** 드 모르간의 법칙</dt><dd>논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 때가 있음. 이러한 경우 드 모르간 법칙을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환할 수 있음.<br>ex) !(x || y) === (!x &amp;&amp; !y)<br>      !(x &amp;&amp; y) === (!x || !y)</dd></dl><ol start="6">
<li><p>쉼표 연산자<br>, 쉼표 연산자는 왼쪽 피 연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가결과를 반환함.<br>ex)  var x, y, z;</p>
<pre><code>x = 1, y = 2, z = 3; // 3</code></pre>
</li>
<li><p>그룹 연산자<br>소괄호( ) 로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가함. 연산자의 우선순위 조절 가능. 연산자 우선순위가 가장 높음.<br>ex) 10 * 2 + 3; // 23<br>   10 * (2 + 3); // 50</p>
</li>
<li><p>typeof 연산자<br>데이터 타입을 문자열로 반환함. 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환함. “null”을 반환하는 경우 없음. 함수의 경우 “function”을 반환. = typeof연산자가 반환하는 문자열은 7개의 데이터 타입과 정확하게 일치하지 않음!!<br>typeof연산자로 null값을 연산해보면 “null”이 아닌”object”를 반환한다는 데 주의!!! 자바스의 첫번째 버전의 버그임. 기존코드에 영향을 줄 수 있기때문에 아직까지 수정되지못함.<br>= 따라서 값이 null 타입인지 확인할때는 typeof연산자말고 일치연산자(===)사용하자.<br>그리고 선언하지 않은 식별자를 typeof연산자로 연산해보면 ReferenceError가 발생하지않고 undefined를 반환함.</p>
</li>
<li><p>지수 연산자<br>ES7에서 도입된 지수연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자값을 반환함.<br>ex) 2 ** 2; //4<br>   2 ** 0; // 1<br>   2 ** -2; // 0.25<br>   2 ** 2.5; // 5.65685<br>지수연산자 도입전까진 Math.pow메서드를 사용했음. 지수연산자가 가독성이 더 좋음<br>음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 함.<br>ex) (-5) ** 2; // 25<br>다른 산술연산자와 마찬가지로 할당연산자와 함께 사용할 수 있음.<br>이항 연산자 중에서 우선순위가 가장 높음.</p>
</li>
<li><p>그 외의 연산자<br>종류 : ?.  옵셔널 체이닝 연산자</p>
<pre><code>   ??  null 병합 연산자
   delete 프로퍼티 삭제
   new 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
   instanceof 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
   in 프로퍼티 존재 확인</code></pre>
</li>
<li><p>연산자의 부수 효과<br>대부분의 연산자는 다른 코드에 영향을 주지 않음. 일부 연산자는 다른코드에 영향을 주는 부수효과(side effect)가 있음.<br>부수 효과가 있는 연산자는 할당(=), 증가(++), 감소(–), delete연산자 이다.</p>
</li>
<li><p>연산자 우선순위<br>우선순위가 높을수록 먼저 실행됨.</p>
</li>
<li><p>연산자 결합 순서<br>연산자의 어느쪽(좌항 또는 우항)부터 평가를 수행할 것인지를 나타내는 순서를 말함.<br>결합순서:<br>좌항-&gt;우항: + , - , / , % , &lt; , &lt;= , &gt; , &gt;= , &amp;&amp; , || , . , [] , () , ?? , ?. , in , instanceof<br>우항-&gt;좌항: ++ , – , 할당연산자, !x , +x , -x , ++x , –x , typeof , delete , ? … : …</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85-data-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85-data-type/" class="post-title-link" itemprop="url">데이터타입 data type</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 22:19:30 / Modified: 22:20:07" itemprop="dateCreated datePublished" datetime="2020-08-25T22:19:30+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>데이터타입(data type. 줄여서 ‘타입’이라고도 함)은 값의 종류를 말함. 자바스의 모든 값은 데이터 타입을 갖는다.<br>자바스는 원시타입6개, 객체타입1개. 총7개의 데이터타입을 제공함.</p>
<ul>
<li>원시타입(Primitive Type):<ul>
<li>숫자(number)타입: 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재</li>
<li>문자열(string)타입: 문자열</li>
<li>불리언(boolean)타입: 논리적 참(true)과 거짓(false)</li>
<li>undefined타입: var 키워드로 선언된 변수에 암묵적으로 할당되는 값</li>
<li>null타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값</li>
<li>심벌(symbol)타입: ES6에서 추가된 7번째 타입</li>
</ul>
</li>
<li>객체 타입(object/ reference type): 객체, 함수, 배열 등.<br>ex) 숫자타입 1 != 문자열타입 ‘1’. <pre><code>숫자타입의 값은 주로 산술연산을 위해 생성, 문자열타입의 값은 주로 텍스를 화면에 출력하기 위해 생성. 메모리공간 확보의 크기도 다름. 메모리에 저장되는 2진수도 다름. 읽어들이는 해석방식도 다름.</code></pre>
</li>
</ul>
<ol>
<li><p>숫자 타입<br>C언어나 자바의 경우, 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)를 구분해서 int, long, float, double등과 같은 다양한 숫자 타입 제공.<br>자바스의 경우, 독특하게 하나의 숫자타입만 존재.<br>ECMAScript 사양의 숫자타입의 값은 배정밀도 64비트 부동소수점형식을 따름. = 모든수를 실수로 처리, 정수만을 표현하기위한 데이터타입(integer type)별도 존재안함. = 정수로 표시된다해도 사실은 실수라는 것을 의미. = 정수끼리 나눠서 실수가 나올수 있는 이유임.<br>자바스는 2진수, 8진수 16진수를 표현하기위한 데이터타입을 제공하지 않기때문에 모두 10진수로 해석됨.<br>추가적으로 세가지 특별한 값들 표현 가능: </p>
<ul>
<li>Infinity : 양의 무한대</li>
<li>infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가(not-a-number)<br>자바스는 대소문자를 구별함= NaN을 nan Nan NAN등과 같이 표현하면 값이 아닌 식별자로 해석하기때문 에러발생. </li>
</ul>
</li>
<li><p>문자열 타입<br>String타입은 텍스트 데이터를 나타내는 데 사용. 문자열은 0개 이상의 16비트 유니코드 문자들의 집합으로 전 세계 대부분의 문자표현 가능.<br>문자열은 작은따옴표(‘’), 큰따옴표(“”), 백틱(``)으로 텍스트 감쌈. 자바스의 일반 표기법은 작은따옴표 사용.<br>따옴표로 감싸는 이유: 키워드나 식별자같은 토큰과 구분. 스페이스같은 공백 포함 가능.</p>
</li>
<li><p>템플릿 리터럴<br>멀티라인 문자열(multi-line string), 표현식 삽입(expression interpolation), 태그드 템플릿(tagged template) 등 편리한 문자열 처리 기능을 제공. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리됨.<br>백틱사용 표현이 일반적.<br>3-1. 멀티라인 문자열<br>일반문자열내에서는 줄바꿈 허용안됨. 백슬래시\로 시작하는 이스케이프 시퀀스 사용해야함.<br>3-2. 표현식 삽입<br>문자열은 문자열 연산자 +를 사용해 연결할 수 있음. + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작. 그 외의 경우는 덧셈 연산자로 동작.<br>표현식을 삽입하려면 ${ }으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입됨.<br>반드시! 템플릿 리터럴 내에서 사용해야 함. 템플릿 리터럴이 아닌 문자열에서의 표현식 삽입은 문자열로 취급됨.</p>
</li>
<li><p>불리언 타입<br>논리적 참, 거짓을 나타내는 true와 false뿐임.<br>조건문에서 자주 사용함.</p>
</li>
<li><p>undefined 타입<br>undefined 타입의 값은 undefined가 유일함.<br>var키워드로 선언한 변수는 암묵적으로 undefined로 초기화됨. = 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질때까지 빈상태(쓰레기값)로 내버려두지 않고 자바스엔진이 undefined로 초기화함. = 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환됨.<br>var foo;<br>console.log(foo); // undefined<br>개발자가 의도적으로 undefined를 변수에 할당하면 undefined의 본래 취지에 어긋나기때문에 권장안함. undefined을 할당하는 게 아닌 null 할당 사용.</p>
</li>
<li><p>null 타입<br>null 타입의 값은 null이 유일. 자바스는 대소문자 구별하므로 null은 Null,NULL등과 다름.<br>프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용. 변수에 null 할당=변수가 이전에 참조하던 값을 더이상 참조하지 않겠다, 명시적으로 제거하는 의미와 같음.= 자바스엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행함.</p>
</li>
<li><p>symbol 타입<br>ES6에서 추가된 7번째 타입. 변경불가능한 원시 타입의 값. 다른 값과 중복되지 않는 유일무이한 값. 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기위해 사용함.<br>symbol은 함수를 호출해 생성함. 이때 생성된 심벌값은 외부에 노출되지 않으며 다른 값과 절대 중복되지 않는 유일무이한 값임.</p>
</li>
<li><p>객체 타입<br>자바스의 데이터타입은 크게 원시타입과 객체타입으로 분류하는 이유는 근본적으로 다르기 때문이다. 자바스는 객체기반의 언어이며, 자바스를 이루고 있는 거의 모든 것이 객체이다.</p>
</li>
<li><p>데이터 타입의 필요성<br>9-1.데이터 타입에 의한 메모리 공간의 확보와 참조<br>ex) var score = 100;<br>ex의 코드가 실행되면 컴퓨터는 숫자값100을 저장위해 메모리공간확보한 후, 숫자값 100을 2진수로 저장. 이러한 처리를 하려면 숫자값을 저장할 때 확보되는 메모리공간의 크기를 알아야함.<br>값은 메모리에 저장하고 참조할 수 있어야함. 메모리에 값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 결정해야함. = 몇 바이트의 메모리 공간을 사용해야 낭비와 손실없이 값을 저장할 수 있는지 알아야 함.<br>자바스엔진은 데이터타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 변수에 할당되는 값의 데이터 타입에 따라 확보해야할 메모리공간의 크기가 결정됨.<br>값을 참조하는 경우! 식별자 score를 통해 숫자값100이 저장되어있는 메모리 공간의 선두 메모리셀의 주소를 찾아갈 수 있음. 이때 값을 참조하려면 한번에 읽어들여야할 메모리셀의개수-바이트수=메모리공간을 알아야함. 자바스엔진은 score변수에 숫자타입의 값이 할당되어 있어서 score변수를 숫자타입으로 인식. 숫자타입은 8바이트 단위로 저장되므로 score변수를 참조하면 8바이트 단위로 메모리 공간에 저장된 값을 읽어들임.<br>9-2.데이터 타입에 의한 값의 해석<br>메모리에서 읽어들인 2진수를 어떻게 해석하냐는 문제가 남아있음.!!<br>모든 값은 데이터 타입을 가지며 메모리에 2진수, 즉 비트 but의 나열로 저장됨. 메모리에 저장된 값은 데이터타입에 따라 다르게 해석될 수 있음.<br>ex) 01000001 -&gt;숫자로해석하면 65 / 문자열로 해석하면 A.<br>데이터타입은 값의 종류를 말함. 자바스의 모든 값은 데이터타입을 갖음. 데이터타입이 필요한 이유:</p>
<ul>
<li>값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어들여야 할 메모리공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li>
</ul>
</li>
<li><p>동적 타이핑<br>10-1. 동적 타입 언어와 정적  타입 언어<br>변수는 데이터타입을 가질까?<br>C나 자바같은 정적타입(static/strong type)언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류 = 데이터 타입을 사전에 선언해야 함. 이를 명시적타입선언(explicit type declaration)이라 함.</p>
<ul>
<li>정적 타입언어:  변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있음. , 컴파일 시점에 타입체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행함. 만약 타입체클르 통과하지 못했다면 에러를 발생시키고 프로그램의 실행자체를 막음. 이를 통해 타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임. , 대표적인 정적타입언어로 C, C++, 자바(Java), 코틀린(Kotlin), 고(Go), 하스켈(Haskell), 러스트(Rust), 스칼라(Scala)등이 있음.<br>자바스는 정적타입언어와 다르게 변수를 선언할 때 타입을 선언하지 않음.<br>다만, var, let, const키워드를 사용해서 변수를 선언할 뿐. 자바스의 변수는 정적타입언어처럼 미리 선언한 타입의 값만 할당할 수 있는것이 아님. 어떠한 데이터 타입의 값이라도 자유롭게 할당 가능.<br>typeof연산자로 변수를 연산하면 변수의 데이터 타입을 반환함= 변수의 데이터 타입을 반환하는것이 아니라 변수에 할당된 값의 데이터 타입을 반환한 것이 더 정확한 표현.<br>자바스의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입추론, type inference)됨. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음. 이러한 특징을 동적타이핑(dynamic typing)이라 하며, 자바스를 정적타입언어와 구별하기위해 동적타입(dynamic/weak type)언어라 함. 대표적인 동적타입언어로 자바스크립트, 파이썬(Python), PHP, 루비(Ruby), 리스프(Lisp), 펄(Perl)등이 있음.<br>처음질문의 답으로 기본적으로 변수는 타입을 갖지않음. 하지만 값은 타입을 갖음. 따라서 현재변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는것이 더 적절함. 변수는 값에 묶여 있는 값에 대한 별명이기 때문.<br>10-2.동적  타입 언어와 변수<br>변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있음. 이러한 동적타입언어의 특징은 데이터타입에 대해 무감각해질정도로 편리하다는 것. 하지만 위험도 있다.<br>모든 소프트웨어 아키텍처는 트레이드오프(trade-off: 두 개의 정책 목표가운데 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적관계를 의미)가 존재하며, 모든 애플리케이션에 적합한 은 탄환(Silver bullet:  고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책)은 없듯이 동적타입언어 또한 구조적인 단점이 있음.<br>변수값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수값을 추적하기 어려울 수 있음. 타입도 언제든지 변경될 수 있음. 따라서 동적타입언어의 변수는 값을 확인하기 전에는 타입을 확실할 수 없음!</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/24/%ED%91%9C%ED%98%84%EC%8B%9Dexpressin%EA%B3%BC-%EB%AC%B8statement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/%ED%91%9C%ED%98%84%EC%8B%9Dexpressin%EA%B3%BC-%EB%AC%B8statement/" class="post-title-link" itemprop="url">표현식expressin과 문statement</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 17:45:29 / Modified: 17:45:46" itemprop="dateCreated datePublished" datetime="2020-08-24T17:45:29+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>값</li>
</ol>
<p>-값(Value)은 식(표현식, Expression 수학의 식과 거의 유사. ex)10+20 )이 평가(Evaluate)되어 생성된 결과(30= 10+20의 결과30)를 말함.<br>-평가(Evaluate)란 식(표현식, Expression)을 해석해서 값을 생성하거나 참조하는 것을 의미. = 값을 도출하는 과정을 평가라고 한다.<br>ex) 10+20;//30 일때 10+20 은 평가되어 숫자 값 30을 생성함.<br>변수에 할당되는 것은 평가된 결과의 값이다.<br>ex) var sum = 10+20; 일때 변수sum에는10+20이 평가되어 생성된 숫자 30이 할당됨. 10+20은 할당 이전에 평가 되어 값을 생성해야 한다.<br>-모든 값은 데이터 타입을 갖으며 메모리에 2진수 = bit비트의 나열로 저장된다. 메모리에 저장된 값은 데이터타입에 따라 다르게 해석될 수 있다.<br>ex)0100 0001<br>    -&gt; 숫자로 해석 = 65<br>    -&gt; 문자열로 해석 = A<br>2. 리터럴<br>리터럴(Literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해서 값을 생성하는 표기 방식(Notation)을 말함.<br>3도 단순한 아라비아 숫자3이 아닌 숫자 리터럴 3이다. 자바스크립트엔진은 숫자리터럴 3을 평가해서 숫자 값 3을 생성한다.<br>이처럼 리터럴은 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등)나 또는 미리 약속된 기호(‘.’”,”.,[]{}//등)로 표기한 코드다.<br>자바스크립트 엔진은 코드가 실행되는 시점인 런타임(Runtime)에 리터럴을 평가해서 값을 생성한다.=리터럴을 작성하면 코드가 실행될 시점에서 상응하는 값을 생성한다.<br>즉, 리터럴은 값을 생성하기 위해 미리 약속된 표기법이라 할 수 있음.<br>리터럴을 사용하면 다양한 종류의 Data Type의 값을 생성할 수 있다. -&gt; 정수,부동소수점(실수), 2진수(0b로 시작),8진수(0o로 시작), 16진수(0x로 시작), 문자열, 불리언, null, undefined, 객체{}, 배열[], 함수Function() , 정규표현식 리터럴<br>3. 표현식—– 이해 더 필요!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 유툽강의 다시보기.<br>표현식(Expression)은 값으로 평가될 수 있는 문(Statement)이다. 즉 , 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. = 리터럴도 표현식이다. 리터럴은 그 자체로 표현식이다. 값으로 평가되는 문은 모두 표현식이다.<br>4. 문<br>문(Statement)과 표현식(Expression)용어 구분 필수! 확실히 이해!<br>문:  프로그램을 구성하는 기본 단위이자 최소 실행 단위임. 문의 집합이 프로그램. 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍!<br>-여러 토큰으로 구성된 것이 문이다. 토큰(Token)이란 문법적인 의미를 가지고, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미함.<br>ex) var sum = 1+2; 에서 각 키워드var, 식별자sum, 연산자=, 리터럴1, 연산자+, 리터럴2, 세미콜론; 이나 마침표. 가 토큰이다.<br>-문을 명령문이라고도 한다. 문=컴퓨터에 내리는 명령=문 실행= -&gt;명령실행-&gt;무슨일이 일어남.<br>-선언문, 표현식 문(할당문), 함수 선언문, 조건문, 반복문<br>5. 세미콜론(;)과 세미콜론 자동 삽입 기능<br>세미콜론(;): 문 의 종료를 나타냄.  = 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행함. 단 0개 이상의 문을 중괄호로 묵은 코드블록 ({ … })뒤에는 세미콜론을 붙이지 않는다. if문, for문, 함수등의 코드블록뒤에는 세미콜론을 붙이지 않는다. 코드블록은 언제나 문 의 종료를 의미하는 자체종결성(Self Closing)을 갖기 떄문이다.<br>문 의 끝에 붙이는 세미콜론은 옵션이라 생략이 가능하다. 자바스크립트 엔진은 자동으로 세미콜론 자동삽인기능(ASI)이 수행되기 때문이다. 하지만 ASI 동작과 개발자의 예측이 일치하지않는 경우가 간혹 있기때문에 세미콜론 사용을 기본으로 설정하는 습관을 들이자.<br>6. 표현식인 문과 표현식이 아닌 문<br>표현식은 문 의 일부일 수도 있고 그 자체로 문이 될수도 있다.!!!!!!!!!!!!!<br>구별하는 방법!: 변수에 할당해보자. 변수에 할당 할 수 있으면 표현식인 문이다.</p>
<ul>
<li>변수 선언문 =/= 표현식<br>ex) var x; //변수 선언문이다. =&gt; var foo = var x;// 는 SyntaxError,</li>
<li>할당문 === 표현식<br>ex) x=100; // 할당문이다. =&gt; var foo = x = 100; //을 console.log(foo);를 찍으면 100이 나온다.</li>
<li>완료 값(Completion Value): 크롬개발자도구에서 표현식이아닌 문 실행하면 언제나 undefined를 출력/ 표현식인 문을 실행하면 언제나 평가된 값을 반환.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JinSol</p>
  <div class="site-description" itemprop="description">All Dev stories found in here</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JinSol</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
