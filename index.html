<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"do-mandoo.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="All Dev stories found in here">
<meta property="og:type" content="website">
<meta property="og:title" content="JINLOG">
<meta property="og:url" content="https://do-mandoo.github.io/index.html">
<meta property="og:site_name" content="JINLOG">
<meta property="og:description" content="All Dev stories found in here">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JinSol">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://do-mandoo.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>JINLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JINLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Awesome</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/27/%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/%EA%B0%9D%EC%B2%B4%EB%A6%AC%ED%84%B0%EB%9F%B4object/" class="post-title-link" itemprop="url">객체리터럴object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:43:52 / Modified: 17:44:04" itemprop="dateCreated datePublished" datetime="2020-08-27T17:43:52+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>객체란?<br>Object. 자바스는 객체기반의 프로그래밍 언어이며, 자바스를 구성하는 거의 “모든 것”이 객체. 원시값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체임.<br>원시 타입은 단 하나의 값만을 나타내지만 객체타입(object/ reference type)은 다양한 타입의 값(원시값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조(data structure)임. 또한 원시타입의 값 = 원시값은 변경불가능한 값(immutable value)이지만, 객체타입의값=객체는 변경가능한 값(mutable value)임.<br>객체는 0개 이상의 프로퍼티로 구성된 집합, 프로퍼티는 키(key)와 값(value)으로 구성됨.<br>ex) var person = {</p>
<pre><code> name : &#39;Lee&#39;,
 age : 20</code></pre>
<p>   }; // name과 age는 프로퍼티 키, Lee와 20은 프로퍼티 값. 이 둘을 어우르는것이 프로퍼티.<br>자바스에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있음. 자바스의 함수는 일급객체이므로 값으로 취급할 수 있음. 따라서 함수도 프로퍼티 값으로 사용 할 수 있음. 프로퍼티 값이 함수일경우 일반함수와 구분하기 위해 메서드(method)라고 부른다.<br>ex) var counter = {</p>
<pre><code>  num : 0,                   //프로퍼티
  increase : function() &#123;   //메서드영역 시작
    this.num++;
  &#125;                                        //메서드영역 끝</code></pre>
<p>   };<br>이처럼 객체는 프로퍼티와 메서드로 구성된 집하체임.<br>프로퍼티와 메서드의 역할 : </p>
<ul>
<li>프로퍼티: 객체의 상태를 나타내는 값(data)</li>
<li>메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)<br>이처럼 객체는 상태와 동작을 하나의 단위로 구조화할 수 있어 유용함.<br>** 객체와 함수<br>: 자바스의 객체는 함수와 밀접한 관계를 가짐. 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 함. 자바스에서 함수와 객체는 분리해서 생각할 수 없는 개념=객체를 이해해야 함수를 제대로 이해, 함수를 이해해야 객체를 정확히 이해 가능.</li>
</ul>
</li>
<li><p>객체 리터럴에 의한 객체 생성</p>
</li>
</ol>
<ul>
<li>C++이나 자바와 같은 클래스기반 객체지향언어는 클래스를 사전에 정의하고 필요한 시점에 new연산자와 함께 생성자(constructor)를 호출하여 인스턴스(instance: 클래스에 의해 생성되어 메모리에 저장된 실체를 말함. 객체지향프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념임. 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 함. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성함.</li>
<li>자바스는 프로토타입 객체지향언어로 클래스기반 객체지향언어와는달리 다양한 객체 생성 방법을 지원함. -&gt; 객체 리터럴, Object생성자 함수, 생성자함수, Object.create메서드, 클래스(ES6)<br>이러한 객체 생성 방법중에서 가장일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법임. 리터럴literal은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법을 말함. 객체리터럴은 객체를 생성하기 위한 표기법임.!!!!</li>
<li>객체 리터럴은 중괄호({…})내에 0개 이상의 프로퍼티를 정의함. 변수에 할당이 이루어지는 시점에 자바스엔진은 객체리터럴을 해석해서 객체를 생성함.<br>만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성됨.<br>객체 리터럴의 중괄호는 코드블록을 의미하지 않음!!! 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않음. 하지만 객체 리터럴은 값으로 평가되는 표현식임. = 객체리터럴의 닫는 중괄호 뒤에는 세미콜론 붙임.</li>
<li>객체리터럴은 자바스의 유연함과 강력함을 대표하는 객체 생성 방식임. 객체를 생성하기 위해 클래스를 먼저 정의하고 new연산자와 함께 생성자를 호출할 필요가 없음. 숫자값이나 문자열을 만드는것과 유사하게 리터럴로 객체를 생성함. 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있음.</li>
<li>객체리터럴 외의 객체생성방식은 모두 함수를 사용해 객체를 생성함</li>
</ul>
<ol start="3">
<li>프로퍼티</li>
</ol>
<ul>
<li>객체는 프로퍼티property들의 집합이며 프로퍼티는 키key와 값value로 구성됨.</li>
<li>프로퍼티 나열할때는 쉼표( , )로 구분. 일반적으로 마지막프로퍼티뒤에는 쉼표사용안하지만 사용해도 됨.</li>
<li>프로퍼티 키와 프로퍼티 값으로 사용할수 있는 값:<br>  -프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값<br>  -프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값</li>
<li>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로서 식별자역할을 함. 하지만 반드시 식별자네이밍규칙을 따라야하는것은 아님. 단! 미묘한차이는 있음.</li>
<li>심벌값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용함. 이때 프로퍼티 키는 문자열이므로 따옴표( ‘ ‘ 또는 “ “ )로 묶어야 함. 하지만 식별자네이밍규칙을 준수하는 이름(=자바스에서 사용가능한 유요한 이름)인경우 따옴표 생략 가능.= 식별자네이밍규칙 따르지 않는 이름에는 반드시 따옴표 사용!</li>
<li>가급적 식별자네이밍규칙을 준수하는 프로퍼티 키를 사용할것을 권장!!</li>
<li>문자열 또는 문자열로 평가할수있는 표현식을 사용해 프로퍼티키를 동적으로 생성할수 있음. 사용할 프로퍼티키를 대괄호( […] )로 묶어서 사용.</li>
<li>빈 문자열을 프로퍼티키로 사용해도 에러는나지않지만 키로서 의미를갖지 못하니까 권장하지 않음.</li>
<li>프로퍼티 키에 문자열이나 심벌값 이외의 값을 사용하면 암묵적타입변환을 통해 문자열이 됨. ex)프로퍼티키로 숫자리터럴사용하면 따옴표는 붙지않지만 내부적으로는 문자열로 변환됨.</li>
<li>var, function과 같은 예약어를 프로퍼티 키로 사용해도 에러발생안함.하지만 예상치 못한 에러발생의 여지가 있으니 권장안함.</li>
<li>이미 존재하는 프로퍼티키를 중복선언하면 나중에 선언한프로퍼티로 덮어씀. 에러가 발생하지않으니 주의!!</li>
</ul>
<ol start="4">
<li><p>메서드<br>자바스에서 사용할 수 있는 모든 값은 프로퍼티값으로 사용할수 있다고 했다. 자바스의 함수는 객체다. 따라서 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있음.<br>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드method라 부름.= 메서드는 객체에 묶여있는 함수를 의미.<br>메서드 내부에서 사용한 this키워드는 객체자신을 가리키는 참조변수임.일단간단하게 이렇게 알고있기.</p>
</li>
<li><p>프로퍼티 접근</p>
</li>
</ol>
<ul>
<li>접근방법 두가지<br>  1- 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법(dot notation)<br>  2- 대괄호 프로퍼티 접근 연산자([…])를 사용하는 대괄호 표기법(bracket notation)</li>
<li>프로퍼티키가 식별자네이밍규칙을 준수하는 이름(=자바스에서 사용가능한 이름)이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있음.</li>
<li>마침표 프로퍼티 접근 연산자 또는 대괄호 프로퍼티 접근 연산자의 좌측에는 객체로 평가되는 표현식을 기술함. 마침표 프로퍼티 접근 연산자의 우측 또는 대괄호 프로퍼티 접근 연산자의 내부에는 프로퍼티 키를 지정함.</li>
<li>대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 함. 그렇지않으면 자바스엔진은 식별자로 해석하기 때문. ex) [‘name’] (O) . <a href="X">name</a></li>
<li>객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환함. 이때 ReferenceError가 발생하지 않게 주의!!!</li>
<li>프로퍼티키가 식별자네이밍규칙을 준수하지않는 이름(=자바스에서 사용가능하지 않는 이름)은 반드시 대괄호 표기법을 사용해야함. 단! 프로퍼티키가 숫자로 이루어진 문자열인경우 따옴표 생략가능. 그 외의 경우는 반드시 대괄호 내에 따옴표로 감싼 문자열이어야만 함!!</li>
<li>ex) person.last-name; // 1.브라우저환경: NaN , 2.Node.js환경:ReferenceError  //person[‘last-name’]; 이 맞는 표기.<br>브라우저 환경과 Node.js 환경에서의 실행결과가 다른 이유는  person.last-name을 실행할때 ①자바스엔진은 person.last를 평가②name식별자로 해석됨. Node.js환경은 name식별자 선언이 없으므로, 브라우저환경은 name이라는 전역변수가 암묵적을 존재. 간단하게는 이렇게 다르다. 자세한 것은 교안(나중에 잘 정리해서 추가하기)확인.</li>
</ul>
<ol start="6">
<li><p>프로퍼티 값 갱신<br>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됨.<br>ex) var person = { name: ‘Lee’ };</p>
<pre><code> person.name = &#39;Kim&#39;; //person 객체에 name프로퍼티가 존재하므로 name프로퍼티 값이 갱신됨.
 console.log(person); // &#123;name: &quot;Kim&quot;&#125;</code></pre>
</li>
<li><p>프로퍼티 동적 생성<br>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당됨.<br>ex) var person = { name: ‘Lee’};</p>
<pre><code> person.age=20; // person객체에 age프로퍼티 존재안함. 선언때 프로퍼티가 동적으로 생성되고 값이 할당됨.
 console.log(person);// &#123;name: &quot;Lee&quot;, age: 20&#125;</code></pre>
</li>
<li><p>프로퍼티 삭제<br>delete연산자는 객체의 프로퍼티를 삭제함. 이때 delete연산자의 피연산자는 프로퍼티값에 접근할 수 있는 표현식이어야 함. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시됨.!<br>ex) var person = { name: ‘Lee’};</p>
<pre><code>  person.age=20; // 프로퍼티 동적 생성
  delete person.age; // person 객체에 age프로퍼티 존재하므로 삭제가능.
  delete person.address; // person객체에 address프로퍼티 존재안함으로 에러 발생하지 않음.
  console.log(person); // &#123;name: &quot;Lee&quot;&#125;</code></pre>
</li>
<li><p>ES6에서 추가된 객체 리터럴의 확장 기능<br>ES6에서는 더욱 간편하고 표현력있는 객체 리터럴의 확장기능을 제공함.<br>9-1.프로퍼티 축약 표현<br>객체리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성됨. 프로퍼티 값은 변수에 할당된 값= 식별자 표현식일 수도 있음.<br>ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수이름과 프로퍼티 키가 동일한 이름일때, 프로퍼티키를 생략(property shorthand)할 수 있음. 이때 프로퍼티 키는 변수 이름으로 자동 생성됨.<br>9-2.계산된 프로퍼티 이름<br>문자열 또는 문자열로 타입변환할 수있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도있음. 단, 프로퍼티키로 사용할 표현식을 대괄호([…])로 묶어야 함. 이를 계산된 프로퍼티 이름(computed property name)이라 함.<br>ES6에서는 객체리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생산할 수 있음.<br>9-3.메서드 축약 표현<br>ES6에서 : 메서드 정의할 때, function키워드를 생략한 축약표현 사용가능, </p>
<pre><code>                 ex)ES5에서: sayHi: function()&#123;&#125;/  ES6에서:sayHi()&#123;&#125;
           메서드 축약표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작!</code></pre>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/27/%EC%9B%90%EC%8B%9C%EA%B0%92primitive-%EA%B3%BC-%EA%B0%9D%EC%B2%B4object-reference-%EC%9D%98-%EB%B9%84%EA%B5%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/%EC%9B%90%EC%8B%9C%EA%B0%92primitive-%EA%B3%BC-%EA%B0%9D%EC%B2%B4object-reference-%EC%9D%98-%EB%B9%84%EA%B5%90/" class="post-title-link" itemprop="url">원시값primitive 과 객체object/reference 의 비교</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:42:38 / Modified: 17:43:04" itemprop="dateCreated datePublished" datetime="2020-08-27T17:42:38+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ㅠ(“6.데이터타입”) 참고<br>자바스가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체타입)은 크게 원시타입(primitive type)과 객체(object/ reference type)타입으로 구분.<br>구분하는 이유는? : 근본적으로 다른다는 의미. 세가지 측면에서 다름</p>
<ul>
<li>원시타입의 값(= 원시값)은 변경 불가능한 값(immutable value)임.,<br>객체(참조)타입의 값(=객체)는 변경 가능한 값(mutable value)임.</li>
<li>원시값을 변수에 할당하면 변수(확보된 메모리공간)에는 실제 값이 저장됨. ,<br>객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조값이 저장됨.</li>
<li>원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달됨. 이를 값에 의한 전달(pass by value)라 함.<br> 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨. 이를 참조에 의한 전달(pass by reference)라 함.</li>
</ul>
<ol>
<li>원시값<br>1-1.변경 불가능한 값<br>primitive type=immutable type </li>
</ol>
<ul>
<li><p>한 번 생성된 원시값은 읽기전용(read only)값이라 변경할 수 없음.</p>
</li>
<li><p>값을 변경할 수 없다 : 변수와 값을 구분해서 생각하자. </p>
<pre><code>                                   - 변수: 하나의 값을 저장하기 위해 확보한 메모리공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름,
                                   - 값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과.
                                     따라서  변경 불가능하다는 것은 변수가 아니라 값에 대한 진술임.  = 즉, &quot;원시값은 변경 불가능하다&quot;는 말은 원시값 자체를 변경할 수 없다는 것이지 변수값을 변경할 수 없다는것이 아님!! 변수는 언제든지 재할당을 통해 변수값을 변경(엄밀히 말하자면 교체)할 수 있기때문에 변수라고 부름.</code></pre>
</li>
<li><p>변수의 상대개념인  상수는 재할당이 금지된 변수를 말함. 상수도 값을 저장하기 위한 메모리공간이 필요하므로 변수라고 할 수 있음. 단, 변수는 언제든지 재할당을 통해 변수값을 변경(교체)할 수 있지만 상수는 단 한번만 할당이 허용되므로 변수값을 변경(교체)할 수 없음. =&gt; 상수와 변경불가능한값을 동일시하면 안됨. 상수는 재할당이 금지된 변수일 뿐임!!</p>
</li>
<li><p>원시값은 변경불가능한 값= 읽기 전용 값. = 불변 = 데이터의 신뢰성 보장.</p>
</li>
<li><p>재할당하면 메모리공간 덮어쓰기가 아닌 새로운 메모리공간을 확보하고 저장. 주소가 바뀌는 것. 이러한 특성을 불변성immutability라 함.<br>1-2.문자열과 불변성</p>
</li>
<li><p>데이터 타입에 의한 메모리 공간의 확보가 필요. 단 ECMAScript사양에 문자열타입(2byte)과 숫자타입(8byte)이외의 원시타입은 크기를 명확히규정하고있지않음=브라우저 제조사의 구현에따라 다름.</p>
</li>
<li><p>원시값인 문자열만의 독특한 특징: 문자열은 0개 이상의 문자(character)로 이뤄진 집합을 말하며, 1개의 문자는 2바이트의 메모리공간에 저장됨.=문자열은 몇개의 문자로 이뤄졌느냐에 따라 필요한 메모리공간의 크기가 결정됨. 숫자값은 1도, 1,000,000도 동일한 8byte가 필요하지만 문자열의 경우(단순계산때) 1개의 문자열은 2byte, 10개로 이뤄진 문자열은 20byte필요.</p>
</li>
<li><p>이런 이유들로 C에서는 하나의 문자를 위한 데이터타입(char)만 있을 뿐 문자열 타입은 존재하지 않음. C에서는 문자열을 문자들의 배열로 처리하고 자바에서는 문자열을 String객체로 처리함.</p>
</li>
<li><p>하지만!  -&gt;자바스의 장점: 개발자의 편의를 위해 원시타입인 문자열타입을 제공!! 자바스의 문자열은 원시타입,변경불가능.=문자열이 생성된 이후에는 변경할수없음을 의미</p>
<pre><code> ex) var str = &#39;hello&#39;;
        str = &#39;world&#39;;</code></pre>
<p>  일때, 첫번째문을 실행해서 hello가 저장된 메모리 공간의 첫번째 메모리셀 주소를 가리킨다. 두번째문 실행하면 world메모리생성하고 식별자str은 이것을 가리킴. hello를 수정해서 world를 덮어씌우는게 아니다. hello와world는 모두 메모리에 존재함. 식별자 str이 문자열 hello를 가리키고 있다가 문자열world를 가리키도록 변경되었을 뿐!!!!!!</p>
</li>
<li><p>문자열은 유사배열객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있음.<br>  ** 유사배열객체array-like object란, </p>
<pre><code>   : 마치 배열처럼 인덱스로 프로퍼티 값에 접근할수있고 length프로퍼티를 갖는 객체를 말함. 
      문자열은 마치 배열처럼 인데스를 통해 각 문자에 접근할 수 있고, length프로퍼티를 갖기 때문에 유사배열객체이고 for문으로 순회할수도있음.</code></pre>
<p>1-3.값에 의한 전달</p>
</li>
<li><p>ex) var score = 80;</p>
<pre><code>  var copy = score;

  console.log(score); // 80
  console.log(copy); // 80</code></pre>
<p>일때, 변수에 변수를 할당했을때 어떻게 전달되는가가 핵심이다.<br>copy=score에서 변수값80으로 평가되므로 copy변수에도 80이 할당(새로운 숫자값 80이 생성되어 copy변수에 할당됨)</p>
</li>
<li><blockquote>
<p>변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달됨 = 값에 의한 전달(Pass by value)라 함.<br>score변수와 copy변수의 값 80은 다른 메모리공간에 저장된 별개의 값임!!</p>
</blockquote>
<p>ex) 위 ex에 연결.</p>
<pre><code>   score = 100;

   console.log(score); // 100
   console.log(copy); // ??? (정답: 80)</code></pre>
<p>에서 score변수와 copy변수의 값 80은 다른 메모리공간에 저장된 별개의 값이라 했음. 따라서 score변수의 값을 100으로 재할당 해도 copy변수의 값에는 어떠한 영향도 주지 않음!!</p>
</li>
<li><p>ECMAScript사양에는 “값에 의한 전달”이라는 용어등장하지 않음.<br>“값에 의한 전달”과 “참조에 의한 전달” “공유에의한전달”이라고 표현.</p>
</li>
<li><p>정확히는 “값에 의한 전달”은 값을 전달하는 것이 아닌 메모리 주소를 전달하는것임. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음.</p>
</li>
<li><p>두변수의 원시값은 서로 다른 메모리공간에 저장된 별개의 값이되어 어느한쪽에서 재할당을 통해 값을 변경해도 서로 간섭할수 없음!!!</p>
</li>
</ul>
<ol start="2">
<li>객체</li>
</ol>
<ul>
<li>프로퍼티 개수가 정해져 있지 않으며, 동적으로 추가됙고 삭제할 수 있음. 또한 프로퍼티의 값에도 제약이 없음. = 객체는 원시값과 같이 확보해야할 메모리공간의 크기를 사전에 정해둘 수 없음.</li>
<li>객체는 복합적인 자료구조이므로 객체 관리 방식이 원시값과 비교해서 복잡함. 원시값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에따라 크기가 매우클수도 있음. 객체 생성하고 프로퍼티에 접근하는것도 원시값과 비교할때 비용이 많이 드는 일임. = 객체는 원시값과는 다른 방식으로 동작하게 설계되어있음.<br>2-1.변경가능한 값</li>
<li>객체(참조)타입의 값= 객체는 변경 가능한 값(mutable value)임.</li>
<li>원시값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리공간에 접근하면 원시값에 접근할수있음. = 원시값을 할당한 변수는 원시값자체를 값으로 갖음. !하지만! 객체를 할당한 변수가 기억하는 메모리주소를 통해 메모리공간에 접근하면 참조값(reference value)에 접근할 수 있음. 참조값은 생성된 객체가 저장된 메모리공간의주소, 그 자체임.</li>
<li>ex) var person = { name: ‘Lee’};<pre><code>  console.log(person); //&#123;name: &quot;Lee&quot;&#125; // person변수는 객체 &#123;name: &#39;Lee&#39;;&#125;를 가리키고point(참조하고)있음.
   (이어서)
   person.name = &#39;Kim&#39;; //  프로퍼티 값 갱신
   person.address = &#39;Seoul&#39;; // 프로퍼티 동적 생성
   console.log(person); //&#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125; // person변수는 객체 &#123;name: &#39;Lee;&#125;를 가리키고point(참조하고)있음. ,, // 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조값은 변경되지 않음.</code></pre>
</li>
<li>원시값은 변경 불가능한 값이므로 원시값을 갖는 변수의 값을 변경하려면 재할당을 통해 메모리에 원시값을 새롭게 생성해야함. 하지만 객체는 변경가능한 값으므로 메모리에 저장된 객체를 직접 수정할 수 있음. = 재할당없이 프로퍼티를 동적으로 추가할수도 있고 프로퍼티값을 갱신할수도 있으며 프로퍼티자체를 삭제할수도 있음. </li>
<li>메모리를 효율적으로 사용하기위해, 객체를 복사해 생성하는 비용을 절약해서 성능을 향상시키기위해 객체는 변경 가능한 값으로 설계되어있음. 메모리 사용의 효율성과 성능을 위해 어느정도의 구조적인 단점을 감안한 설계</li>
<li>구조적단점에 따른 부작용: 원시값과는 다르게 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것.<br> **얕은 복사(shallow copy)와 깊은 복사(deep copy)<pre><code>  :얕은복사 - 객체를 프로퍼티 값으로 갖는객체의 경우 한단계까지만 복사.
    깊은 복사 - 객체에 중첩되어있는 객체까지 모두 복사.</code></pre>
2-2.참조에 의한 전달<br>여러개의 식별자가 하나의 객체를 공유할 수 있다는것을 공부하자.</li>
<li>ex) var person = { name: ‘Lee’};<pre><code>   var copy = person // 참조값을 복사 (얕은복사)</code></pre>
객체를 가리키는 변수(원본,person)를 다른변수(사본,copy)에 할당하면 원본의 참조값이 복사되어 전달됨= 참조에의한전달pass by reference<br>원본person과 사본copy는 저장된 메모리 주소는 다르지만 동일한 참조값을 갖음= 모두 동일한 객체를 가리킴.=두개의 식별자가 하나의 객체를 공유함을 의미.= 원본이나 사본중 어느한쪽에서 객체를 변경(재할당이아닌 객체의 프로퍼티값을 변경하거나 프로퍼티추가,삭제)하면 서로 영향을 주고 받음.</li>
<li>ex) var person = { name=’Lee’};<pre><code>   var copy = person; // =&gt;참조값을 얕은 복사함. copy와person은 동일한 참조값 갖음.
   console.log(copy===person); //true =&gt;copy와 person은 동일한 객체를 참조함.
   copy.name = &#39;Kim&#39;; // =&gt;copy를 통해 객체를 변경
   person.address = &#39;Seoul&#39;; // =&gt;person을 통해 동적생성
   console.log(person); // &#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125;
   console.log(copy); // &#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125;
                                        =&gt;copy와person은 동일한객체가리킴.
                                            서로 영향 주고 받음.</code></pre>
</li>
<li>결국 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어있는 값을 복사해서 전달한다는 면에서 동일.<br>다만 식별자가 기억하는 공간=변수에 저장되어있는 값이 원시값이냐 참조값이냐 하는 차이만 있음.</li>
<li>자바스에는 “참조에 의한 전달”은 존재하지않고 “값에 의한 전달”만이 존재한다고 말할수있음.</li>
<li>따라서 교안에서는 전달되는 값의 종류가 원시값인지 참조값인지 구별해서 강조하는 의미에서 “값에의한전달”과 “참조에의한전달”로 구분해서 부르기로함.</li>
</ul>
<p><strong><em>퀴즈!!</em></strong><br>var person1 = {name=’Lee’};<br>var person2 = {name=’Lee’};<br>console.log(person1 === person2} //  false =&gt;객체의 변수이름이 다름(?)<br>console.log(person1.name === person2.name} //  true =&gt; 객체의 참조값이 같음.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/25/%EC%97%B0%EC%82%B0%EC%9E%90operator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%EC%97%B0%EC%82%B0%EC%9E%90operator/" class="post-title-link" itemprop="url">연산자operator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 22:20:35 / Modified: 22:20:48" itemprop="dateCreated datePublished" datetime="2020-08-25T22:20:35+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation)등을 수행해 하나의 값을 만듦. 이때 연산의 대상의 피연산자(operand)라 함. 피연산자는 값으로 평가될 수 있는 표현식이어야 함.</p>
<ul>
<li>피연산자가 “값”이라는 명사의 역할을 한다면,<br>연산자는 “피연산자를 연산하여 새로운 값을 만든다”라는 동사의 역할을 한다고 볼 수 있음.<br>= 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 함. 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만듦.</li>
</ul>
<ol>
<li>산술연산자<br>arithmetic operator<br>피연산자를 대상으로 수학적 계산을 수행해 새로운 값을 만듦. 산술 연산이 불가능할 경우 NaN을 반환함. 산술연산자는 피연산자의 개수에 따라 이항산술연산자와 단항산술연산자로 구분할 수 있음.<br>1-1. 이항(binary) 산술 연산자<br>binary산술 연산자는 2개의 피연산자를 산술연산해서 숫자값을 만듦.<br>모든 이행 산술연산자는 피연산자의 값을 변경하는 부수효과(side effect)가 없음. = 어떤 산술을 해도 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운값을 만들뿐!<br>종류: +덧셈 -뺼셈 *곱셈 /나누기 %나머지<br>1-2. 단항(unary) 산술 연산자<br>unary산술 연산자는 1개의 피연산자를 산술연산하여 숫자값을 만듦.<br>종류: ++증가(부수효과있음)<pre><code>    --감소(부수효과있음) 
   +어떠한효과없고 음수양수반전도 안하고 부수효과도 없음.
    -양수를음수로음수를양수로반전한값을 반환하고 부수효과는 없음.</code></pre>
증가++ 감소– 연산자는 피연산자의 값을 변경하는 부수효과가 있다는 것이 중요!!= 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적할당이 이루어짐.</li>
</ol>
<p>** 증가/감소(++/–)연산자는 위치에 의미가 있음!! 중요!!!</p>
<ul>
<li>피연산자 앞에 위치한 = 전위 증가/감소 연산자(prefix increment/ decrement operator)는 피연산자의 값은 먼저 증가/감소 시킨 후, 다른 연산을 수행.</li>
<li>피연산자 뒤에 위치한 = 후위 증가/감소 연산자(postfix increment/ decrement operator)는 다른 연산을 먼저 수행한 후 피연산자의 값을 증가/감소시킴.</li>
<li><ul>
<li>단항연산자는 피연산자에 어떠한 효과도 없음. 음수를 양수로 반전하지도 않음. 숫자타입이 아닌 피연산자에 +사용하면 숫자타입으로 변환한 값을 생성해서 반환함. 부수효과없음.</li>
</ul>
</li>
<li>-단항연산잔느 피연산자의 부호를 반전한 값을 반환함. +단항연산자와 마찬가지로 숫자타입이 아닌 피연산자에 사용하면 숫자타입으로 변환한 값을 생성하여 반환함. 피연산자를 변경한느것이 아닌 부호를 반전한 값을 생성해서 반환함. 부수효과 없음.<br>1-3. 문자열 연결 연산자<ul>
<li>연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작. 그 외의 경우는 산술연산자로 동작.</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>할당 연산자<br>assignment operator는 우항에 있는 피연산자의 평가결과를 좌항에 있는 변수에 할당. 할당연산자는 좌항의 변수에 값을 할당하므로 변수값이 변하는 부수효과가 있음.<br>종류: = -&gt; x = 5 , x = 5</p>
<pre><code> += -&gt; x += 5, x=x+5
  -= -&gt; x -= 5, x=x-5
  *= -&gt; x *= 5, x=x*5
  /= -&gt; x /= 5, x=x/5
  %= -&gt; x %= 5, x=x%5</code></pre>
<p>할당문은 표현식인 문일까 표현식이 아닌 문일까? = 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가됨. 할당문을 다른 변수에 할당하는 특징을 활용해 여러변수에 동일한 값을 연쇄할당할 수 있음<br>ex) var a, b, c;<br>   a = b = c = 0; //연쇄할당. 오른쪽에서 왼쪽으로 진행. c=0, b=0, a=0.<br>  console.log(a, b, c); // 0, 0, 0</p>
</li>
<li><p>비교 연산자<br>comparison operator는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환함. 비교 연산자는 if문이나 for문과 같은 제어문의 조건식에서 주로 사용함.<br>3-1. 동등/ 일치 비교 연산자<br>동등비교(loose equality)연산자와 일치비교(strict equality)연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는 지 비교해 불리언값을 반환함. 하지만 비교하는 엄격성의 정도가 다름! 동등비교는 느슨한비교, 일치비교는 엄격한비교. 부수효과 전부 없음.<br>종류 : == 동등비교, x == y, x와 y의 값이 같음.</p>
<pre><code>    === 일치비교, x === y, x와 y의 타입이 같음.
    != 부동등 비교, x != y, x와 y의 값이 다름.
    !== 불일치비교, x !== y, x와 y의 타입이 다름.</code></pre>
<p>동등비교(==)는 좌항과 우항의 피연산자를 비교할때 암묵적인 타입변환을 통해 타입일치시킨 후 같은 값인지 비교함.<br>ex) 0 == ‘ ‘; // true<br>   0 == ‘0’; // true<br>   ‘0’ == ‘ ‘; // false<br>동등비교연산자는 결과를 예측하기 어려우므로 일치비교(===)연산자를 사용한다.<br>ex) 5 === 5; // true<br>   5 === ‘5’; // false<br>일치비교(===)연산자에서 주의할 것은 NaN 이다!!!<br>NaN은 자신과 일치하지 않는 유일한 값임.<br>ex) NaN===NaN; // false<br>따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용.<br>ex) isNaN(NaN); // true</p>
<pre><code>isNaN(10); // false</code></pre>
<p>숫자 0도 주의!!!! 자바스에는 양의0과 음의0이 있는데 이들을 비교하면 true를 반환함.<br>ex) 0 === -0; // true</p>
<pre><code>0 == -0; // true</code></pre>
<dl><dt>(** Object.is 메서드</dt><dd>ES6에서 도입된 Object.is메서드는 예측 가능한 정확한 비교결과를 반환함. 그 외에는 일치비교(===)연산자와 동일하게 작동.<br>ex)  -0 === +0; // true</dd></dl><pre><code> Object.is(-0, +0); // false
 NaN === NaN; // false
 Object.is(NaN, NaN); // true</code></pre>
<p>)<br>부동등 비교연산자(!=)와 불일치 비교 연산자(!==)는 각각 동등비교(==)연산자와 일치비교(===)연산자의 반대개념임.<br>3-2. 대소 관계 비교 연산자<br>피연산자의 크기를 비교하여 불리언 값을 반환함. 부수효과 없음.<br>종류 : &gt; , x &gt; y, x가 y보다 크다.</p>
<pre><code>    &lt; , x &lt; y, x가 y보다 작다.
    &gt;= , x &gt;= y, x가 y보다 크거나 같다.
    &lt;= , x &lt;= y, x가 y보다 작거나 같다.</code></pre>
</li>
<li><p>삼항 조건 연산자<br>ternary operator는 조건식의 평가 결과에 따라 반환할 값을 결정함. 자바스의 유일한 삼항 연산자이며 부수효과 없음.<br>사용 예 : 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값<br>삼항조건연산자는 두번째 피연산자 또는 세번째 피연산자로 평가되는 표현식임.<br>물음표? 앞의 첫번째 피연산자는 조건식=불리언 타입의 값으로 평가될 표현식임. 조건식의 평가 결과가 불리언값이 아니어도 불리언값으로 암묵적타입변환됨. 이때 조건식이 참true이면 콜론:  앞의 두번째 피연산자가 평가되어 반환, 거짓false라면 콜론: 뒤의 세번째 피연산자가 평가되어 반환.<br>if~ else문을 사용해도 삼항조건 연산자 표현식과 유사하게 처리할 수 있음.<br>하지만 삼항조건연산자표현식은 값처럼 사용가능(=표현식인 문)하지만 if~else문은 값처럼 사용할 수 없음(=표현식이 아닌 문).</p>
</li>
<li><p>논리 연산자<br>logical operator는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다. 부수효과 없음.<br>종류 : || 논리합(OR)</p>
<pre><code>    &amp;&amp; 논리곱(AND)
    ! 부정(NOT) // 언제나 불리언 값을 반환함.</code></pre>
</li>
</ol>
<dl><dt>** 드 모르간의 법칙</dt><dd>논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않아 한눈에 이해하기 어려울 때가 있음. 이러한 경우 드 모르간 법칙을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환할 수 있음.<br>ex) !(x || y) === (!x &amp;&amp; !y)<br>      !(x &amp;&amp; y) === (!x || !y)</dd></dl><ol start="6">
<li><p>쉼표 연산자<br>, 쉼표 연산자는 왼쪽 피 연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가결과를 반환함.<br>ex)  var x, y, z;</p>
<pre><code>x = 1, y = 2, z = 3; // 3</code></pre>
</li>
<li><p>그룹 연산자<br>소괄호( ) 로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가함. 연산자의 우선순위 조절 가능. 연산자 우선순위가 가장 높음.<br>ex) 10 * 2 + 3; // 23<br>   10 * (2 + 3); // 50</p>
</li>
<li><p>typeof 연산자<br>데이터 타입을 문자열로 반환함. 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환함. “null”을 반환하는 경우 없음. 함수의 경우 “function”을 반환. = typeof연산자가 반환하는 문자열은 7개의 데이터 타입과 정확하게 일치하지 않음!!<br>typeof연산자로 null값을 연산해보면 “null”이 아닌”object”를 반환한다는 데 주의!!! 자바스의 첫번째 버전의 버그임. 기존코드에 영향을 줄 수 있기때문에 아직까지 수정되지못함.<br>= 따라서 값이 null 타입인지 확인할때는 typeof연산자말고 일치연산자(===)사용하자.<br>그리고 선언하지 않은 식별자를 typeof연산자로 연산해보면 ReferenceError가 발생하지않고 undefined를 반환함.</p>
</li>
<li><p>지수 연산자<br>ES7에서 도입된 지수연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자값을 반환함.<br>ex) 2 ** 2; //4<br>   2 ** 0; // 1<br>   2 ** -2; // 0.25<br>   2 ** 2.5; // 5.65685<br>지수연산자 도입전까진 Math.pow메서드를 사용했음. 지수연산자가 가독성이 더 좋음<br>음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 함.<br>ex) (-5) ** 2; // 25<br>다른 산술연산자와 마찬가지로 할당연산자와 함께 사용할 수 있음.<br>이항 연산자 중에서 우선순위가 가장 높음.</p>
</li>
<li><p>그 외의 연산자<br>종류 : ?.  옵셔널 체이닝 연산자</p>
<pre><code>   ??  null 병합 연산자
   delete 프로퍼티 삭제
   new 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
   instanceof 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
   in 프로퍼티 존재 확인</code></pre>
</li>
<li><p>연산자의 부수 효과<br>대부분의 연산자는 다른 코드에 영향을 주지 않음. 일부 연산자는 다른코드에 영향을 주는 부수효과(side effect)가 있음.<br>부수 효과가 있는 연산자는 할당(=), 증가(++), 감소(–), delete연산자 이다.</p>
</li>
<li><p>연산자 우선순위<br>우선순위가 높을수록 먼저 실행됨.</p>
</li>
<li><p>연산자 결합 순서<br>연산자의 어느쪽(좌항 또는 우항)부터 평가를 수행할 것인지를 나타내는 순서를 말함.<br>결합순서:<br>좌항-&gt;우항: + , - , / , % , &lt; , &lt;= , &gt; , &gt;= , &amp;&amp; , || , . , [] , () , ?? , ?. , in , instanceof<br>우항-&gt;좌항: ++ , – , 할당연산자, !x , +x , -x , ++x , –x , typeof , delete , ? … : …</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85-data-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85-data-type/" class="post-title-link" itemprop="url">데이터타입 data type</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 22:19:30 / Modified: 22:20:07" itemprop="dateCreated datePublished" datetime="2020-08-25T22:19:30+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>데이터타입(data type. 줄여서 ‘타입’이라고도 함)은 값의 종류를 말함. 자바스의 모든 값은 데이터 타입을 갖는다.<br>자바스는 원시타입6개, 객체타입1개. 총7개의 데이터타입을 제공함.</p>
<ul>
<li>원시타입(Primitive Type):<ul>
<li>숫자(number)타입: 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재</li>
<li>문자열(string)타입: 문자열</li>
<li>불리언(boolean)타입: 논리적 참(true)과 거짓(false)</li>
<li>undefined타입: var 키워드로 선언된 변수에 암묵적으로 할당되는 값</li>
<li>null타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값</li>
<li>심벌(symbol)타입: ES6에서 추가된 7번째 타입</li>
</ul>
</li>
<li>객체 타입(object/ reference type): 객체, 함수, 배열 등.<br>ex) 숫자타입 1 != 문자열타입 ‘1’. <pre><code>숫자타입의 값은 주로 산술연산을 위해 생성, 문자열타입의 값은 주로 텍스를 화면에 출력하기 위해 생성. 메모리공간 확보의 크기도 다름. 메모리에 저장되는 2진수도 다름. 읽어들이는 해석방식도 다름.</code></pre>
</li>
</ul>
<ol>
<li><p>숫자 타입<br>C언어나 자바의 경우, 정수(소수점 이하가 없는 숫자)와 실수(소수점 이하가 있는 숫자)를 구분해서 int, long, float, double등과 같은 다양한 숫자 타입 제공.<br>자바스의 경우, 독특하게 하나의 숫자타입만 존재.<br>ECMAScript 사양의 숫자타입의 값은 배정밀도 64비트 부동소수점형식을 따름. = 모든수를 실수로 처리, 정수만을 표현하기위한 데이터타입(integer type)별도 존재안함. = 정수로 표시된다해도 사실은 실수라는 것을 의미. = 정수끼리 나눠서 실수가 나올수 있는 이유임.<br>자바스는 2진수, 8진수 16진수를 표현하기위한 데이터타입을 제공하지 않기때문에 모두 10진수로 해석됨.<br>추가적으로 세가지 특별한 값들 표현 가능: </p>
<ul>
<li>Infinity : 양의 무한대</li>
<li>infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가(not-a-number)<br>자바스는 대소문자를 구별함= NaN을 nan Nan NAN등과 같이 표현하면 값이 아닌 식별자로 해석하기때문 에러발생. </li>
</ul>
</li>
<li><p>문자열 타입<br>String타입은 텍스트 데이터를 나타내는 데 사용. 문자열은 0개 이상의 16비트 유니코드 문자들의 집합으로 전 세계 대부분의 문자표현 가능.<br>문자열은 작은따옴표(‘’), 큰따옴표(“”), 백틱(``)으로 텍스트 감쌈. 자바스의 일반 표기법은 작은따옴표 사용.<br>따옴표로 감싸는 이유: 키워드나 식별자같은 토큰과 구분. 스페이스같은 공백 포함 가능.</p>
</li>
<li><p>템플릿 리터럴<br>멀티라인 문자열(multi-line string), 표현식 삽입(expression interpolation), 태그드 템플릿(tagged template) 등 편리한 문자열 처리 기능을 제공. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리됨.<br>백틱사용 표현이 일반적.<br>3-1. 멀티라인 문자열<br>일반문자열내에서는 줄바꿈 허용안됨. 백슬래시\로 시작하는 이스케이프 시퀀스 사용해야함.<br>3-2. 표현식 삽입<br>문자열은 문자열 연산자 +를 사용해 연결할 수 있음. + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작. 그 외의 경우는 덧셈 연산자로 동작.<br>표현식을 삽입하려면 ${ }으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입됨.<br>반드시! 템플릿 리터럴 내에서 사용해야 함. 템플릿 리터럴이 아닌 문자열에서의 표현식 삽입은 문자열로 취급됨.</p>
</li>
<li><p>불리언 타입<br>논리적 참, 거짓을 나타내는 true와 false뿐임.<br>조건문에서 자주 사용함.</p>
</li>
<li><p>undefined 타입<br>undefined 타입의 값은 undefined가 유일함.<br>var키워드로 선언한 변수는 암묵적으로 undefined로 초기화됨. = 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질때까지 빈상태(쓰레기값)로 내버려두지 않고 자바스엔진이 undefined로 초기화함. = 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환됨.<br>var foo;<br>console.log(foo); // undefined<br>개발자가 의도적으로 undefined를 변수에 할당하면 undefined의 본래 취지에 어긋나기때문에 권장안함. undefined을 할당하는 게 아닌 null 할당 사용.</p>
</li>
<li><p>null 타입<br>null 타입의 값은 null이 유일. 자바스는 대소문자 구별하므로 null은 Null,NULL등과 다름.<br>프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용. 변수에 null 할당=변수가 이전에 참조하던 값을 더이상 참조하지 않겠다, 명시적으로 제거하는 의미와 같음.= 자바스엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행함.</p>
</li>
<li><p>symbol 타입<br>ES6에서 추가된 7번째 타입. 변경불가능한 원시 타입의 값. 다른 값과 중복되지 않는 유일무이한 값. 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기위해 사용함.<br>symbol은 함수를 호출해 생성함. 이때 생성된 심벌값은 외부에 노출되지 않으며 다른 값과 절대 중복되지 않는 유일무이한 값임.</p>
</li>
<li><p>객체 타입<br>자바스의 데이터타입은 크게 원시타입과 객체타입으로 분류하는 이유는 근본적으로 다르기 때문이다. 자바스는 객체기반의 언어이며, 자바스를 이루고 있는 거의 모든 것이 객체이다.</p>
</li>
<li><p>데이터 타입의 필요성<br>9-1.데이터 타입에 의한 메모리 공간의 확보와 참조<br>ex) var score = 100;<br>ex의 코드가 실행되면 컴퓨터는 숫자값100을 저장위해 메모리공간확보한 후, 숫자값 100을 2진수로 저장. 이러한 처리를 하려면 숫자값을 저장할 때 확보되는 메모리공간의 크기를 알아야함.<br>값은 메모리에 저장하고 참조할 수 있어야함. 메모리에 값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 결정해야함. = 몇 바이트의 메모리 공간을 사용해야 낭비와 손실없이 값을 저장할 수 있는지 알아야 함.<br>자바스엔진은 데이터타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 변수에 할당되는 값의 데이터 타입에 따라 확보해야할 메모리공간의 크기가 결정됨.<br>값을 참조하는 경우! 식별자 score를 통해 숫자값100이 저장되어있는 메모리 공간의 선두 메모리셀의 주소를 찾아갈 수 있음. 이때 값을 참조하려면 한번에 읽어들여야할 메모리셀의개수-바이트수=메모리공간을 알아야함. 자바스엔진은 score변수에 숫자타입의 값이 할당되어 있어서 score변수를 숫자타입으로 인식. 숫자타입은 8바이트 단위로 저장되므로 score변수를 참조하면 8바이트 단위로 메모리 공간에 저장된 값을 읽어들임.<br>9-2.데이터 타입에 의한 값의 해석<br>메모리에서 읽어들인 2진수를 어떻게 해석하냐는 문제가 남아있음.!!<br>모든 값은 데이터 타입을 가지며 메모리에 2진수, 즉 비트 but의 나열로 저장됨. 메모리에 저장된 값은 데이터타입에 따라 다르게 해석될 수 있음.<br>ex) 01000001 -&gt;숫자로해석하면 65 / 문자열로 해석하면 A.<br>데이터타입은 값의 종류를 말함. 자바스의 모든 값은 데이터타입을 갖음. 데이터타입이 필요한 이유:</p>
<ul>
<li>값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어들여야 할 메모리공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li>
</ul>
</li>
<li><p>동적 타이핑<br>10-1. 동적 타입 언어와 정적  타입 언어<br>변수는 데이터타입을 가질까?<br>C나 자바같은 정적타입(static/strong type)언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류 = 데이터 타입을 사전에 선언해야 함. 이를 명시적타입선언(explicit type declaration)이라 함.</p>
<ul>
<li>정적 타입언어:  변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있음. , 컴파일 시점에 타입체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행함. 만약 타입체클르 통과하지 못했다면 에러를 발생시키고 프로그램의 실행자체를 막음. 이를 통해 타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임. , 대표적인 정적타입언어로 C, C++, 자바(Java), 코틀린(Kotlin), 고(Go), 하스켈(Haskell), 러스트(Rust), 스칼라(Scala)등이 있음.<br>자바스는 정적타입언어와 다르게 변수를 선언할 때 타입을 선언하지 않음.<br>다만, var, let, const키워드를 사용해서 변수를 선언할 뿐. 자바스의 변수는 정적타입언어처럼 미리 선언한 타입의 값만 할당할 수 있는것이 아님. 어떠한 데이터 타입의 값이라도 자유롭게 할당 가능.<br>typeof연산자로 변수를 연산하면 변수의 데이터 타입을 반환함= 변수의 데이터 타입을 반환하는것이 아니라 변수에 할당된 값의 데이터 타입을 반환한 것이 더 정확한 표현.<br>자바스의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입추론, type inference)됨. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음. 이러한 특징을 동적타이핑(dynamic typing)이라 하며, 자바스를 정적타입언어와 구별하기위해 동적타입(dynamic/weak type)언어라 함. 대표적인 동적타입언어로 자바스크립트, 파이썬(Python), PHP, 루비(Ruby), 리스프(Lisp), 펄(Perl)등이 있음.<br>처음질문의 답으로 기본적으로 변수는 타입을 갖지않음. 하지만 값은 타입을 갖음. 따라서 현재변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는것이 더 적절함. 변수는 값에 묶여 있는 값에 대한 별명이기 때문.<br>10-2.동적  타입 언어와 변수<br>변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있음. 이러한 동적타입언어의 특징은 데이터타입에 대해 무감각해질정도로 편리하다는 것. 하지만 위험도 있다.<br>모든 소프트웨어 아키텍처는 트레이드오프(trade-off: 두 개의 정책 목표가운데 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적관계를 의미)가 존재하며, 모든 애플리케이션에 적합한 은 탄환(Silver bullet:  고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책)은 없듯이 동적타입언어 또한 구조적인 단점이 있음.<br>변수값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수값을 추적하기 어려울 수 있음. 타입도 언제든지 변경될 수 있음. 따라서 동적타입언어의 변수는 값을 확인하기 전에는 타입을 확실할 수 없음!</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/24/%ED%91%9C%ED%98%84%EC%8B%9Dexpressin%EA%B3%BC-%EB%AC%B8statement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/%ED%91%9C%ED%98%84%EC%8B%9Dexpressin%EA%B3%BC-%EB%AC%B8statement/" class="post-title-link" itemprop="url">표현식expressin과 문statement</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 17:45:29 / Modified: 17:45:46" itemprop="dateCreated datePublished" datetime="2020-08-24T17:45:29+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>값</li>
</ol>
<p>-값(Value)은 식(표현식, Expression 수학의 식과 거의 유사. ex)10+20 )이 평가(Evaluate)되어 생성된 결과(30= 10+20의 결과30)를 말함.<br>-평가(Evaluate)란 식(표현식, Expression)을 해석해서 값을 생성하거나 참조하는 것을 의미. = 값을 도출하는 과정을 평가라고 한다.<br>ex) 10+20;//30 일때 10+20 은 평가되어 숫자 값 30을 생성함.<br>변수에 할당되는 것은 평가된 결과의 값이다.<br>ex) var sum = 10+20; 일때 변수sum에는10+20이 평가되어 생성된 숫자 30이 할당됨. 10+20은 할당 이전에 평가 되어 값을 생성해야 한다.<br>-모든 값은 데이터 타입을 갖으며 메모리에 2진수 = bit비트의 나열로 저장된다. 메모리에 저장된 값은 데이터타입에 따라 다르게 해석될 수 있다.<br>ex)0100 0001<br>    -&gt; 숫자로 해석 = 65<br>    -&gt; 문자열로 해석 = A<br>2. 리터럴<br>리터럴(Literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해서 값을 생성하는 표기 방식(Notation)을 말함.<br>3도 단순한 아라비아 숫자3이 아닌 숫자 리터럴 3이다. 자바스크립트엔진은 숫자리터럴 3을 평가해서 숫자 값 3을 생성한다.<br>이처럼 리터럴은 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등)나 또는 미리 약속된 기호(‘.’”,”.,[]{}//등)로 표기한 코드다.<br>자바스크립트 엔진은 코드가 실행되는 시점인 런타임(Runtime)에 리터럴을 평가해서 값을 생성한다.=리터럴을 작성하면 코드가 실행될 시점에서 상응하는 값을 생성한다.<br>즉, 리터럴은 값을 생성하기 위해 미리 약속된 표기법이라 할 수 있음.<br>리터럴을 사용하면 다양한 종류의 Data Type의 값을 생성할 수 있다. -&gt; 정수,부동소수점(실수), 2진수(0b로 시작),8진수(0o로 시작), 16진수(0x로 시작), 문자열, 불리언, null, undefined, 객체{}, 배열[], 함수Function() , 정규표현식 리터럴<br>3. 표현식—– 이해 더 필요!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 유툽강의 다시보기.<br>표현식(Expression)은 값으로 평가될 수 있는 문(Statement)이다. 즉 , 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. = 리터럴도 표현식이다. 리터럴은 그 자체로 표현식이다. 값으로 평가되는 문은 모두 표현식이다.<br>4. 문<br>문(Statement)과 표현식(Expression)용어 구분 필수! 확실히 이해!<br>문:  프로그램을 구성하는 기본 단위이자 최소 실행 단위임. 문의 집합이 프로그램. 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍!<br>-여러 토큰으로 구성된 것이 문이다. 토큰(Token)이란 문법적인 의미를 가지고, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미함.<br>ex) var sum = 1+2; 에서 각 키워드var, 식별자sum, 연산자=, 리터럴1, 연산자+, 리터럴2, 세미콜론; 이나 마침표. 가 토큰이다.<br>-문을 명령문이라고도 한다. 문=컴퓨터에 내리는 명령=문 실행= -&gt;명령실행-&gt;무슨일이 일어남.<br>-선언문, 표현식 문(할당문), 함수 선언문, 조건문, 반복문<br>5. 세미콜론(;)과 세미콜론 자동 삽입 기능<br>세미콜론(;): 문 의 종료를 나타냄.  = 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행함. 단 0개 이상의 문을 중괄호로 묵은 코드블록 ({ … })뒤에는 세미콜론을 붙이지 않는다. if문, for문, 함수등의 코드블록뒤에는 세미콜론을 붙이지 않는다. 코드블록은 언제나 문 의 종료를 의미하는 자체종결성(Self Closing)을 갖기 떄문이다.<br>문 의 끝에 붙이는 세미콜론은 옵션이라 생략이 가능하다. 자바스크립트 엔진은 자동으로 세미콜론 자동삽인기능(ASI)이 수행되기 때문이다. 하지만 ASI 동작과 개발자의 예측이 일치하지않는 경우가 간혹 있기때문에 세미콜론 사용을 기본으로 설정하는 습관을 들이자.<br>6. 표현식인 문과 표현식이 아닌 문<br>표현식은 문 의 일부일 수도 있고 그 자체로 문이 될수도 있다.!!!!!!!!!!!!!<br>구별하는 방법!: 변수에 할당해보자. 변수에 할당 할 수 있으면 표현식인 문이다.</p>
<ul>
<li>변수 선언문 =/= 표현식<br>ex) var x; //변수 선언문이다. =&gt; var foo = var x;// 는 SyntaxError,</li>
<li>할당문 === 표현식<br>ex) x=100; // 할당문이다. =&gt; var foo = x = 100; //을 console.log(foo);를 찍으면 100이 나온다.</li>
<li>완료 값(Completion Value): 크롬개발자도구에서 표현식이아닌 문 실행하면 언제나 undefined를 출력/ 표현식인 문을 실행하면 언제나 평가된 값을 반환.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/24/%EB%B3%80%EC%88%98variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/%EB%B3%80%EC%88%98variable/" class="post-title-link" itemprop="url">변수variable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 17:42:50 / Modified: 17:45:55" itemprop="dateCreated datePublished" datetime="2020-08-24T17:42:50+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>변수란 무엇인가? 왜 필요한가?<br>변수란 데이터를 관리하기 위한 핵심 개념이다.<br>자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.=메모리 주소를 통해 값에 직접 접근하려는 시도는 올바른 방법이 아니다.<br>변수는 하나의 값을 저장하기 위해 확보된 메모리 공간 자체 또는 그 메모리공간을 식별하기 위해 붙인 이름을 말한다.(상수도 변수이지만 일반적인 변수와 다른 성격을 갖고있다. 상수는 재할당이 안된다.)<br>변수는 하나의 값을 저장하기 위한 매커니즘. 여러개의 값을 지정하려면 여러개의 변수 사용. 하지만 배열이나 객체같은 자료구조를 사용하면 관련이 있는 여러개의 값을 그룹화해서 하나의 값처럼 사용할 수 있다.<br>ex) var coffee= [americano, latte, mocha, hazelnut]; // 하나의 변수에 여러개의 값 저장.<br>변수이름은 가독성을 높이는 부수적인 효과도 있기 때문에 변수의 이름은 첫아이의 이름을 짓듯이 심사숙고해서 지어야한다(曰강사님)</li>
<li>식별자 + 8. 식별자 네이밍 규칙과 같이 보자.<br>변수 이름=식별자=어떤값을 구별해서 식별할 수 있는 고유한 이름.like사람이름.<br>값은 메모리 공간에 저장되어 있기때문에 저장되어있는 어떤 값을 구별해서  식별해내야한다. 따라서 식별자는 이를위해 어떤값이 저장되어있는 메모리 주소를 기억(저장)해야한다.<br>식별자는 값이 아니라 메모리 주소를 기억하고 있다는것이 핵심이다.= 식별자는 메모리 주소에 붙인 이름.</li>
<li>변수 선언<br>변수를 생성하는 것을 변수 선언이라 함.= 값을 저장하기 위한 메모리 공간을 확보하고 변수이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것.<br>변수를 사용하려면 반드시 선언이 필요. 변수 선언 키워드 -&gt; var, let, const<br>(리바인딩과 변형mutation을 헷갈려서는 안됨. 리바인딩은 참조하는 식별자에 대한 변화이고 변형은 참조되는 값의 변화이다.<br>var키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 ‘선언단계’와 ‘초기화단계’가 한번에 진행됨., 재할당 가능<br>let은 분리되어 진행됨=런타임이전에 선언단계 실행되고 변수 선언문에 도달했을 때 초기화단계 실행. , 재할당 가능<br>const는 반드시 선언과 동시에 초기화해야한다.,  재할당 금지</li>
<li>변수 선언의 실행 시점과 변수 호이스팅<br>변수 선언의 실행: 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문에 선언문보다 변수를 참조하는 코드가 앞에 있다해서 참조에러ReferenceError를 발생시키지 않는다. 런타임단계를 실행하기 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드 실행을 위한 준비를 함.<br>변수 호이스팅: 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행함. = 변수선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있음.=변수선언(선언단계와 초기화단계)이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행된다는 증거. === 변수 선언문이 코드의 선두로 끌어 올려진것처럼 동작하는 자바스크립 고유의 특징을 변수 호이스팅 이라 함.</li>
<li>값의 할당<br>할당=대입=저장 할 때는 할당 연산자 “=”를 사용. 우변의 값을 좌변의 변수에 할당.<br>변수에 값을 할당할때는 이전값=초기된 값이 저장되어있던 메모리를 덮어쓰는것이 아님. 새로운 메모리공간을 확보하고 그 곳에 할당 된 값을 저장한다는 것이 중요.<br>초기화된 값은 더이상 불러올 수 없음. 왜냐하면 초기화된 값의 변수이름이 할당된 변수의 이름으로 이동했기 때문에 초기화된 값의 변수이름이 없어서 부를 수가 없음. 사용할 수 없음.</li>
<li>값의 재할당<br>이미 값이 할당되어 있는 변수에 새로운값을 또다시 할당하는 것.<br>var키워드로 선언한 변수는 값을 재할당하는게 가능. let도 가능 const는 불가능.<br>만약 값을 재할당 할 수 없어 한번 정해지면 변하지 않는 값은 상수라고 한다. const키워드도 상수를 표현할 수 있지만 반드시 상수만의 위해 사용하는것은 아니다.<br>초기값에 값을 할당하는것도 재할당이라고 할 수 있다.<br>재할당역시 새로운 메모리공간을 확보하고 재할당한 값을 저장한다.</li>
<li>값의 교환<br>두 변수의 값을 교환하는 코드를 작성하라<br>var x=1;<br>var y=2;<br>//TODO<br>var x=2;<br>var y=1; //2 1 재할당.<br> or<br>var x=y;<br>var y=1;// 2 1 y값 재할당.<br> or<br>var c = x;<br>var x = y;<br>var y = c;// 2 1 교환재할당.<br>console.log(x,y); // 2 1</li>
<li>식별자 네이밍 규칙 +  2. 식별자와 같이 보자.<br>식별자는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름을 말하기때문에 식별자는 네이밍 규칙을 준수해야함.</li>
</ol>
<p>-식별자는 특수문자를 제외한 문자, 숫자, 언더스코어<em>, 달러기호$를 호함할 수 있다.<br>단, 특수문자를 제외한 문자, 언더스코어</em>, 달러기호$로 시작해야함. 숫자로 시작하는건 허용하지 않음.<br>-예약어는 식별자로 사용할 수 없음.(예약어는 프로그래밍 언어에서 사용되고 있거나 사용 예정인 단어를 말함.)<br>-네이밍 컨벤션 4가지 유형<br>1.카멜 케이스 : firstName - 변수나 함수이름에 사용.<br>2.스네이크 케이스 : first_name<br>3.파스칼 케이스:FirstName - 생성자 함수, 클래스 이름에 사용.<br>4.헝가리언케이스: strFirstName//type+identifier , $elem=document.getElenentById(‘myId)//JQuery에서 DOM노드 요소를 나타냄, observable=fromEvent(document, ‘click’)//RxJS옵저버블</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/18/My-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/My-JavaScript/" class="post-title-link" itemprop="url">My JavaScript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-18 18:34:56" itemprop="dateCreated datePublished" datetime="2020-08-18T18:34:56+09:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-19 23:54:29" itemprop="dateModified" datetime="2020-08-19T23:54:29+09:00">2020-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hi there!!! It’s me again. LOL. welcome to my JIN BLOG :-)</p>
<p>매년 나오는 버전업그레이드. 특징들을 적극적으로 받아들여야한다. 높은 수준의 함수이지만 배워야한다.</p>
<p>웹페이지와 웹애플리케이션의 차이,구분은 애매하다. 만약 회사홈페이지를 만들었다면 그 상태도 웹페이지이고 로그인해야 게시판에 글을 쓰는것도 웹페이지라고 한다. 웹애플리케이션은 그 것을 가지고 일,업무를 하기위한 그런 느낌이다. 예를들면  vscode나 slack같은 프로그램들을 웹애플리케이션이라고 한다.</p>
<p>SPA에서 single page라는것은 html이 하나만있다는 뜻.</p>
<p>자바스크립트와 에크마스크립트<br>ECMAScript는 스펙상 용어이다. 노드랑 브라우저에서 동작 가능.<br>자바스크립트 alert(‘foo’);실행시키는 것을 nodejs에서 실행시키면 모른다고 나온다. 참조에러가 뜸. = 함수는 브라우저에서는 되고 노드에서는 안되는것이 있다. alert은 경고창이지만 브라우저에서 작동하는것이라 node는 브라우저가 없으니 실행이 안됨.<br>DOM!!!! 또한 브라우저가 있어야만 실행가능하기 때문에 node에서 동작안됨.</p>
<p>인터프리터! 중요. 컴파일러(like번역)와 인터프리터(like통역) 구분.<br>소스코드는 순수한 text파일을 말한다.<br>컴파일러의 단점은 컴파일을 해야한다는것이 단점이다.<br>컴파일중 수정사항이 생기면 다시 파일을 줘야한다.<br>프로그래머에게 편한건 인터프리터언어이지만,<br>실행속도가 빠른것은 컴파일러언어이다.<br>따라서 일부 컴파일을 쓴다. 인터프리터 언어다! 실행파일을 안만들기때문에 인터프리터 언어라고 말한다!</p>
<h2 id="변수에서의-값의-할당"><a href="#변수에서의-값의-할당" class="headerlink" title="변수에서의 값의 할당"></a>변수에서의 값의 할당</h2><p>변수는 초기값으로 쓰레기 값을 가지고 있다. 사용자(?)가 새로운 값을 할당해주면 쓰레기값의 메모리를 덮어씌우는 것이 아닌 새로운 메모리공간에 할당된 값을 저장한다는 개념이 중요하다.<br>키워드var, let, const중에서 var와 let은 값의 재할당이 가능하다.<br>따지면 쓰레기값에 값을 할당하는것도 재할당하는 것이다.<br>ex)<br>var mandoo; // mandoo라는 변수에는 값을 할당하지 않았지만 보이지않는 초기값인 쓰레기값을 갖고있다.<br>mandoo = 20; // mandoo라는 변수에 숫자20 값을 할당했다. = 쓰레기값에 숫자20을 재할당했다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/11/My-HTML5-CSS3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/My-HTML5-CSS3/" class="post-title-link" itemprop="url">My HTML5 & CSS3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-11 16:45:49" itemprop="dateCreated datePublished" datetime="2020-08-11T16:45:49+09:00">2020-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-19 23:55:42" itemprop="dateModified" datetime="2020-08-19T23:55:42+09:00">2020-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hi, This is my TIL(Today I Learn). Welcome.</p>
<h2 id="HTML의-ATTRIBUTE-와-CSS의-PROPERTY의-차이"><a href="#HTML의-ATTRIBUTE-와-CSS의-PROPERTY의-차이" class="headerlink" title="HTML의 ATTRIBUTE 와 CSS의 PROPERTY의 차이"></a>HTML의 ATTRIBUTE 와 CSS의 PROPERTY의 차이</h2><ul>
<li><strong>HTML의 ATTRIBUTE</strong>: 속성이라는 뜻. html문서에서 elements(요소들)에 추가적인 정보를 넣을 때 사용되는 요소. 정적(변하지 않음)이다.<br>예) <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my-study&quot;</span>&gt;</span>HI<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
위의 코드에서 <code>&quot;my-study&quot;</code>는 <code>&lt;div&gt;</code>의 element(요소)이고, <code>class</code>는 attribute(속성, <strong>추가정보</strong>)가 된다.<br><code>my-study&quot;</code>는 class attribute의 value(값)가 됨.</li>
<li><strong>CSS의 PROPERTY</strong>: 특성, 요소라는 뜻. html DOM안에서 attribute를 가리키는/대신하는 표현. 동적(값이 변할 수 있음)이다.<br>예) 위의 예에서 DOM 노드트리로 표현한 것에서  className <code>&quot;my-study&quot;</code>가 property가 됨.<br>CSS에서의 font-size와 color는 property이다. font-size와 color는 태어날 때부터 가지고 있는 속성이 있지만 바뀔 수 있다. 그래서 동적과 정적이라고 함.</li>
</ul>
<h2 id="HTML이란"><a href="#HTML이란" class="headerlink" title="HTML이란"></a>HTML이란</h2><ul>
<li><strong>H</strong>yper<strong>T</strong>ext<strong>M</strong>arkup<strong>L</strong>anguage =  문서와 문서가 태그로 이루어져있고 링크로 연결되어있는 언어. 마크업 언어이다.</li>
<li>웹의 아버지 : 팀 버너스리<br>웹을 이루는 가장 기초적인 구성 요소이다.<br>hypertext는 다른 text에 대한 link를 포함하는 text이다. = text와 text가 link로 연결되어 있다.</li>
</ul>
<p><strong>1. W</strong>eb Standards 웹표준기술<br><strong>2. W</strong>eb Accessibilty 윕 접근성 - 한가지 대안만 사용하지 않는다.</p>
<ul>
<li>예) 계단 옆의 경사로. </li>
<li>접근을 생각해보면 떠오르는 장애 접근성. </li>
<li>장애에 대한 이해: 시각장애(전맹, 저시력), 청각장애, 지체장애(절단 및 지체기능 장애), 뇌변병장애</li>
<li>장애 환경에 대한 이해: 다양한 Platform, Cross Browsing(크롬이나 익스플로러등 다양한 환경), SEO(Search Engine Optimization), 저사양 또는 저속 회선</li>
<li>장애는 틀린것이 아닌 다른것임. 다름을 인정해야 한다.</li>
</ul>
<p><strong>3.</strong> HTML의 탄생 ( 운영체제 - vender )</p>
<ul>
<li>IE - MS</li>
<li>Chrome - Google</li>
<li>Safari - Apple</li>
<li>Firefox - Gojira</li>
<li>Opera - Opera</li>
</ul>
<p><strong>4. WHATWG</strong></p>
<ul>
<li>웹 하이퍼텍스트 애플리케이션 테크놀로지 워킹 그룹(Web Hypertext Application Technology Working Group, WHATWG)은 HTML 및 관련 기술을 발전시키는 데 관심이 있는 사람들의 모임이다. 2004년 애플, 모질라 재단, 오페라 소프트웨어의 개인들이 설립하였다. 그 후, 당시 WHATWG 규격의 편집장이었던 이안 힉슨(Ian Hickson)이 오페라 소프트웨어에서 구글로 이직함에 따라 구글도 WHATWG의 일원이 됐다.<br>WHATWG는 멤버스(Members)로 불리는 초대 전용의 조그마한 감시 위원회를 가지고 있으며 이 위원회는 규격을 맡은 편집장을 탄핵할 권한을 가지고 있다. 누구든지 WHATWG 메일링 리스트에 참가하여 기여자로 참여할 수 있다.</li>
</ul>
<h2 id="CSS란"><a href="#CSS란" class="headerlink" title="CSS란"></a>CSS란</h2><ul>
<li><strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets = 사용자에게 문서를 표시하는 방법을 지정하는 언어.<br>웹 이전부터 워드프로세서 등에서 사용했던 개념.</li>
<li>프론트 엔드의 3대장(HTML5, CSS3, JavaScript)중 1대장은 JavaScript이다.</li>
<li>Web기술의 설정 값으로 HTML5는 건강한 신체이고  CSS3은 근사한 스타일링을 맡는다고 할 수 있다.<br>CSS는 스타일링할때에 설계가 필요하고 기획, 디자인 또한 필요하다.<br>JavaScript는 스마트한 두뇌의 역할이라 코어까지 들어가면 어렵게 느껴질 수 있다.</li>
<li>요소 배치 방법<br>: display, float, position, table, flex, grid</li>
</ul>
<p><strong>1.</strong> FLOAT 배치방법 </p>
<ul>
<li>classic버전.</li>
<li>도움이 되는 동영상 = <a target="_blank" rel="noopener" href="https://youtu.be/xara4Z1b18I" title="CSS float이해">Youtube</a>링크 클릭.</li>
<li>노멀플로우(Normal Flow)는 띄워지지 않은, 바닥에 위치해있는 기본위치를 의미한다.<br>float과 position(중 absolute)를 요소에 지정하면 공중에 띄워진다.</li>
<li>float의 기본 값은 none이고 left와 right를 지정할 수 있다.</li>
<li>float은 block레이아웃의 사용을 뜻하기 때문에 float을 하면 block요소로 바뀐다.</li>
<li>group에 float을 적용하게 되면 부모인 main이 자식요소인 group을 알 수 없게 되어 높이를 잃어버리고, 뒤쪽에 오는 다른 요소들에게도 float이 영향을 끼치게 되기 때문에 clearfix를 사용하여 float을 해제하고 부모가 자식의 높이를 인지할 수 있도록 해줘야 한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/11/My-Brand-New-POST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/My-Brand-New-POST/" class="post-title-link" itemprop="url">My Brand New POST</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-11 15:49:58" itemprop="dateCreated datePublished" datetime="2020-08-11T15:49:58+09:00">2020-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-12 12:44:36" itemprop="dateModified" datetime="2020-08-12T12:44:36+09:00">2020-08-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HELLO WORLD!</p>
<p>What a beautiful World!! lol</p>
<p>Hi, there!<br>Nice to meet you!</p>
<p>Do you know <strong>Eddie Redmayne</strong>?<br>He is my favorite actor in space.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://do-mandoo.github.io/2020/08/11/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JinSol">
      <meta itemprop="description" content="All Dev stories found in here">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JINLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-11 15:39:26" itemprop="dateCreated datePublished" datetime="2020-08-11T15:39:26+09:00">2020-08-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JinSol</p>
  <div class="site-description" itemprop="description">All Dev stories found in here</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JinSol</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
